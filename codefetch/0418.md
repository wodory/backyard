Project Structure:
├── LICENSE
├── README.md
├── codefetch
│   ├── 0417-edge.md
│   └── 0417-login-fail.md
├── codefetch.config.mjs
├── components.json
├── dev.log
├── eslint.config.mjs
├── html
│   ├── bg.png
│   ├── favicon.ico
│   ├── favicon.svg
│   ├── html.meta.json.gz
│   └── index.html
├── lint-errors.txt
├── lint.json
├── lint.txt
├── logs
│   └── client-logs.json
├── next-env.d.ts
├── next.config.ts
├── package copy.json
├── package.json
├── postcss.config.mjs
├── prisma
│   ├── dev.db
│   ├── schema.master.prisma
│   ├── schema.postgresql.prisma
│   ├── schema.prisma
│   ├── schema.production.prisma
│   ├── schema.sqlite.prisma
├── public
│   ├── file.svg
│   ├── globe.svg
│   ├── next.svg
│   ├── vercel.svg
│   └── window.svg
├── scripts
│   ├── check-port.js
│   ├── coverage-report.js
│   ├── create-user.js
│   ├── pre-deploy.js
│   ├── run-tests.sh
│   ├── schema-sync.js
│   ├── select-db.js
│   ├── test-db.js
│   └── update-file-dates.js
├── server.pid
├── src
│   ├── middleware.ts
├── supabase
│   ├── config.toml
│   └── schema.sql
├── tailwind.config.js
├── tsc.txt
├── tsconfig.jest.json
├── tsconfig.json
├── tsconfig.tsbuildinfo
├── types
│   └── vitest.d.ts
├── update-modified-dates.js
├── vite.config.ts
├── vitest
│   └── failed-files-reporter.js
├── vitest.config.ts
└── yarn.lock


next-env.d.ts
```
1 | /// <reference types="next" />
2 | /// <reference types="next/image-types/global" />
3 | 
4 | // NOTE: This file should not be edited
5 | // see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
```

next.config.ts
```
1 | import type { NextConfig } from "next";
2 | 
3 | const nextConfig: NextConfig = {
4 |   /* config options here */
5 |   compiler: {
6 |     reactRemoveProperties: process.env.NODE_ENV === 'production' ? 
7 |       { properties: ['^data-testid$'] } : undefined,
8 |   },
9 |   // 빠른 배포를 위해 ESLint 검사 비활성화
10 |   eslint: {
11 |     ignoreDuringBuilds: true,
12 |   },
13 |   // 빠른 배포를 위해 타입 검사 비활성화
14 |   typescript: {
15 |     ignoreBuildErrors: true,
16 |   },
17 |   // React Flow 및 관련 패키지 트랜스파일 설정
18 |   transpilePackages: ['@xyflow/react', 'zustand'],
19 | };
20 | 
21 | export default nextConfig;
```

tailwind.config.js
```
1 | /** @type {import('@tailwindcss/postcss').TailwindConfig} */
2 | export default {
3 |   mode: "css", // CSS 모드 사용
4 |   inputPath: "./src/app/globals.css", // 입력 CSS 파일 경로
5 |   plugins: [
6 |     "tailwindcss-animate", // 애니메이션 플러그인 (이미 설치됨)
7 |   ],
8 |   font: {
9 |     sans: ["Pretendard", "sans-serif"], // 기본 폰트 설정
10 |   },
11 |   colors: {
12 |     // 기본 색상 설정
13 |     primary: "oklch(0.208 0.042 265.755)",
14 |     secondary: "oklch(0.968 0.007 247.896)",
15 |     background: "oklch(1 0 0)",
16 |     foreground: "oklch(0.129 0.042 264.695)",
17 |   },
18 |   colorMode: {
19 |     default: "light", // 기본 컬러 모드
20 |     selector: ".dark", // 다크 모드 선택자
21 |   },
22 |   rules: [
23 |     // 커스텀 변형 규칙
24 |     ["dark", "&:is(.dark *)"],
25 |   ],
26 | } 
```

update-modified-dates.js
```
1 | /**
2 |  * 파일명: update-modified-dates.js
3 |  * 목적: 파일의 수정일 주석을 정리하고 git 이력과 일치시키는 스크립트
4 |  * 역할: 1. 여러 개의 수정일이 있다면 가장 최근 것만 유지, 2. git log 기반으로 수정일 업데이트
5 |  * 작성일: 2024-05-09
6 |  */
7 | 
8 | const { exec } = require('child_process');
9 | const fs = require('fs');
10 | const path = require('path');
11 | const { promisify } = require('util');
12 | 
13 | const readdir = promisify(fs.readdir);
14 | const readFile = promisify(fs.readFile);
15 | const writeFile = promisify(fs.writeFile);
16 | const stat = promisify(fs.stat);
17 | const execPromise = promisify(exec);
18 | 
19 | const rootDir = process.cwd(); // 현재 디렉토리(프로젝트 루트)
20 | 
21 | // 대상 파일 확장자
22 | const fileExtensions = ['.ts', '.tsx', '.js', '.jsx', '.md'];
23 | 
24 | // 제외할 디렉토리
25 | const excludeDirs = ['node_modules', '.git', 'dist', 'build', '.next', 'html'];
26 | 
27 | // git log에서 파일의 마지막 수정 날짜 가져오기
28 | async function getLastModifiedDateFromGit(filePath) {
29 |     try {
30 |         const relativeFilePath = path.relative(rootDir, filePath);
31 |         const { stdout } = await execPromise(`git log -1 --format="%ad" --date=short -- "${relativeFilePath}"`);
32 |         return stdout.trim(); // YYYY-MM-DD 형식
33 |     } catch (error) {
34 |         console.error(`Git log error for ${filePath}:`, error.message);
35 |         return null;
36 |     }
37 | }
38 | 
39 | // 주어진 파일에서 수정일 주석 정리
40 | async function processFile(filePath) {
41 |     try {
42 |         const content = await readFile(filePath, 'utf8');
43 | 
44 |         // 수정일 주석 여러 개 있는지 확인
45 |         const modificationDateRegex = /\* 수정일: (\d{4}-\d{2}-\d{2}).*$/gm;
46 |         const matches = [...content.matchAll(modificationDateRegex)];
47 | 
48 |         // 파일에 수정일 주석이 없으면 git에서 최종 수정일 가져오기
49 |         let lastDate = await getLastModifiedDateFromGit(filePath);
50 | 
51 |         if (!lastDate) {
52 |             console.log(`Git 히스토리를 찾을 수 없음: ${filePath}`);
53 |             return;
54 |         }
55 | 
56 |         let updatedContent = content;
57 | 
58 |         // 수정일 주석이 없고, 작성일 주석이 있는 경우에만 추가
59 |         if (matches.length === 0) {
60 |             const creationDateRegex = /\* 작성일: (\d{4}-\d{2}-\d{2})/;
61 |             const creationMatch = content.match(creationDateRegex);
62 | 
63 |             if (creationMatch) {
64 |                 const creationDate = creationMatch[1];
65 | 
66 |                 // 작성일과 최종 수정일이 다른 경우에만 수정일 추가
67 |                 if (creationDate !== lastDate) {
68 |                     updatedContent = content.replace(
69 |                         creationDateRegex,
70 |                         `* 작성일: ${creationDate}\n * 수정일: ${lastDate}`
71 |                     );
[TRUNCATED]
```

vite.config.ts
```
1 | /**
2 |  * 파일명: vite.config.ts
3 |  * 목적: Vite 빌드 도구 설정
4 |  * 역할: 프로젝트의 빌드 및 개발 환경 설정 제공
5 |  * 작성일: 2024-03-31
6 |  * 수정일: 2025-04-11
7 |  */
8 | 
9 | import { dirname, resolve } from 'path';
10 | import { fileURLToPath } from 'url';
11 | 
12 | import react from '@vitejs/plugin-react';
13 | import { defineConfig } from 'vite';
14 | 
15 | // ESM에서 __dirname 대체
16 | const __filename = fileURLToPath(import.meta.url);
17 | const __dirname = dirname(__filename);
18 | 
19 | export default defineConfig({
20 |   plugins: [react()],
21 |   resolve: {
22 |     alias: {
23 |       '@': resolve(__dirname, './src'),
24 |     },
25 |   },
26 | }); 
```

vitest.config.ts
```
1 | /**
2 |  * 파일명: viconfig.ts
3 |  * 목적: Vitest 테스트 환경 설정
4 |  * 역할: 테스트 실행을 위한 Vite 설정과 통합된 설정 제공
5 |  * 작성일: 2024-03-31
6 |  * 수정일: 2025-04-11
7 |  */
8 | 
9 | import { dirname, resolve } from 'path';
10 | import { fileURLToPath } from 'url';
11 | 
12 | import { loadEnv } from 'vite';
13 | import { defineConfig, mergeConfig } from 'vitest/config';
14 | 
15 | import viteConfig from './vite.config.js';
16 | 
17 | // ESM에서 __dirname 대체
18 | const __filename = fileURLToPath(import.meta.url);
19 | const __dirname = dirname(__filename);
20 | 
21 | export default mergeConfig(
22 |   viteConfig,
23 |   defineConfig({
24 |     test: {
25 |       // 환경 변수 설정
26 |       env: loadEnv('test', process.cwd(), ''),
27 |       
28 |       // 테스트 환경 설정
29 |       environment: 'jsdom',
30 |       globals: true,
31 |       setupFiles: ['./src/tests/setup.ts'],
32 |       
33 |       // 성능 최적화 설정
34 |       testTimeout: 2000, // 전역 타임아웃 설정 (2초로 변경)
35 |       hookTimeout: 2000, // 훅 타임아웃 설정 (2초로 변경)
36 |       pool: 'threads',
37 |       poolOptions: {
38 |         threads: {
39 |           singleThread: false,
40 |         },
41 |       },
42 |       isolate: true,
43 |       
44 |       // Node.js v20의 Undici 타임아웃 문제 처리
45 |       environmentOptions: {
46 |         // jsdom 환경에서 글로벌 변수 설정
47 |         jsdom: {
48 |           // JS 타이머 이벤트가 즉시 처리되도록 설정
49 |           // Undici의 타임아웃 이슈 해결
50 |           pretendToBeVisual: true,
51 |         }
52 |       },
53 |       
54 |       // 테스트 파일 패턴 설정
55 |       include: ['src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
56 |       exclude: [
57 |         '**/node_modules/**',
58 |         '**/dist/**',
59 |         '**/.next/**', // Next.js 빌드 결과물
60 |         '**/coverage/**', // 커버리지 리포트 폴더
61 |         '**/.{idea,git,cache,output,temp}/**',
62 |         '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,storybook,eslint,prettier}.config.*', // 각종 설정 파일
63 |         '**/prisma/seed/**', // Prisma Seed 파일
64 |         '**/scripts/**', // 스크립트 폴더
65 |         '**/src/tests/**', // 테스트 관련 폴더
66 |         '**/src/components/board/nodes/NodeInspect*.tsx', //디버깅용 NodeInspector
67 |         // src/lib
68 |         '**/src/lib/debug-utils.ts',  // 디버깅 유틸리티 
69 |         '**/test-utils.ts',                
70 |         '**/src/lib/cookie.ts',
71 |         '**/src/lib/auth-server.ts',
72 |         '**/src/lib/prisma.ts',
73 |         '**/src/lib/supabase-instance.ts',
74 |         '**/src/lib/supabase-server.ts',
75 |         '**/src/lib/supabase.ts',
76 |         '**/src/lib/debug-utils.ts',
77 |         '**/src/lib/ideamap-utils.ts',
78 |         '**/src/lib/layout-utils.ts',
79 |         // root       // 모든 서브 폴더의 test-utils.ts 파일 제외
80 |         './*.config.js', // 루트 경로의 config 파일들
81 |         './*.config.ts',
82 |         './*.config.mjs',
[TRUNCATED]
```

scripts/check-port.js
```
1 | /**
2 |  * 파일명: check-port.js
3 |  * 목적: 포트 3000이 사용 중인지 확인하고 필요시 프로세스 종료
4 |  * 역할: 개발 서버 실행 전 포트 충돌 예방
5 |  * 작성일: 2024-03-24
6 |  * 수정일: 2025-03-26
7 |  */
8 | 
9 | import { execSync } from 'child_process';
10 | import os from 'os';
11 | 
12 | const PORT = 3000;
13 | 
14 | function checkPort() {
15 |   console.log(`\n🔍 포트 ${PORT} 상태 확인 중...`);
16 | 
17 |   try {
18 |     let command;
19 |     let processIdCommand;
20 | 
21 |     // OS별 명령어 설정
22 |     if (os.platform() === 'win32') {
23 |       // Windows
24 |       command = `netstat -ano | findstr :${PORT}`;
25 |       processIdCommand = (line) => {
26 |         const parts = line.trim().split(/\s+/);
27 |         return parts[parts.length - 1];
28 |       };
29 |     } else {
30 |       // macOS, Linux
31 |       command = `lsof -i :${PORT}`;
32 |       processIdCommand = (line) => {
33 |         const parts = line.trim().split(/\s+/);
34 |         return parts[1];
35 |       };
36 |     }
37 | 
38 |     // 명령어 실행 및 결과 가져오기
39 |     const result = execSync(command, { encoding: 'utf8' });
40 | 
41 |     if (result && result.trim()) {
42 |       console.log(`⚠️ 포트 ${PORT}가 이미 사용 중입니다.`);
43 | 
44 |       // 결과에서 PID 추출
45 |       const lines = result.split('\n').filter(Boolean);
46 | 
47 |       // 헤더 라인 제외 (macOS/Linux의 lsof 명령어는 헤더가 있음)
48 |       const processLines = os.platform() === 'win32' ? lines : lines.slice(1);
49 | 
50 |       if (processLines.length > 0) {
51 |         // 첫 번째 프로세스의 PID 추출
52 |         const pid = processIdCommand(processLines[0]);
53 | 
54 |         if (pid) {
55 |           console.log(`👉 PID ${pid} 프로세스 종료 중...`);
56 | 
57 |           try {
58 |             // 프로세스 종료
59 |             if (os.platform() === 'win32') {
60 |               execSync(`taskkill /F /PID ${pid}`);
61 |             } else {
62 |               execSync(`kill -9 ${pid}`);
63 |             }
64 |             console.log(`✅ 포트 ${PORT}를 사용하던 프로세스(PID: ${pid})가 종료되었습니다.`);
65 |           } catch (killError) {
66 |             console.error(`❌ 프로세스(PID: ${pid}) 종료 실패:`, killError.message);
67 |             process.exit(1);
68 |           }
69 |         }
70 |       }
71 |     } else {
72 |       console.log(`✅ 포트 ${PORT}는 사용 가능합니다.`);
73 |     }
74 |   } catch (error) {
75 |     // 명령어 실행 오류 - 보통 "포트가 사용 중이 아님"을 의미
76 |     console.log(`✅ 포트 ${PORT}는 사용 가능합니다.`);
77 |   }
78 | }
79 | 
[TRUNCATED]
```

scripts/coverage-report.js
```
1 | import fs from 'fs';
2 | import path from 'path';
3 | import { fileURLToPath } from 'url';
4 | 
5 | // __dirname 대체
6 | const __filename = fileURLToPath(import.meta.url);
7 | const __dirname = path.dirname(__filename);
8 | 
9 | // 파라미터
10 | const sortBy = process.argv[2] || 'LoC';
11 | 
12 | // 파일 읽기
13 | const coveragePath = path.resolve(__dirname, '../coverage/coverage-summary.json');
14 | 
15 | if (!fs.existsSync(coveragePath)) {
16 |     console.error('❌ coverage-summary.json 파일이 존재하지 않습니다.');
17 |     process.exit(1);
18 | }
19 | 
20 | const summary = JSON.parse(fs.readFileSync(coveragePath, 'utf-8'));
21 | delete summary.total;
22 | 
23 | const rows = Object.entries(summary).map(([filePath, metrics]) => {
24 |     const folder = path.dirname(filePath);
25 |     const file = path.basename(filePath);
26 |     const lines = metrics.lines || {};
27 |     const branches = metrics.branches || {};
28 |     const functions = metrics.functions || {};
29 | 
30 |     return {
31 |         '파일명': file,
32 |         '폴더': folder,
33 |         'LoC': lines.total || 0,
34 |         '브랜치 커버리지': branches.pct || 0,
35 |         '함수 커버리지': functions.pct || 0,
36 |         '라인 커버리지': lines.pct || 0,
37 |         'uncovered Line': (lines.total || 0) - (lines.covered || 0),
38 |     };
39 | });
40 | 
41 | // 정렬
42 | const validSort = rows[0].hasOwnProperty(sortBy) ? sortBy : 'LoC';
43 | rows.sort((a, b) => b[validSort] - a[validSort]);
44 | 
45 | // 출력
46 | const printTable = (data) => {
47 |     if (data.length === 0) {
48 |         console.log('데이터가 없습니다.');
49 |         return;
50 |     }
51 | 
52 |     const headers = Object.keys(data[0]);
53 |     const colWidths = headers.map(header =>
54 |         Math.max(header.length, ...data.map(row => String(row[header] ?? '').length))
55 |     );
56 | 
57 |     const formatRow = (rowOrHeader) =>
58 |         headers.map((h, i) => String(rowOrHeader[h] ?? rowOrHeader[i] ?? '').padEnd(colWidths[i])).join(' | ');
59 | 
60 |     const separator = colWidths.map(w => '-'.repeat(w)).join('-|-');
61 | 
62 |     // ✅ 수정된 출력
63 |     console.log(formatRow(headers));
64 |     console.log(separator);
65 |     data.forEach(row => console.log(formatRow(row)));
66 | };
67 | 
68 | 
69 | printTable(rows);
```

scripts/create-user.js
```
1 | const { PrismaClient } = require('@prisma/client');
2 | const prisma = new PrismaClient();
3 | 
4 | async function main() {
5 |   try {
6 |     const user = await prisma.user.create({
7 |       data: {
8 |         email: 'test@example.com',
9 |         name: 'Test User'
10 |       }
11 |     });
12 |     console.log('Created user:', user);
13 |   } catch (error) {
14 |     console.error('Error creating user:', error);
15 |   } finally {
16 |     await prisma.$disconnect();
17 |   }
18 | }
19 | 
20 | main(); 
```

scripts/pre-deploy.js
```
1 | #!/usr/bin/env node
2 | 
3 | /**
4 |  * 배포 전 환경 설정 스크립트
5 |  * 
6 |  * 이 스크립트는 Vercel 등의 프로덕션 환경에 배포하기 전에
7 |  * 환경 파일을 확인하고 필요한 설정을 적용합니다.
8 |  */
9 | 
10 | import { execSync } from 'child_process';
11 | import fs from 'fs';
12 | import path from 'path';
13 | import { fileURLToPath } from 'url';
14 | 
15 | // __dirname 대체
16 | const __filename = fileURLToPath(import.meta.url);
17 | const __dirname = path.dirname(__filename);
18 | 
19 | console.log('배포 전 환경 설정 확인 중...');
20 | 
21 | // 기본 필수 환경 변수 목록
22 | let requiredEnvVars = [
23 |   'DATABASE_PROVIDER',
24 |   'DATABASE_URL'
25 | ];
26 | 
27 | // 데이터베이스 프로바이더에 따라 추가 변수 검증
28 | if (process.env.DATABASE_PROVIDER === 'postgresql') {
29 |   requiredEnvVars.push('DIRECT_URL');
30 |   requiredEnvVars.push('NEXT_PUBLIC_SUPABASE_URL');
31 |   requiredEnvVars.push('NEXT_PUBLIC_SUPABASE_ANON_KEY');
32 | 
33 |   if (process.env.NODE_ENV === 'production') {
34 |     requiredEnvVars.push('NEXT_PUBLIC_OAUTH_REDIRECT_URL');
35 |   }
36 | }
37 | 
38 | // 환경 변수 검증
39 | const missingEnvVars = requiredEnvVars.filter(envVar => !process.env[envVar]);
40 | 
41 | if (missingEnvVars.length > 0) {
42 |   console.error('❌ 누락된 환경 변수가 있습니다:');
43 |   missingEnvVars.forEach(envVar => {
44 |     console.error(`   - ${envVar}`);
45 |   });
46 |   process.exit(1);
47 | }
48 | 
49 | console.log('✅ 모든 필수 환경 변수가 설정되어 있습니다.');
50 | 
51 | // 프로덕션 환경 확인
52 | if (process.env.NODE_ENV === 'production') {
53 |   console.log('프로덕션 환경 감지: 설정을 확인합니다...');
54 | 
55 |   if (process.env.DATABASE_PROVIDER !== 'postgresql') {
56 |     console.error('❌ 프로덕션 환경에서는 DATABASE_PROVIDER가 postgresql이어야 합니다.');
57 |     process.exit(1);
58 |   }
59 | 
60 |   if (process.env.DATABASE_PROVIDER === 'postgresql' && !process.env.DATABASE_URL.includes('supabase.co')) {
61 |     console.error('❌ 프로덕션 환경에서 DATABASE_URL이 Supabase 연결 문자열이 아닙니다.');
62 |     process.exit(1);
63 |   }
64 | }
65 | 
66 | console.log('✅ 환경 설정 확인 완료');
67 | 
68 | // Prisma 클라이언트 생성
69 | console.log('Prisma 클라이언트를 생성합니다...');
70 | try {
71 |   execSync('npx prisma generate', { stdio: 'inherit' });
72 |   console.log('✅ Prisma 클라이언트가 생성되었습니다.');
73 | } catch (error) {
74 |   console.error(`⚠️ Prisma 클라이언트 생성 중 오류가 발생했습니다: ${error.message}`);
75 |   console.error('하지만 배포 과정을 계속 진행합니다.');
76 | } 
```

scripts/schema-sync.js
```
1 | #!/usr/bin/env node
2 | 
3 | /**
4 |  * Prisma 스키마 동기화 스크립트
5 |  * 
6 |  * 이 스크립트는 마스터 템플릿에서 각 환경별 스키마를 생성합니다.
7 |  */
8 | import fs from 'fs';
9 | import path from 'path';
10 | import { fileURLToPath } from 'url';
11 | 
12 | // __dirname 대체
13 | const __filename = fileURLToPath(import.meta.url);
14 | const __dirname = path.dirname(__filename);
15 | 
16 | // 경로 설정
17 | const basePath = path.join(__dirname, '../prisma');
18 | const masterSchemaPath = path.join(basePath, 'schema.master.prisma');
19 | const sqliteSchemaPath = path.join(basePath, 'schema.sqlite.prisma');
20 | const postgresSchemaPath = path.join(basePath, 'schema.postgresql.prisma');
21 | 
22 | console.log('Prisma 스키마 동기화를 시작합니다...');
23 | 
24 | // 마스터 스키마 파일 확인
25 | if (!fs.existsSync(masterSchemaPath)) {
26 |   console.log('마스터 스키마 파일이 없습니다. 현재 schema.prisma를 마스터로 사용합니다.');
27 |   const currentSchemaPath = path.join(basePath, 'schema.prisma');
28 |   if (fs.existsSync(currentSchemaPath)) {
29 |     fs.copyFileSync(currentSchemaPath, masterSchemaPath);
30 |     console.log(`현재 스키마를 마스터 템플릿으로 복사했습니다: ${masterSchemaPath}`);
31 |   } else {
32 |     console.error('오류: 현재 스키마 파일도 찾을 수 없습니다!');
33 |     process.exit(1);
34 |   }
35 | }
36 | 
37 | // 마스터 스키마 읽기
38 | console.log(`마스터 스키마 파일 읽기: ${masterSchemaPath}`);
39 | const masterSchema = fs.readFileSync(masterSchemaPath, 'utf8');
40 | 
41 | // SQLite 스키마 생성
42 | const sqliteSchema = masterSchema
43 |   .replace(/provider(\s*)=(\s*)"postgresql"/g, 'provider$1=$2"sqlite"')
44 |   .replace(/directUrl(\s*)=(\s*)env\("DIRECT_URL"\)/g, '')
45 |   .replace(/extensions(\s*)=(\s*)\[.*?\]/g, '')
46 |   .replace(/\/\/ This is your Prisma schema file for.*?,/g, '// This is your Prisma schema file for SQLite,');
47 | 
48 | // PostgreSQL 스키마 생성
49 | const postgresSchema = masterSchema
50 |   .replace(/provider(\s*)=(\s*)"sqlite"/g, 'provider$1=$2"postgresql"')
51 |   .replace(/\/\/ This is your Prisma schema file for.*?,/g, '// This is your Prisma schema file for PostgreSQL,');
52 | 
53 | // 생성된 스키마 파일 저장
54 | fs.writeFileSync(sqliteSchemaPath, sqliteSchema);
55 | console.log(`SQLite 스키마 파일이 생성되었습니다: ${sqliteSchemaPath}`);
56 | 
57 | fs.writeFileSync(postgresSchemaPath, postgresSchema);
58 | console.log(`PostgreSQL 스키마 파일이 생성되었습니다: ${postgresSchemaPath}`);
59 | 
60 | console.log('스키마 동기화가 완료되었습니다.');
61 | console.log('이제 환경에 맞는 스키마를 적용하려면 다음 명령을 실행하세요:');
62 | console.log('- 개발 환경: yarn db:setup:dev');
63 | console.log('- 프로덕션 환경: yarn db:setup:prod');
64 | 
```

scripts/select-db.js
```
1 | #!/usr/bin/env node
2 | 
3 | import fs from 'fs';
4 | import path from 'path';
5 | import { fileURLToPath } from 'url';
6 | 
7 | // __dirname 대체
8 | const __filename = fileURLToPath(import.meta.url);
9 | const __dirname = path.dirname(__filename);
10 | 
11 | // 환경 확인
12 | const isProduction = process.env.NODE_ENV === 'production';
13 | const dbType = isProduction ? 'postgresql' : 'sqlite';
14 | 
15 | // 경로 설정
16 | const basePath = path.join(__dirname, '../prisma');
17 | const schemaPath = path.join(basePath, 'schema.prisma');
18 | const sourceSchemaPath = path.join(basePath, `schema.${dbType}.prisma`);
19 | 
20 | console.log(`환경: ${isProduction ? '프로덕션' : '개발'}`);
21 | console.log(`데이터베이스: ${dbType}`);
22 | console.log(`소스 스키마: ${sourceSchemaPath}`);
23 | console.log(`타겟 스키마: ${schemaPath}`);
24 | 
25 | // 파일 복사
26 | try {
27 |   // 소스 파일 존재 확인
28 |   if (!fs.existsSync(sourceSchemaPath)) {
29 |     console.error(`오류: 소스 스키마 파일을 찾을 수 없습니다: ${sourceSchemaPath}`);
30 |     process.exit(1);
31 |   }
32 | 
33 |   // 파일 복사
34 |   fs.copyFileSync(sourceSchemaPath, schemaPath);
35 |   console.log(`✅ 성공: ${dbType} 스키마를 복사했습니다.`);
36 | 
37 |   // Prisma 생성 명령어 안내
38 |   console.log('이제 다음 명령어를 실행하세요: npx prisma generate');
39 | } catch (error) {
40 |   console.error(`❌ 오류 발생: ${error.message}`);
41 |   process.exit(1);
42 | } 
```

scripts/test-db.js
```
1 | // 데이터베이스 연결 테스트 스크립트
2 | import { PrismaClient } from '@prisma/client';
3 | 
4 | async function main() {
5 |   console.log('데이터베이스 연결 테스트 시작...');
6 |   console.log('환경 변수:', {
7 |     NODE_ENV: process.env.NODE_ENV,
8 |     DATABASE_URL: process.env.DATABASE_URL,
9 |     DATABASE_PROVIDER: process.env.DATABASE_PROVIDER
10 |   });
11 | 
12 |   try {
13 |     const prisma = new PrismaClient();
14 |     console.log('Prisma 클라이언트 초기화 성공');
15 | 
16 |     // 연결 테스트
17 |     console.log('데이터베이스 연결 시도 중...');
18 |     await prisma.$connect();
19 |     console.log('데이터베이스 연결 성공!');
20 | 
21 |     // 간단한 쿼리 테스트
22 |     console.log('사용자 조회 시도 중...');
23 |     const users = await prisma.user.findMany({ take: 5 });
24 |     console.log(`사용자 조회 성공: ${users.length}명의 사용자 발견`);
25 | 
26 |     // 연결 종료
27 |     await prisma.$disconnect();
28 |     console.log('데이터베이스 연결 종료');
29 |   } catch (error) {
30 |     console.error('에러 발생:', error);
31 |   }
32 | }
33 | 
34 | main(); 
```

scripts/update-file-dates.js
```
1 | /**
2 |  * 파일명: scripts/update-file-dates.js
3 |  * 목적: 코드베이스 파일의 작성일 헤더를 수정
4 |  * 역할: 2024년 또는 이상한 날짜가 있는 파일의 헤더를 파일 생성 날짜로 업데이트
5 |  * 작성일: 2023-05-26
6 |  */
7 | 
8 | const { exec } = require('child_process');
9 | const fs = require('fs');
10 | const path = require('path');
11 | const util = require('util');
12 | const execPromise = util.promisify(exec);
13 | 
14 | // src 디렉토리 경로
15 | const srcDir = path.join(__dirname, '../src');
16 | 
17 | // 파일 생성 날짜를 가져오는 함수 (git log를 사용하여 첫 커밋 날짜를 가져옴)
18 | async function getFileCreationDate(filePath) {
19 |     try {
20 |         // 상대 경로로 변환
21 |         const relativeFilePath = path.relative(path.join(__dirname, '..'), filePath);
22 | 
23 |         // git log를 사용하여 파일의 첫 커밋 날짜 가져오기
24 |         const { stdout } = await execPromise(`git log --follow --format="%ad" --date=short -- "${relativeFilePath}" | tail -1`);
25 | 
26 |         // 결과가 있으면 반환, 없으면 현재 날짜 반환
27 |         const gitDate = stdout.trim();
28 |         if (gitDate) {
29 |             return gitDate;
30 |         }
31 | 
32 |         // git 정보가 없는 경우 파일 생성일 가져오기
33 |         const stats = fs.statSync(filePath);
34 |         const date = new Date(stats.birthtime);
35 |         const year = date.getFullYear();
36 |         const month = String(date.getMonth() + 1).padStart(2, '0');
37 |         const day = String(date.getDate()).padStart(2, '0');
38 |         return `${year}-${month}-${day}`;
39 |     } catch (error) {
40 |         console.error(`Error getting creation date for ${filePath}:`, error);
41 | 
42 |         // 오류 발생 시 현재 날짜 반환
43 |         const now = new Date();
44 |         const year = now.getFullYear();
45 |         const month = String(now.getMonth() + 1).padStart(2, '0');
46 |         const day = String(now.getDate()).padStart(2, '0');
47 |         return `${year}-${month}-${day}`;
48 |     }
49 | }
50 | 
51 | // 날짜 형식 검증 및 2024년 날짜 확인
52 | function isDateInvalid(dateStr) {
53 |     // 날짜 형식 검증 (YYYY-MM-DD)
54 |     const datePattern = /^\d{4}-\d{2}-\d{2}$/;
55 |     if (!datePattern.test(dateStr)) {
56 |         return true;
57 |     }
58 | 
59 |     // 2024년 날짜 확인
60 |     if (dateStr.startsWith('2024-')) {
61 |         return true;
62 |     }
63 | 
64 |     // 날짜 유효성 검사
65 |     const [year, month, day] = dateStr.split('-').map(Number);
66 | 
67 |     // 월 범위 검사 (1-12)
68 |     if (month < 1 || month > 12) {
69 |         return true;
[TRUNCATED]
```

src/middleware.ts
```
1 | /**
2 |  * 파일명: middleware.ts
3 |  * 목적: Supabase 인증 토큰 새로고침을 위한 미들웨어
4 |  * 역할: 인증 토큰을 새로고침하고 브라우저와 서버 컴포넌트에 전달
5 |  * 작성일: 2025-03-08
6 |  * 수정일: 2025-03-27
7 |  * 수정일: 2024-05-08 : 인증된 사용자가 /login 페이지 접근 시 홈으로 리다이렉션하는 기능 추가
8 |  */
9 | 
10 | import { NextRequest, NextResponse } from 'next/server'
11 | 
12 | import { createServerClient } from '@supabase/ssr'
13 | 
14 | import { updateSession } from '@/lib/supabase/middleware'
15 | import { Database } from '@/types/supabase'
16 | 
17 | export async function middleware(request: NextRequest) {
18 |   // 먼저 세션 업데이트
19 |   const response = await updateSession(request)
20 |   
21 |   // 로그인 페이지 접근 체크
22 |   const url = new URL(request.url)
23 |   if (url.pathname === '/login') {
24 |     // Supabase 클라이언트 생성
25 |     const supabase = createServerClient<Database>(
26 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
27 |       process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
28 |       {
29 |         cookies: {
30 |           get(name: string) {
31 |             return request.cookies.get(name)?.value
32 |           },
33 |           set() {
34 |             // 미들웨어에서는 쿠키를 설정하지 않음
35 |           },
36 |           remove() {
37 |             // 미들웨어에서는 쿠키를 삭제하지 않음
38 |           },
39 |         },
40 |       }
41 |     )
42 |     
43 |     // 현재 사용자 세션 확인
44 |     const { data } = await supabase.auth.getSession()
45 |     
46 |     // 인증된 사용자가 로그인 페이지에 접근할 경우 홈으로 리다이렉션
47 |     if (data?.session) {
48 |       return NextResponse.redirect(new URL('/', request.url))
49 |     }
50 |   }
51 |   
52 |   return response
53 | }
54 | 
55 | export const config = {
56 |   matcher: [
57 |     /*
58 |      * Match all request paths except for the ones starting with:
59 |      * - _next/static (static files)
60 |      * - _next/image (image optimization files)
61 |      * - favicon.ico (favicon file)
62 |      * Feel free to modify this pattern to include more paths.
63 |      */
64 |     '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
65 |   ],
66 | } 
```

types/vitest.d.ts
```
1 | /// <reference types="vitest" />
2 | /// <reference types="@testing-library/jest-dom" />
3 | 
4 | import type { TestingLibraryMatchers } from '@testing-library/jest-dom/matchers';
5 | 
6 | declare global {
7 |   namespace Vi {
8 |     interface JestAssertion<T = any> 
9 |       extends jest.Matchers<void, T>,
10 |         TestingLibraryMatchers<T, void> {}
11 |   }
12 | 
13 |   // 테스트 환경에서 전역 fetch를 사용할 수 있도록 설정
14 |   var fetch: jest.Mock<Promise<Response>> & {
15 |     mockResolvedValue: (value: any) => jest.Mock;
16 |     mockRejectedValue: (error: any) => jest.Mock;
17 |     mockImplementation: (fn: (...args: any[]) => any) => jest.Mock;
18 |   };
19 | }
20 | 
21 | // Prisma 모킹 타입 확장
22 | declare module '@prisma/client' {
23 |   interface PrismaClient {
24 |     tag?: {
25 |       findUnique: jest.Mock<any, any>;
26 |       findMany: jest.Mock<any, any>; 
27 |       create: jest.Mock<any, any>;
28 |       delete: jest.Mock<any, any>;
29 |       update: jest.Mock<any, any>;
30 |     };
31 |     cardTag?: {
32 |       deleteMany: jest.Mock<any, any>;
33 |       create: jest.Mock<any, any>;
34 |       findMany: jest.Mock<any, any>;
35 |     };
36 |     card?: {
37 |       findUnique: jest.Mock<any, any>;
38 |       findMany: jest.Mock<any, any>;
39 |       create: jest.Mock<any, any>;
40 |       delete: jest.Mock<any, any>;
41 |       update: jest.Mock<any, any>;
42 |     };
43 |   }
44 | } 
```

vitest/failed-files-reporter.js
```
1 | // failed-files-reporter.js
2 | export default class FailedFilesReporter {
3 |     onFinished(results) {
4 |         // results.testFileResults는 각 테스트 파일의 결과 정보를 담고 있습니다.
5 |         const failedFiles = results.testFileResults
6 |             .filter(fileResult => fileResult.numFailingTests > 0)
7 |             .map(fileResult => fileResult.file)
8 | 
9 |         if (failedFiles.length > 0) {
10 |             console.log('\n실패한 테스트 파일:');
11 |             failedFiles.forEach(file => console.log(file))
12 |         }
13 |     }
14 | }
```

html/assets/index-CsZqQx26.js
```
1 | var DS=Object.defineProperty;var IS=(e,t,r)=>t in e?DS(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var us=(e,t,r)=>IS(e,typeof t!="symbol"?t+"":t,r);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))o(s);new MutationObserver(s=>{for(const c of s)if(c.type==="childList")for(const f of c.addedNodes)f.tagName==="LINK"&&f.rel==="modulepreload"&&o(f)}).observe(document,{childList:!0,subtree:!0});function r(s){const c={};return s.integrity&&(c.integrity=s.integrity),s.referrerPolicy&&(c.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?c.credentials="include":s.crossOrigin==="anonymous"?c.credentials="omit":c.credentials="same-origin",c}function o(s){if(s.ep)return;s.ep=!0;const c=r(s);fetch(s.href,c)}})();/**
2 | * @vue/shared v3.5.12
3 | * (c) 2018-present Yuxi (Evan) You and Vue contributors
4 | * @license MIT
[TRUNCATED]
```

prisma/seed/index.js
```
1 | import { PrismaClient } from '@prisma/client';
2 | const prisma = new PrismaClient();
3 | 
4 | async function main() {
5 |   try {
6 |     // 사용자 생성
7 |     const user = await prisma.user.upsert({
8 |       where: { email: 'test@example.com' },
9 |       update: {},
10 |       create: {
11 |         email: 'test@example.com',
12 |         name: 'Test User',
13 |         cards: {
14 |           create: [
15 |             {
16 |               title: '시작하기',
17 |               content: '백야드 프로젝트에 오신 것을 환영합니다!'
18 |             }
19 |           ]
20 |         }
21 |       }
22 |     });
23 | 
24 |     // 태그 생성
25 |     const welcomeTag = await prisma.tag.upsert({
26 |       where: { name: '환영' },
27 |       update: {},
28 |       create: { name: '환영' }
29 |     });
30 | 
31 |     // 카드-태그 연결
32 |     const cards = await prisma.card.findMany({
33 |       where: { userId: user.id }
34 |     });
35 | 
36 |     if (cards.length > 0) {
37 |       await prisma.cardTag.upsert({
38 |         where: {
39 |           cardId_tagId: {
40 |             cardId: cards[0].id,
41 |             tagId: welcomeTag.id
42 |           }
43 |         },
44 |         update: {},
45 |         create: {
46 |           cardId: cards[0].id,
47 |           tagId: welcomeTag.id
48 |         }
49 |       });
50 |     }
51 | 
52 |     console.log('Database seeded!');
53 |   } catch (error) {
54 |     console.error('Error seeding database:', error);
55 |   } finally {
56 |     await prisma.$disconnect();
57 |   }
58 | }
59 | 
60 | main(); 
```

src/app/layout.test.tsx
```
1 | /**
2 |  * 파일명: layout.test.tsx
3 |  * 목적: RootLayout 컴포넌트 테스트
4 |  * 역할: 레이아웃 컴포넌트의 기능과 구조 검증
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-03-30
7 |  * 수정일: 2025-04-27 : import 순서 정리
8 |  */
9 | 
10 | import { render, screen } from '@testing-library/react';
11 | import '@testing-library/jest-dom/vitest';
12 | import { describe, it, expect, vi, beforeEach } from 'vitest';
13 | 
14 | import RootLayout from './layout';
15 | import { metadata } from './metadata';
16 | 
17 | // next/font 모듈 모킹
18 | vi.mock('next/font/google', () => ({
19 |   Geist: vi.fn().mockReturnValue({
20 |     variable: 'mocked-geist-sans',
21 |   }),
22 |   Geist_Mono: vi.fn().mockReturnValue({
23 |     variable: 'mocked-geist-mono',
24 |   }),
25 | }));
26 | 
27 | // ClientLayout 모킹
28 | vi.mock('@/components/layout/ClientLayout', () => ({
29 |   ClientLayout: ({ children }: { children: React.ReactNode }) => (
30 |     <div data-testid="client-layout">{children}</div>
31 |   ),
32 | }));
33 | 
34 | describe('메타데이터 테스트', () => {
35 |   it('기본 메타데이터가 올바르게 설정되어 있어야 합니다', () => {
36 |     expect(metadata.title).toBeDefined();
37 |     expect(metadata.description).toBeDefined();
38 |   });
39 | });
40 | 
41 | describe('RootLayout 컴포넌트 테스트', () => {
42 |   beforeEach(() => {
43 |     render(
44 |       <RootLayout>
45 |         <div data-testid="test-child">Test Child</div>
46 |       </RootLayout>
47 |     );
48 |   });
49 | 
50 |   it('컴포넌트가 정의되어 있어야 합니다', () => {
51 |     expect(RootLayout).toBeDefined();
52 |   });
53 | 
54 |   it('자식 컴포넌트를 올바르게 렌더링해야 합니다', () => {
55 |     const testChild = screen.getByTestId('test-child');
56 |     expect(testChild).toBeInTheDocument();
57 |     expect(testChild).toHaveTextContent('Test Child');
58 |   });
59 | 
60 |   it('ClientLayout이 렌더링되어야 합니다', () => {
61 |     const clientLayout = screen.getByTestId('client-layout');
62 |     expect(clientLayout).toBeInTheDocument();
63 |     expect(clientLayout).toContainElement(screen.getByTestId('test-child'));
64 |   });
65 | }); 
```

src/app/layout.tsx
```
1 | /**
2 |  * 파일명: src/app/layout.tsx
3 |  * 목적: 앱의 기본 레이아웃 구조 정의
4 |  * 역할: 전체 페이지 구조와 공통 UI 요소 제공
5 |  * 작성일: 2025-02-27
6 |  * 수정일: 2025-03-28
7 |  * 수정일: 2024-05-08 : 메타데이터 추가
8 |  * 수정일: 2024-05-28 : import 순서 정렬
9 |  */
10 | 
11 | import "@/app/globals.css";
12 | import "@xyflow/react/dist/style.css";
13 | 
14 | import { Metadata } from "next";
15 | 
16 | import { ClientLayout } from "@/components/layout/ClientLayout";
17 | 
18 | export const metadata: Metadata = {
19 |   title: "Backyard - 생각을 관리하는 새로운 방법",
20 |   description: "아이디어를 시각적으로 구성하고 관리하는 직관적인 도구",
21 | }
22 | 
23 | export default function RootLayout({
24 |   children,
25 | }: {
26 |   children: React.ReactNode;
27 | }) {
28 |   return (
29 |     <html lang="ko">
30 |       <body className="antialiased" suppressHydrationWarning>
31 |         <ClientLayout>
32 |           {children}
33 |         </ClientLayout>
34 |       </body>
35 |     </html>
36 |   );
37 | }
```

src/app/metadata.ts
```
1 | import { Metadata } from "next";
2 | 
3 | export const metadata: Metadata = {
4 |   title: "Backyard - 모든 아이디어를 정리하는 공간",
5 |   description: "효율적인 메모와 지식 관리를 위한 솔루션",
6 |   icons: {
7 |     icon: "/favicon.ico",
8 |   },
9 | }; 
```

src/app/not-found.test.tsx
```
1 | /**
2 |  * 파일명: not-found.test.tsx
3 |  * 목적: NotFound 컴포넌트의 기능 검증
4 |  * 역할: 404 페이지가 올바르게 렌더링되는지 확인
5 |  * 작성일: 2025-04-01
6 |  */
7 | 
8 | import { render, screen } from '@testing-library/react';
9 | import { expect, describe, it, vi } from 'vitest';
10 | 
11 | import NotFound from './not-found';
12 | 
13 | // Next.js Link 컴포넌트 모킹
14 | vi.mock('next/link', () => ({
15 |     default: ({ children, href }: { children: React.ReactNode, href: string }) => (
16 |         <a href={href} data-testid="link">
17 |             {children}
18 |         </a>
19 |     ),
20 | }));
21 | 
22 | describe('NotFound 컴포넌트', () => {
23 |     it('404 텍스트가 표시되어야 함', () => {
24 |         render(<NotFound />);
25 |         expect(screen.getByText('404')).toBeInTheDocument();
26 |     });
27 | 
28 |     it('페이지를 찾을 수 없다는 메시지가 표시되어야 함', () => {
29 |         render(<NotFound />);
30 |         expect(screen.getByText('페이지를 찾을 수 없습니다')).toBeInTheDocument();
31 |     });
32 | 
33 |     it('설명 텍스트가 표시되어야 함', () => {
34 |         render(<NotFound />);
35 |         expect(screen.getByText('요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.')).toBeInTheDocument();
36 |     });
37 | 
38 |     it('홈으로 돌아가는 링크가 있어야 함', () => {
39 |         render(<NotFound />);
40 |         const link = screen.getByTestId('link');
41 |         expect(link).toBeInTheDocument();
42 |         expect(link).toHaveAttribute('href', '/');
43 |         expect(link).toHaveTextContent('홈으로 돌아가기');
44 |     });
45 | }); 
```

src/app/not-found.tsx
```
1 | 'use client';
2 | 
3 | import Link from 'next/link';
4 | 
5 | export default function NotFound() {
6 |   return (
7 |     <div className="flex flex-col items-center justify-center min-h-screen p-8">
8 |       <div className="text-center">
9 |         <h1 className="text-6xl font-bold text-gray-800 mb-4">404</h1>
10 |         <h2 className="text-2xl font-semibold text-gray-700 mb-6">페이지를 찾을 수 없습니다</h2>
11 |         <p className="text-gray-600 mb-8">
12 |           요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.
13 |         </p>
14 |         <Link
15 |           href="/"
16 |           className="px-6 py-3 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
17 |         >
18 |           홈으로 돌아가기
19 |         </Link>
20 |       </div>
21 |     </div>
22 |   );
23 | } 
```

src/app/page.test.tsx
```
1 | /**
2 |  * 파일명: page.test.tsx
3 |  * 목적: 홈 페이지 컴포넌트 테스트
4 |  * 역할: 홈 페이지의 렌더링과 기능 검증
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-03-30
7 |  * 수정일: 2025-04-25 : lint 오류 수정 - import 순서 및 next/link 사용
8 |  */
9 | 
10 | import React from 'react';
11 | 
12 | import { render, screen } from '@testing-library/react';
13 | import '@testing-library/jest-dom/vitest';
14 | import { describe, it, expect, vi } from 'vitest';
15 | 
16 | import { DashboardLayout } from '@/components/layout/DashboardLayout';
17 | 
18 | import Home from './page';
19 | 
20 | // DashboardLayout 모킹
21 | vi.mock('@/components/layout/DashboardLayout', () => ({
22 |   DashboardLayout: vi.fn().mockImplementation(() => (
23 |     <div data-testid="dashboard-layout">
24 |       <h1>Backyard</h1>
25 |       <p>아이디어와 지식을 시각적으로 구성, 관리, 공유할 수 있는 도구</p>
26 |       <span>카드 목록 보기</span>
27 |     </div>
28 |   )),
29 | }));
30 | 
31 | describe('Home 페이지', () => {
32 |   it('컴포넌트가 정의되어 있어야 합니다', () => {
33 |     expect(typeof Home).toBe('function');
34 |   });
35 | 
36 |   it('DashboardLayout을 렌더링해야 합니다', () => {
37 |     render(<Home />);
38 |     const dashboard = screen.getByTestId('dashboard-layout');
39 |     expect(dashboard).toBeInTheDocument();
40 |   });
41 | 
42 |   it('Backyard 제목이 렌더링되어야 합니다', () => {
43 |     render(<Home />);
44 |     const heading = screen.getByText('Backyard');
45 |     expect(heading).toBeInTheDocument();
46 |     expect(heading.tagName).toBe('H1');
47 |   });
48 | 
49 |   it('설명 텍스트가 렌더링되어야 합니다', () => {
50 |     render(<Home />);
51 |     const description = screen.getByText('아이디어와 지식을 시각적으로 구성, 관리, 공유할 수 있는 도구');
52 |     expect(description).toBeInTheDocument();
53 |     expect(description.tagName).toBe('P');
54 |   });
55 | 
56 |   it('카드 목록 보기 링크가 렌더링되어야 합니다', () => {
57 |     render(<Home />);
58 |     const link = screen.getByText('카드 목록 보기');
59 |     expect(link).toBeInTheDocument();
60 |     expect(link.tagName).toBe('A');
61 |     expect(link).toHaveAttribute('href', '/cards');
62 |   });
63 | 
64 |   it('DashboardLayout이 호출되어야 합니다', () => {
65 |     render(<Home />);
66 |     expect(DashboardLayout).toHaveBeenCalled();
67 |   });
68 | }); 
```

src/app/page.tsx
```
1 | import { DashboardLayout } from '@/components/layout/DashboardLayout';
2 | 
3 | export default function Home() {
4 |   return <DashboardLayout />;
5 | }
```

src/components/IdeaMap.tsx
```
1 | /**
2 |  * 파일명: src/components/IdeaMap.tsx
3 |  * 목적: 카드 데이터 업데이트 유틸리티 함수 제공
4 |  * 역할: 아이디어맵 내 카드 노드 데이터 갱신 로직
5 |  * 작성일: 2024-05-07
6 |  */
7 | 
8 | import { Node } from '@xyflow/react';
9 | 
10 | import { CardData } from '@/components/ideamap/types/ideamap-types';
11 | 
12 | /**
13 |  * updateCardNodes: 기존 노드 배열에서 특정 카드 데이터를 업데이트한 새 노드 배열 반환
14 |  * @param {Node<CardData>[]} prevNodes - 업데이트할 노드 배열
15 |  * @param {CardData} cardData - 업데이트할 카드 데이터
16 |  * @returns {Node<CardData>[]} 업데이트된 노드 배열
17 |  */
18 | export const updateCardNodes = (prevNodes: Node<CardData>[], cardData: CardData): Node<CardData>[] => {
19 |     return prevNodes.map((node) => {
20 |         if (node.id === cardData.id) {
21 |             return {
22 |                 ...node,
23 |                 data: {
24 |                     ...node.data,
25 |                     title: cardData.title,
26 |                     content: cardData.content ?? '',
27 |                 },
28 |             };
29 |         }
30 |         return node;
31 |     });
32 | }; 
```

src/contexts/AuthContext.tsx
```
1 | /**
2 |  * 파일명: AuthContext.tsx
3 |  * 목적: 전역 인증 상태 관리
4 |  * 역할: 인증 상태, code_verifier 등의 인증 관련 데이터를 전역적으로 관리
5 |  * 작성일: 2025-03-08
6 |  * 수정일: 2025-04-09
7 |  * 수정일: 2024-05-08 : localStorage 관련 코드 제거 - @supabase/ssr의 쿠키 기반 세션 관리와 호환되도록 수정
8 |  * 수정일: 2023-10-27 : 불필요한 서버 환경 체크 로직 제거 ('use client' 지시문이 있으므로 항상 클라이언트에서 실행됨)
9 |  */
10 | 
11 | 'use client';
12 | 
13 | import { createContext, useContext, useEffect, useState, ReactNode } from 'react';
14 | 
15 | import { User, Session, SupabaseClient } from '@supabase/supabase-js';
16 | 
17 | import { STORAGE_KEYS } from '@/lib/auth';
18 | // import { isClient } from '@/lib/environment';
19 | import createLogger from '@/lib/logger';
20 | import { createClient } from '@/lib/supabase/client';
21 | import { Database } from '@/types/supabase';
22 | 
23 | // 모듈별 로거 생성
24 | const logger = createLogger('AuthContext');
25 | 
26 | // 클라이언트 환경 확인 (전역 변수로 미리 설정)
27 | // const isClientEnv = typeof window !== 'undefined';
28 | 
29 | interface AuthContextType {
30 |   user: User | null;
31 |   session: Session | null;
32 |   isLoading: boolean;
33 |   signOut: () => Promise<void>;
34 |   codeVerifier: string | null;
35 |   error: Error | null;
36 |   setCodeVerifier: (value: string | null) => void;
37 | }
38 | 
39 | // 기본 컨텍스트 값
40 | const AuthContext = createContext<AuthContextType>({
41 |   user: null,
42 |   session: null,
43 |   isLoading: true,
44 |   signOut: async () => { },
45 |   codeVerifier: null,
46 |   error: null,
47 |   setCodeVerifier: () => { },
48 | });
49 | 
50 | export function AuthProvider({ children }: { children: ReactNode }) {
51 |   // 'use client'가 있으므로 이 코드는 항상 클라이언트에서만 실행됨
52 |   // 서버 환경 체크는 불필요함
53 |   const [user, setUser] = useState<User | null>(null);
54 |   const [session, setSession] = useState<Session | null>(null);
55 |   const [isLoading, setIsLoading] = useState(true);
56 |   const [codeVerifier, setCodeVerifier] = useState<string | null>(null);
57 |   const [isInitialized, setIsInitialized] = useState(false);
58 |   const [authError, setAuthError] = useState<Error | null>(null);
59 | 
60 |   // Supabase 인스턴스 접근
61 |   let supabase: SupabaseClient<Database>;
62 |   try {
63 |     supabase = createClient();
64 |   } catch (error) {
65 |     logger.error('AuthProvider에서 Supabase 초기화 실패', error);
66 |     return <AuthContext.Provider value={{
67 |       user: null,
68 |       session: null,
69 |       isLoading: false,
70 |       signOut: async () => { },
71 |       codeVerifier: null,
72 |       error: error instanceof Error ? error : new Error('Supabase 초기화 실패'),
73 |       setCodeVerifier: () => { },
74 |     }}>{children}</AuthContext.Provider>;
75 |   }
76 | 
77 |   useEffect(() => {
[TRUNCATED]
```

src/contexts/ThemeContext.test.tsx
```
1 | /**
2 |  * 파일명: ThemeContext.test.tsx
3 |  * 목적: ThemeContext 및 ThemeProvider 테스트
4 |  * 역할: 테마 관련 기능 검증
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-01
7 |  */
8 | 
9 | import React from 'react';
10 | 
11 | import { render, screen } from '@testing-library/react';
12 | import { describe, test, expect, vi, beforeEach, afterEach, beforeAll, afterAll } from 'vitest';
13 | 
14 | import { ThemeProvider } from './ThemeContext';
15 | 
16 | // 모든 모킹을 파일 상단에 그룹화
17 | // ResizeObserver 모킹
18 | const mockResizeObserver = vi.fn().mockImplementation(() => ({
19 |   observe: vi.fn(),
20 |   unobserve: vi.fn(),
21 |   disconnect: vi.fn(),
22 | }));
23 | 
24 | // console.log 모킹
25 | vi.spyOn(console, 'log').mockImplementation(() => undefined);
26 | 
27 | // CSS 속성 적용 모킹을 위한 함수 모킹
28 | const mockSetProperty = vi.fn();
29 | 
30 | // 원본 함수 참조 저장 변수
31 | let originalSetProperty: typeof document.documentElement.style.setProperty;
32 | 
33 | describe('ThemeContext', () => {
34 |   // 모든 테스트 전에 전역 객체 모킹 설정
35 |   beforeAll(() => {
36 |     // ResizeObserver 모킹
37 |     vi.stubGlobal('ResizeObserver', mockResizeObserver);
38 | 
39 |     // document.documentElement.style.setProperty 모킹
40 |     originalSetProperty = document.documentElement.style.setProperty;
41 |     document.documentElement.style.setProperty = mockSetProperty;
42 |   });
43 | 
44 |   // 각 테스트 전에 모킹 함수 초기화
45 |   beforeEach(() => {
46 |     mockSetProperty.mockClear();
47 |     vi.clearAllMocks();
48 |   });
49 | 
50 |   // 각 테스트 후에 정리
51 |   afterEach(() => {
52 |     vi.resetAllMocks();
53 |   });
54 | 
55 |   // 모든 테스트 후에 전역 모킹 복원
56 |   afterAll(() => {
57 |     // 원본 함수 복원
58 |     document.documentElement.style.setProperty = originalSetProperty;
59 | 
60 |     // 모든 모킹 복원
61 |     vi.unstubAllGlobals();
62 |     vi.restoreAllMocks();
63 |   });
64 | 
65 |   test('ThemeProvider가 자식 컴포넌트를 렌더링해야 함', () => {
66 |     render(
67 |       <ThemeProvider>
68 |         <div>테스트 자식</div>
69 |       </ThemeProvider>
70 |     );
71 | 
72 |     expect(screen.getByText('테스트 자식')).toBeInTheDocument();
73 |     expect(mockSetProperty).toHaveBeenCalled();
74 |   });
75 | }); 
```

src/contexts/ThemeContext.tsx
```
1 | /**
2 |  * 파일명: ThemeContext.tsx
3 |  * 목적: 중앙화된 테마 관리 시스템 구현
4 |  * 역할: React Flow 노드 및 엣지 스타일링을 위한 전역 테마 컨텍스트 제공
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
9 | 
10 | import defaultConfig from '../config/uiOptions.json';
11 | 
12 | export interface NodeTheme {
13 |   width: number;
14 |   height: number;
15 |   maxHeight: number;
16 |   backgroundColor: string;
17 |   borderColor: string;
18 |   borderWidth: number;
19 |   borderRadius: number;
20 |   selectedBorderColor: string;
21 |   font: {
22 |     family: string;
23 |     titleSize: number;
24 |     contentSize: number;
25 |     tagsSize: number;
26 |   };
27 | }
28 | 
29 | export interface EdgeTheme {
30 |   color: string;
31 |   width: number;
32 |   selectedColor: string;
33 |   animated: boolean;
34 | }
35 | 
36 | export interface HandleTheme {
37 |   size: number;
38 |   backgroundColor: string;
39 |   borderColor: string;
40 |   borderWidth: number;
41 | }
42 | 
43 | export interface LayoutTheme {
44 |   spacing: {
45 |     horizontal: number;
46 |     vertical: number;
47 |   };
48 |   padding: number;
49 | }
50 | 
51 | export interface Theme {
52 |   node: NodeTheme;
53 |   edge: EdgeTheme;
54 |   handle: HandleTheme;
55 |   layout: LayoutTheme;
56 | }
57 | 
58 | // 기본 테마 설정 - 기존 JSON 파일의 값 사용
59 | const defaultTheme: Theme = {
60 |   node: {
61 |     width: defaultConfig.layout.nodeSize.width,
62 |     height: defaultConfig.layout.nodeSize.height,
63 |     maxHeight: defaultConfig.layout.nodeSize.maxHeight,
64 |     backgroundColor: defaultConfig.card.backgroundColor,
65 |     borderColor: '#C1C1C1',
66 |     borderWidth: 1,
67 |     borderRadius: defaultConfig.card.borderRadius,
68 |     selectedBorderColor: '#0071e3',
69 |     font: {
70 |       family: 'Pretendard, sans-serif',
71 |       titleSize: defaultConfig.card.fontSizes.title,
72 |       contentSize: defaultConfig.card.fontSizes.content,
73 |       tagsSize: defaultConfig.card.fontSizes.tags,
74 |     }
75 |   },
76 |   edge: {
77 |     color: defaultConfig.ideaMap.edgeColor,
78 |     width: defaultConfig.ideaMap.strokeWidth,
79 |     selectedColor: defaultConfig.ideaMap.selectedEdgeColor,
80 |     animated: defaultConfig.ideaMap.animated,
81 |   },
82 |   handle: {
83 |     size: defaultConfig.handles.size,
84 |     backgroundColor: defaultConfig.handles.backgroundColor,
85 |     borderColor: defaultConfig.handles.borderColor,
86 |     borderWidth: defaultConfig.handles.borderWidth,
87 |   },
88 |   layout: {
89 |     spacing: {
90 |       horizontal: defaultConfig.layout.defaultSpacing.horizontal,
91 |       vertical: defaultConfig.layout.defaultSpacing.vertical,
92 |     },
93 |     padding: defaultConfig.layout.defaultPadding,
94 |   },
95 | };
96 | 
97 | interface ThemeContextType {
98 |   theme: Theme;
99 |   updateTheme: (newTheme: Partial<Theme>) => void;
100 |   updateNodeSize: (width: number, height: number, maxHeight?: number) => void;
101 | }
102 | 
[TRUNCATED]
```

src/hooks/useAddNodeOnEdgeDrop.ts
```
1 | import { useState, useCallback } from 'react';
2 | 
3 | import { OnConnectStart, OnConnectEnd, useReactFlow, Connection, XYPosition } from '@xyflow/react';
4 | 
5 | interface UseAddNodeOnEdgeDropProps {
6 |   onCreateNode: (position: XYPosition, connectingNodeId: string, handleType: 'source' | 'target') => void;
7 | }
8 | 
9 | /**
10 |  * 엣지를 드래그해서 특정 위치에 드롭했을 때 새 노드를 생성하는 기능을 제공하는 훅
11 |  */
12 | export function useAddNodeOnEdgeDrop({ onCreateNode }: UseAddNodeOnEdgeDropProps) {
13 |   // 현재 연결 중인 노드 ID
14 |   const [connectingNodeId, setConnectingNodeId] = useState<string | null>(null);
15 |   // 현재 연결 중인 핸들 타입 (source 또는 target)
16 |   const [connectingHandleType, setConnectingHandleType] = useState<'source' | 'target' | null>(null);
17 |   
18 |   // ReactFlow 인스턴스 가져오기
19 |   const { screenToFlowPosition, getNodes } = useReactFlow();
20 |   
21 |   // 연결 시작 핸들러
22 |   const onConnectStart: OnConnectStart = useCallback((_, { nodeId, handleType }) => {
23 |     setConnectingNodeId(nodeId);
24 |     setConnectingHandleType(handleType as 'source' | 'target');
25 |   }, []);
26 |   
27 |   // 연결 종료 핸들러
28 |   const onConnectEnd: OnConnectEnd = useCallback(
29 |     (event) => {
30 |       if (!connectingNodeId || !connectingHandleType || !event) {
31 |         return;
32 |       }
33 |       
34 |       // 마우스 이벤트를 캐스팅
35 |       const mouseEvent = event as MouseEvent;
36 |       
37 |       // 마우스 위치를 Flow 좌표로 변환
38 |       const position = screenToFlowPosition({
39 |         x: mouseEvent.clientX,
40 |         y: mouseEvent.clientY,
41 |       });
42 |       
43 |       // 노드 목록 가져오기
44 |       const nodes = getNodes();
45 |       
46 |       // 해당 위치에 이미 노드가 있는지 확인 (50px 허용 오차)
47 |       const targetNodeAtPosition = nodes.find(
48 |         node => 
49 |           Math.abs(node.position.x - position.x) < 50 && 
50 |           Math.abs(node.position.y - position.y) < 50
51 |       );
52 |       
53 |       // 이미 노드가 있으면 자동 연결 처리는 하지 않고 기본 동작을 사용
54 |       if (!targetNodeAtPosition) {
55 |         // 노드가 없으면 새 노드 생성 함수 호출
56 |         onCreateNode(position, connectingNodeId, connectingHandleType);
57 |       }
58 |       
59 |       // 연결 상태 초기화
60 |       setConnectingNodeId(null);
61 |       setConnectingHandleType(null);
62 |     },
63 |     [connectingNodeId, connectingHandleType, getNodes, onCreateNode, screenToFlowPosition]
64 |   );
65 |   
66 |   return {
67 |     connectingNodeId,
68 |     connectingHandleType,
69 |     onConnectStart,
70 |     onConnectEnd,
71 |   };
72 | } 
```

src/hooks/useCardData.ts
```
1 | /**
2 |  * 파일명: useCardData.ts
3 |  * 목적: 카드 데이터를 API에서 로드하고 관리하는 훅
4 |  * 역할: API 호출 및 응답 처리, 데이터 캐싱, 전역 상태 업데이트 담당
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2024-05-30 : 카드 로드 후 노드와 동기화 로직 추가
7 |  */
8 | 
9 | import { useState, useEffect, useCallback } from 'react';
10 | 
11 | import { toast } from 'sonner';
12 | 
13 | import { useAppStore, Card } from '@/store/useAppStore';
14 | 
15 | interface UseCardDataOptions {
16 |   autoLoad?: boolean;
17 |   userId?: string | null;
18 |   searchQuery?: string | null;
19 |   tagFilter?: string | null;
20 | }
21 | 
22 | /**
23 |  * useCardData: 카드 데이터를 API에서 로드하고 관리하는 훅
24 |  * @param options 데이터 로드 설정 옵션
25 |  * @returns 카드 데이터 관련 상태 및 함수들
26 |  */
27 | export function useCardData({
28 |   autoLoad = true,
29 |   userId = null,
30 |   searchQuery = null,
31 |   tagFilter = null
32 | }: UseCardDataOptions = {}) {
33 |   // 로딩 및 에러 상태
34 |   const [isLoading, setIsLoading] = useState(false);
35 |   const [error, setError] = useState<string | null>(null);
36 |   const [lastLoadedAt, setLastLoadedAt] = useState<Date | null>(null);
37 |   
38 |   // useAppStore에서 카드 관련 상태 및 함수 가져오기
39 |   const cards = useAppStore(state => state.cards);
40 |   const setCards = useAppStore(state => state.setCards);
41 |   
42 |   /**
43 |    * 카드 데이터 로드 함수
44 |    * @param params 선택적 검색 매개변수
45 |    */
46 |   const loadCards = useCallback(async (params?: {
47 |     userId?: string;
48 |     q?: string;
49 |     tag?: string;
50 |   }) => {
51 |     try {
52 |       setIsLoading(true);
53 |       setError(null);
54 |       
55 |       // URL 매개변수 구성
56 |       const searchParams = new URLSearchParams();
57 |       
58 |       // 기본 옵션과 매개변수 병합
59 |       const userId = params?.userId || null;
60 |       const q = params?.q || searchQuery || null;
61 |       const tag = params?.tag || tagFilter || null;
62 |       
63 |       // 선택적 매개변수 추가
64 |       if (userId) searchParams.append('userId', userId);
65 |       if (q) searchParams.append('q', q);
66 |       if (tag) searchParams.append('tag', tag);
67 |       
68 |       // 엔드포인트 구성
69 |       const queryString = searchParams.toString();
70 |       const endpoint = `/api/cards${queryString ? `?${queryString}` : ''}`;
71 |       
72 |       console.log('[useCardData] API 요청:', endpoint);
73 |       
74 |       // fetch API 호출
75 |       const response = await fetch(endpoint);
76 |       
77 |       // 응답 에러 처리
78 |       if (!response.ok) {
79 |         const errorText = await response.text();
[TRUNCATED]
```

src/hooks/useResizable.ts
```
1 | import { useState, useEffect, useRef } from 'react';
2 | 
3 | interface UseResizableProps {
4 |   initialWidth: number;
5 |   minWidth: number;
6 |   maxWidth: number;
7 |   onWidthChange?: (width: number) => void;
8 |   storageKey?: string;
9 | }
10 | 
11 | export function useResizable({
12 |   initialWidth = 320,
13 |   minWidth = 240,
14 |   maxWidth = 480,
15 |   onWidthChange,
16 |   storageKey
17 | }: UseResizableProps) {
18 |   // 로컬 스토리지에서 저장된 너비 가져오기
19 |   const getStoredWidth = () => {
20 |     if (typeof window === 'undefined' || !storageKey) return initialWidth;
21 |     
22 |     const storedWidth = localStorage.getItem(storageKey);
23 |     if (storedWidth) {
24 |       const parsed = parseInt(storedWidth, 10);
25 |       if (!isNaN(parsed) && parsed >= minWidth && parsed <= maxWidth) {
26 |         return parsed;
27 |       }
28 |     }
29 |     return initialWidth;
30 |   };
31 | 
32 |   const [width, setWidth] = useState<number>(getStoredWidth);
33 |   const [isDragging, setIsDragging] = useState<boolean>(false);
34 |   const dragHandleRef = useRef<HTMLDivElement>(null);
35 | 
36 |   useEffect(() => {
37 |     if (storageKey && typeof window !== 'undefined') {
38 |       localStorage.setItem(storageKey, width.toString());
39 |     }
40 |     
41 |     onWidthChange?.(width);
42 |   }, [width, storageKey, onWidthChange]);
43 | 
44 |   useEffect(() => {
45 |     const handleMouseMove = (e: MouseEvent) => {
46 |       if (!isDragging) return;
47 |       
48 |       // 마우스 위치와 요소의 위치에 따라 너비 계산
49 |       const newWidth = window.innerWidth - e.clientX;
50 |       const clampedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
51 |       
52 |       setWidth(clampedWidth);
53 |     };
54 | 
55 |     const handleMouseUp = () => {
56 |       setIsDragging(false);
57 |     };
58 | 
59 |     // 마우스 이벤트 리스너 등록
60 |     if (isDragging) {
61 |       document.addEventListener('mousemove', handleMouseMove);
62 |       document.addEventListener('mouseup', handleMouseUp);
63 |     }
64 | 
65 |     return () => {
66 |       document.removeEventListener('mousemove', handleMouseMove);
67 |       document.removeEventListener('mouseup', handleMouseUp);
68 |     };
69 |   }, [isDragging, minWidth, maxWidth]);
70 | 
71 |   const startResize = (e: React.MouseEvent) => {
72 |     e.preventDefault();
73 |     setIsDragging(true);
74 |   };
75 | 
76 |   return {
77 |     width,
78 |     isDragging,
79 |     startResize,
80 |     dragHandleRef,
81 |     setWidth
82 |   };
83 | } 
```

src/lib/auth-server.ts
```
1 | /**
2 |  * 파일명: auth-server.ts
3 |  * 목적: 서버 측 인증 기능 및 세션 처리
4 |  * 역할: API 라우트에서 사용할 서버 측 인증 함수 제공
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-09
7 |  */
8 | 
9 | import createLogger from './logger';
10 | import { createClient } from './supabase/server';
11 | 
12 | // 로거 생성
13 | const logger = createLogger('AuthServer');
14 | 
15 | /**
16 |  * auth: 서버 컴포넌트와 API 라우트에서 사용할 인증 함수
17 |  * @returns 현재 인증된 세션 정보
18 |  */
19 | export const auth = async () => {
20 |   try {
21 |     const supabase = await createClient();
22 |     const { data: { session } } = await supabase.auth.getSession();
23 |     return session;
24 |   } catch (error) {
25 |     logger.error('서버 인증 오류:', error);
26 |     return null;
27 |   }
28 | };
29 | 
30 | /**
31 |  * getCurrentUser: 현재 인증된 사용자 정보를 반환
32 |  * @returns 현재 인증된 사용자 또는 null
33 |  */
34 | export const getCurrentUser = async () => {
35 |   try {
36 |     const supabase = await createClient();
37 |     const { data: { user } } = await supabase.auth.getUser();
38 |     return user;
39 |   } catch (error) {
40 |     logger.error('사용자 정보 조회 오류:', error);
41 |     return null;
42 |   }
43 | }; 
```

src/lib/auth.ts
```
1 | /**
2 |  * 파일명: auth.ts
3 |  * 목적: 사용자 인증 관련 기능 제공
4 |  * 역할: 로그인, 회원가입, 세션 관리 등 인증 관련 유틸리티 함수 제공
5 |  * 작성일: 2025-03-08
6 |  * 수정일: 2025-04-09
7 |  * 수정일: 2023-10-31 : Supabase 로그아웃 함수 개선 및 쿠키 삭제 기능 추가
8 |  * 수정일: 2024-05-08 : signOut 함수 간소화 - @supabase/ssr 기반 세션 관리와 호환되도록 개선
9 |  */
10 | 
11 | 'use client';
12 | 
13 | import { User } from '@supabase/supabase-js';
14 | 
15 | import { base64UrlEncode, stringToArrayBuffer } from './base64';
16 | import { isClient } from './environment';
17 | import createLogger from './logger';
18 | import { createClient } from './supabase/client';
19 | 
20 | // 모듈별 로거 생성
21 | const logger = createLogger('Auth');
22 | 
23 | // OAuth 설정
24 | const OAUTH_CONFIG = {
25 |   codeVerifierLength: 128, // PKCE 코드 검증기 길이
26 |   codeChallengeMethod: 'S256', // SHA-256 해시 사용
27 | };
28 | 
29 | // 스토리지 키 정의
30 | export const STORAGE_KEYS = {
31 |   CODE_VERIFIER: 'code_verifier', // sessionStorage에서 사용
32 |   ACCESS_TOKEN: 'access_token',   // localStorage에서 사용
33 |   REFRESH_TOKEN: 'refresh_token', // localStorage에서 사용
34 |   USER_ID: 'user_id',             // localStorage에서 사용
35 |   PROVIDER: 'provider'            // localStorage에서 사용
36 | };
37 | 
38 | /**
39 |  * PKCE 코드 검증기 생성 (RFC 7636 준수)
40 |  * @returns RFC 7636 기반 안전한 코드 검증기
41 |  */
42 | export const generateCodeVerifier = async (): Promise<string> => {
43 |   try {
44 |     // PKCE 표준: 최소 43자, 최대 128자의 무작위 문자열
45 |     // A-Z, a-z, 0-9, -, ., _, ~ 문자만 사용 가능
46 |     const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
47 |     
48 |     // Web Crypto API로 더 안전한 난수 생성
49 |     const randomValues = new Uint8Array(96); // 96바이트 = 128자 정도로 충분
50 |     crypto.getRandomValues(randomValues);
51 |     
52 |     // 무작위 바이트를 유효한 charset 문자로 변환
53 |     const verifier = Array.from(randomValues)
54 |       .map(byte => charset[byte % charset.length])
55 |       .join('');
56 |     
57 |     // PKCE 표준에 맞는 길이 (43-128) 확인
58 |     if (verifier.length < 43 || verifier.length > 128) {
59 |       throw new Error(`유효하지 않은 코드 검증기 길이: ${verifier.length}`);
60 |     }
61 |     
62 |     logger.debug('PKCE 코드 검증기 생성 완료', { 길이: verifier.length });
63 |     return verifier;
64 |   } catch (error) {
65 |     logger.error('코드 검증기 생성 오류', error);
66 |     throw error;
67 |   }
68 | };
69 | 
70 | /**
71 |  * PKCE 코드 챌린지 생성
72 |  * @param verifier 코드 검증기
73 |  * @returns Base64URL 인코딩된 SHA-256 해시
74 |  */
[TRUNCATED]
```

src/lib/base64.ts
```
1 | /**
2 |  * 파일명: base64.ts
3 |  * 목적: Base64 인코딩 유틸리티
4 |  * 역할: 일반 및 URL-safe Base64 인코딩/디코딩 기능 제공
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | /**
9 |  * base64Encode: 문자열을 Base64로 인코딩
10 |  * @param {string} str - 인코딩할 문자열
11 |  * @returns {string} Base64 인코딩된 문자열
12 |  */
13 | export const base64Encode = (str: string): string => {
14 |   if (typeof window !== 'undefined') {
15 |     // 브라우저 환경
16 |     return window.btoa(str);
17 |   } else {
18 |     // Node.js 환경
19 |     return Buffer.from(str).toString('base64');
20 |   }
21 | };
22 | 
23 | /**
24 |  * base64Decode: Base64 문자열을 디코딩
25 |  * @param {string} str - 디코딩할 Base64 문자열
26 |  * @returns {string} 디코딩된 문자열
27 |  */
28 | export const base64Decode = (str: string): string => {
29 |   if (typeof window !== 'undefined') {
30 |     // 브라우저 환경
31 |     return window.atob(str);
32 |   } else {
33 |     // Node.js 환경
34 |     return Buffer.from(str, 'base64').toString();
35 |   }
36 | };
37 | 
38 | /**
39 |  * base64UrlEncode: ArrayBuffer를 URL 안전한 Base64 문자열로 인코딩
40 |  * - RFC 7636에 따라 code_challenge를 위한 포맷으로 인코딩
41 |  * - `+` -> `-`, `/` -> `_`, 패딩 문자(`=`) 제거
42 |  * @param {ArrayBufferLike} buffer - 인코딩할 ArrayBuffer
43 |  * @returns {string} URL 안전한 Base64 문자열
44 |  */
45 | export const base64UrlEncode = (buffer: ArrayBufferLike): string => {
46 |   let base64 = '';
47 |   
48 |   if (typeof window !== 'undefined') {
49 |     // 브라우저 환경
50 |     base64 = window.btoa(
51 |       String.fromCharCode.apply(
52 |         null,
53 |         new Uint8Array(buffer) as unknown as number[]
54 |       )
55 |     );
56 |   } else {
57 |     // Node.js 환경
58 |     base64 = Buffer.from(buffer).toString('base64');
59 |   }
60 |   
61 |   // URL 안전 문자로 변경 (+, /, = 처리)
62 |   return base64
63 |     .replace(/\+/g, '-')
64 |     .replace(/\//g, '_')
65 |     .replace(/=+$/, '');
66 | };
67 | 
68 | /**
69 |  * base64UrlDecode: URL 안전한 Base64 문자열을 디코딩하여 ArrayBuffer 반환
70 |  * - `-` -> `+`, `_` -> `/`, 패딩 문자 복원
71 |  * @param {string} base64Url - 디코딩할 URL 안전 Base64 문자열
72 |  * @returns {ArrayBufferLike} 디코딩된 ArrayBuffer
73 |  */
74 | export const base64UrlDecode = (base64Url: string): ArrayBufferLike => {
75 |   // 원래 Base64 형식으로 복원
76 |   let base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
77 |   
78 |   // 패딩 복원
79 |   while (base64.length % 4) {
80 |     base64 += '=';
81 |   }
82 |   
83 |   const binaryString = base64Decode(base64);
84 |   const bytes = new Uint8Array(binaryString.length);
85 |   
[TRUNCATED]
```

src/lib/constants.ts
```
1 | // 애플리케이션 전체에서 사용되는 상수 값들
2 | 
3 | // 테스트 사용자 ID (데이터베이스에 실제로 존재하는 ID)
4 | // 이전 값: export const DEFAULT_USER_ID = "91fc1ef9-daec-45de-8eb4-40ca52ec292f";
5 | export const DEFAULT_USER_ID = "13ce1b15-aa4e-452b-af81-124d06413662"; // 실제 데이터베이스에 존재하는 ID
6 | 
7 | // 페이지 크기 상수
8 | export const PAGE_SIZE = 10;
9 | 
10 | // 날짜 형식
11 | export const DATE_FORMAT = "YYYY년 MM월 DD일"; 
```

src/lib/cookie.ts
```
1 | /**
2 |  * 파일명: src/lib/cookie.ts
3 |  * 목적: 크로스 도메인 쿠키 관리 유틸리티 제공
4 |  * 역할: 쿠키 설정, 조회, 삭제 기능 제공
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | import { createLogger } from './logger';
9 | 
10 | const logger = createLogger('Cookie');
11 | 
12 | /**
13 |  * 쿠키 설정
14 |  * @param name 쿠키 이름
15 |  * @param value 쿠키 값
16 |  * @param options 쿠키 옵션
17 |  */
18 | export function setCookie(
19 |   name: string,
20 |   value: string,
21 |   options: {
22 |     days?: number;
23 |     path?: string;
24 |     domain?: string;
25 |     sameSite?: 'strict' | 'lax' | 'none';
26 |     secure?: boolean;
27 |   } = {}
28 | ): void {
29 |   if (typeof document === 'undefined') {
30 |     logger.warn('Document is not available - 쿠키를 설정할 수 없습니다');
31 |     return;
32 |   }
33 | 
34 |   const { days = 7, path = '/', domain, sameSite = 'lax', secure = false } = options;
35 | 
36 |   // 만료일 계산
37 |   const expiresDate = new Date();
38 |   expiresDate.setTime(expiresDate.getTime() + days * 24 * 60 * 60 * 1000);
39 | 
40 |   // 쿠키 문자열 구성
41 |   let cookieString = `${encodeURIComponent(name)}=${encodeURIComponent(value)}; expires=${expiresDate.toUTCString()}; path=${path}`;
42 | 
43 |   // 도메인 추가 (있는 경우)
44 |   if (domain) {
45 |     cookieString += `; domain=${domain}`;
46 |   }
47 | 
48 |   // SameSite 추가
49 |   cookieString += `; samesite=${sameSite}`;
50 | 
51 |   // Secure 추가 (SameSite=None일 경우 필수)
52 |   if (secure || sameSite === 'none') {
53 |     cookieString += '; secure';
54 |   }
55 | 
56 |   // 쿠키 설정
57 |   document.cookie = cookieString;
58 |   logger.debug(`쿠키 설정: ${name}`, { days, path, domain, sameSite, secure });
59 | }
60 | 
61 | /**
62 |  * 쿠키 값 조회
63 |  * @param name 쿠키 이름
64 |  * @returns 쿠키 값 또는 null
65 |  */
66 | export function getCookie(name: string): string | null {
67 |   if (typeof document === 'undefined') {
68 |     logger.warn('Document is not available - 쿠키를 조회할 수 없습니다');
69 |     return null;
70 |   }
71 | 
72 |   const nameEQ = encodeURIComponent(name) + '=';
73 |   const ca = document.cookie.split(';');
74 | 
75 |   for (let i = 0; i < ca.length; i++) {
76 |     let c = ca[i];
77 |     while (c.charAt(0) === ' ') {
78 |       c = c.substring(1, c.length);
79 |     }
80 |     if (c.indexOf(nameEQ) === 0) {
81 |       return decodeURIComponent(c.substring(nameEQ.length, c.length));
82 |     }
83 |   }
84 | 
85 |   return null;
[TRUNCATED]
```

src/lib/db-check.js
```
1 | import { PrismaClient } from '@prisma/client';
2 | 
3 | let prisma;
4 | 
5 | if (process.env.NODE_ENV === 'production') {
6 |   prisma = new PrismaClient();
7 | } else {
8 |   if (!global.prisma) {
9 |     global.prisma = new PrismaClient();
10 |   }
11 |   prisma = global.prisma;
12 | }
13 | 
14 | export async function checkDatabaseConnection() {
15 |   try {
16 |     // 간단한 쿼리로 연결 확인
17 |     await prisma.$queryRaw`SELECT 1`;
18 |     return { connected: true };
19 |   } catch (error) {
20 |     console.error('데이터베이스 연결 오류:', error);
21 |     return { 
22 |       connected: false, 
23 |       error: error.message,
24 |       tips: [
25 |         '.env 파일에 DATABASE_URL이 올바르게 설정되었는지 확인하세요.',
26 |         'PostgreSQL 서버가 실행 중인지 확인하세요.',
27 |         '데이터베이스 "backyard"가 생성되었는지 확인하세요.',
28 |         '사용자 이름과 비밀번호가 올바른지 확인하세요.'
29 |       ]
30 |     };
31 |   }
32 | }
33 | 
34 | export { prisma }; 
```

src/lib/db-init.ts
```
1 | /**
2 |  * 파일명: db-init.ts
3 |  * 목적: 데이터베이스 초기화 및 테이블 생성
4 |  * 역할: 애플리케이션 시작 시 필요한 데이터베이스 구조 설정
5 |  * 작성일: 2025-03-08
6 |  * 수정일: 2025-04-09
7 |  */
8 | 
9 | import { PrismaClient } from '@prisma/client';
10 | 
11 | import { createClient } from './supabase/server';
12 | 
13 | // 테이블 정의 및 생성 SQL
14 | const tableDefinitions = {
15 |   users: `
16 |     CREATE TABLE IF NOT EXISTS users (
17 |       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
18 |       email TEXT UNIQUE NOT NULL,
19 |       name TEXT,
20 |       created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
21 |       updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
22 |     );
23 |   `,
24 |   cards: `
25 |     CREATE TABLE IF NOT EXISTS cards (
26 |       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
27 |       title TEXT NOT NULL,
28 |       content TEXT,
29 |       created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
30 |       updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
31 |       user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE
32 |     );
33 |   `,
34 |   tags: `
35 |     CREATE TABLE IF NOT EXISTS tags (
36 |       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
37 |       name TEXT UNIQUE NOT NULL,
38 |       created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
39 |       updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
40 |     );
41 |   `,
42 |   card_tags: `
43 |     CREATE TABLE IF NOT EXISTS card_tags (
44 |       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
45 |       card_id UUID NOT NULL REFERENCES cards(id) ON DELETE CASCADE,
46 |       tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
47 |       created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
48 |       UNIQUE(card_id, tag_id)
49 |     );
50 |   `,
51 |   board_settings: `
52 |     CREATE TABLE IF NOT EXISTS board_settings (
53 |       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
54 |       user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
55 |       settings JSONB NOT NULL,
56 |       created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
57 |       updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
58 |     );
59 |   `
60 | };
61 | 
62 | // RLS 정책 설정 SQL
63 | const rlsPolicies = {
64 |   users: `
65 |     ALTER TABLE users ENABLE ROW LEVEL SECURITY;
66 |     
67 |     -- 사용자는 자신의 정보만 볼 수 있음
[TRUNCATED]
```

src/lib/debug-utils.ts
```
1 | /*
2 |   @description: 디버깅용 로컬 스토리지 초기화 함수
3 | */
4 | 
5 | import { BOARD_SETTINGS_KEY } from './ideamap-constants';
6 | 
7 | // 디버깅용 로컬 스토리지 초기화 함수
8 | export function resetLocalStorageBoardSettings() {
9 |   try {
10 |     localStorage.removeItem(BOARD_SETTINGS_KEY);
11 |     console.log('보드 설정 로컬 스토리지 초기화 완료');
12 |     return true;
13 |   } catch (e) {
14 |     console.error('보드 설정 초기화 실패:', e);
15 |     return false;
16 |   }
17 | }
18 | 
19 | // 현재 보드 설정 출력 함수
20 | export function logCurrentBoardSettings() {
21 |   try {
22 |     const settings = localStorage.getItem(BOARD_SETTINGS_KEY);
23 |     console.log('현재 보드 설정 (localStorage):', settings ? JSON.parse(settings) : null);
24 |     
25 |     // Zustand 저장소 내용도 확인
26 |     const appStorage = localStorage.getItem('backyard-app-storage');
27 |     console.log('Zustand 앱 스토리지:', appStorage ? JSON.parse(appStorage) : null);
28 |     
29 |     return settings ? JSON.parse(settings) : null;
30 |   } catch (e) {
31 |     console.error('보드 설정 출력 실패:', e);
32 |     return null;
33 |   }
34 | }
35 | 
36 | // Zustand 스토리지 초기화 함수
37 | export function resetZustandStorage() {
38 |   try {
39 |     localStorage.removeItem('backyard-app-storage');
40 |     console.log('Zustand 스토리지 초기화 완료');
41 |     return true;
42 |   } catch (e) {
43 |     console.error('Zustand 스토리지 초기화 실패:', e);
44 |     return false;
45 |   }
46 | }
47 | 
48 | // 전체 스토리지 초기화 함수
49 | export function resetAllStorage() {
50 |   const boardReset = resetLocalStorageBoardSettings();
51 |   const zustandReset = resetZustandStorage();
52 |   
53 |   return boardReset && zustandReset;
54 | } 
```

src/lib/environment.ts
```
1 | /**
2 |  * 파일명: environment.ts
3 |  * 목적: 실행 환경 감지 유틸리티
4 |  * 역할: 클라이언트/서버 환경 감지 및 환경별 코드 실행 제공
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | /**
9 |  * isClient: 현재 코드가 클라이언트(브라우저) 환경에서 실행 중인지 확인
10 |  * @returns {boolean} 클라이언트 환경 여부
11 |  */
12 | export const isClient = (): boolean => {
13 |   return typeof window !== 'undefined';
14 | };
15 | 
16 | /**
17 |  * isServer: 현재 코드가 서버 환경에서 실행 중인지 확인
18 |  * @returns {boolean} 서버 환경 여부
19 |  */
20 | export const isServer = (): boolean => {
21 |   return typeof window === 'undefined';
22 | };
23 | 
24 | /**
25 |  * executeOnClient: 클라이언트 환경에서만 함수 실행
26 |  * @param {Function} fn - 클라이언트에서 실행할 함수
27 |  * @returns {any | undefined} 함수 실행 결과 또는 undefined
28 |  */
29 | export const executeOnClient = <T>(fn: () => T): T | undefined => {
30 |   if (isClient()) {
31 |     return fn();
32 |   }
33 |   return undefined;
34 | };
35 | 
36 | /**
37 |  * executeOnServer: 서버 환경에서만 함수 실행
38 |  * @param {Function} fn - 서버에서 실행할 함수
39 |  * @returns {any | undefined} 함수 실행 결과 또는 undefined
40 |  */
41 | export const executeOnServer = <T>(fn: () => T): T | undefined => {
42 |   if (isServer()) {
43 |     return fn();
44 |   }
45 |   return undefined;
46 | };
47 | 
48 | /**
49 |  * getEnvironment: 현재 실행 환경 반환
50 |  * @returns {'client' | 'server'} 실행 환경 문자열
51 |  */
52 | export const getEnvironment = (): 'client' | 'server' => {
53 |   return isClient() ? 'client' : 'server';
54 | };
55 | 
56 | /**
57 |  * runInEnvironment: 환경에 따라 적절한 함수 실행
58 |  * @param {Object} options - 실행 옵션
59 |  * @param {Function} options.client - 클라이언트에서 실행할 함수
60 |  * @param {Function} options.server - 서버에서 실행할 함수
61 |  * @returns {any} 환경에 맞는 함수의 실행 결과
62 |  */
63 | export const runInEnvironment = <C, S>({ 
64 |   client, 
65 |   server 
66 | }: { 
67 |   client?: () => C; 
68 |   server?: () => S; 
69 | }): C | S | undefined => {
70 |   if (isClient() && client) {
71 |     return client();
72 |   } else if (isServer() && server) {
73 |     return server();
74 |   }
75 |   return undefined;
76 | }; 
```

src/lib/flow-constants.ts
```
1 | /**
2 |  * 파일명: flow-constants.ts
3 |  * 목적: React Flow 관련 상수 정의
4 |  * 역할: 싱글톤 패턴으로 구현하여 항상 동일한 객체 참조를 유지함
5 |  * 작성일: 2025-03-09
6 |  * 수정일: 2025-03-28
7 |  */
8 | 
9 | import CardNode from '@/components/ideamap/nodes/CardNode';
10 | import CustomEdge from '@/components/ideamap/nodes/CustomEdge';
11 | import NodeInspect from '@/components/ideamap/nodes/NodeInspect';
12 | 
13 | // 1. 먼저 타입 키 상수를 정의 (문자열만 포함)
14 | // 노드 타입 키 정의 - 문자열 상수로 분리
15 | export const NODE_TYPES_KEYS = Object.freeze({
16 |   card: 'card',
17 |   nodeInspect: 'nodeInspect',
18 |   default: 'default'
19 | });
20 | 
21 | // 엣지 타입 키 정의
22 | export const EDGE_TYPES_KEYS = Object.freeze({
23 |   custom: 'custom',
24 |   default: 'default'
25 | });
26 | 
27 | // 2. 그 다음 컴포넌트 정의 검증
28 | // 컴포넌트 유효성 확인
29 | const isValidComponent = (component: any): boolean => {
30 |   return typeof component === 'function';
31 | };
32 | 
33 | // 디버깅 로그 - 컴포넌트 검증
34 | console.log('[flow-constants] 컴포넌트 유효성 검증:', {
35 |   cardNode: isValidComponent(CardNode) ? 'OK' : 'ERROR',
36 |   customEdge: isValidComponent(CustomEdge) ? 'OK' : 'ERROR',
37 |   nodeInspect: isValidComponent(NodeInspect) ? 'OK' : 'ERROR'
38 | });
39 | 
40 | // 3. 타입 키와 컴포넌트 연결
41 | // 노드 타입 정의 - 객체 프리징하여 변경 불가능하게 함
42 | export const NODE_TYPES = Object.freeze({
43 |   [NODE_TYPES_KEYS.card]: CardNode,
44 |   [NODE_TYPES_KEYS.nodeInspect]: NodeInspect,
45 |   // React Flow 기본 타입에도 매핑
46 |   [NODE_TYPES_KEYS.default]: CardNode
47 | });
48 | 
49 | // 엣지 타입 정의 - 객체 프리징하여 변경 불가능하게 함
50 | export const EDGE_TYPES = Object.freeze({
51 |   [EDGE_TYPES_KEYS.custom]: CustomEdge,
52 |   // React Flow는 'default' 타입을 찾지 못하면 fallback으로 사용합니다.
53 |   // 명시적으로 'default' 타입도 등록합니다.
54 |   [EDGE_TYPES_KEYS.default]: CustomEdge
55 | });
56 | 
57 | // 4. 최종 로그 출력
58 | // 디버깅 로그 추가
59 | console.log('[flow-constants] 노드 및 엣지 타입 등록 완료:', {
60 |   NODE_TYPES_KEYS: Object.keys(NODE_TYPES_KEYS),
61 |   EDGE_TYPES_KEYS: Object.keys(EDGE_TYPES_KEYS),
62 |   NODE_TYPES: Object.keys(NODE_TYPES),
63 |   EDGE_TYPES: Object.keys(EDGE_TYPES)
64 | });
65 | 
66 | // 타입 검증 - 디버깅용
67 | if (!NODE_TYPES || !NODE_TYPES[NODE_TYPES_KEYS.card]) {
68 |   console.error('[flow-constants] NODE_TYPES가 제대로 정의되지 않았습니다!');
69 | }
70 | 
71 | if (!EDGE_TYPES || !EDGE_TYPES[EDGE_TYPES_KEYS.custom]) {
72 |   console.error('[flow-constants] EDGE_TYPES가 제대로 정의되지 않았습니다!');
73 | } 
```

src/lib/ideamap-constants.ts
```
1 | import { ConnectionLineType, MarkerType } from '@xyflow/react';
2 | 
3 | // 스냅 그리드 옵션
4 | export const SNAP_GRID_OPTIONS = [
5 |   { value: 0, label: '끄기' },
6 |   { value: 10, label: '10px' },
7 |   { value: 15, label: '15px' },
8 |   { value: 20, label: '20px' },
9 |   { value: 25, label: '25px' },
10 | ];
11 | 
12 | // 기본 스냅 그리드 설정
13 | export const DEFAULT_SNAP_GRID = [15, 15];
14 | 
15 | // 연결선 타입 옵션
16 | export const CONNECTION_TYPE_OPTIONS = [
17 |   { value: ConnectionLineType.Bezier, label: '곡선 (Bezier)' },
18 |   { value: ConnectionLineType.Straight, label: '직선 (Straight)' },
19 |   { value: ConnectionLineType.Step, label: '계단식 (Step)' },
20 |   { value: ConnectionLineType.SmoothStep, label: '부드러운 계단식 (SmoothStep)' },
21 |   { value: ConnectionLineType.SimpleBezier, label: '단순 곡선 (SimpleBezier)' },
22 | ];
23 | 
24 | // 화살표 마커 타입 옵션
25 | export const MARKER_TYPE_OPTIONS = [
26 |   { value: MarkerType.Arrow, label: '화살표 (Arrow)' },
27 |   { value: MarkerType.ArrowClosed, label: '닫힌 화살표 (ArrowClosed)' },
28 |   { value: null, label: '없음 (None)' },
29 | ];
30 | 
31 | // 연결선 두께 옵션
32 | export const STROKE_WIDTH_OPTIONS = [
33 |   { value: 1, label: '얇게 (1px)' },
34 |   { value: 2, label: '보통 (2px)' },
35 |   { value: 3, label: '굵게 (3px)' },
36 |   { value: 4, label: '매우 굵게 (4px)' },
37 | ];
38 | 
39 | // 마커 크기 옵션
40 | export const MARKER_SIZE_OPTIONS = [
41 |   { value: 10, label: '작게 (10px)' },
42 |   { value: 15, label: '보통 (15px)' },
43 |   { value: 20, label: '크게 (20px)' },
44 |   { value: 25, label: '매우 크게 (25px)' },
45 | ];
46 | 
47 | // 연결선 애니메이션 옵션
48 | export const EDGE_ANIMATION_OPTIONS = [
49 |   { value: true, label: '켜기' },
50 |   { value: false, label: '끄기' },
51 | ];
52 | 
53 | // 연결선 색상 옵션
54 | export const EDGE_COLOR_OPTIONS = [
55 |   { value: '#C1C1C1', label: '회색 (기본)', color: '#C1C1C1' },
56 |   { value: '#000000', label: '검정색', color: '#000000' },
57 |   { value: '#FF0072', label: '핑크색', color: '#FF0072' },
58 |   { value: '#3366FF', label: '파란색', color: '#3366FF' },
59 |   { value: '#43A047', label: '녹색', color: '#43A047' },
60 |   { value: '#FFC107', label: '노란색', color: '#FFC107' },
61 |   { value: '#9C27B0', label: '보라색', color: '#9C27B0' },
62 | ];
63 | 
64 | // 스토리지 키
65 | // export const STORAGE_KEY = 'backyard-board-layout';
66 | // export const EDGES_STORAGE_KEY = 'backyard-board-edges';
67 | // export const IDEAMAP_SETTINGS_KEY = 'backyard-board-settings';
68 | // export const TRANSFORM_STORAGE_KEY = 'backyard-board-transform'; // 뷰포트 transform 저장용 키
69 | 
70 | export const IDEAMAP_LAYOUT_STORAGE_KEY = 'backyard-board-layout';
71 | export const IDEAMAP_EDGES_STORAGE_KEY = 'backyard-board-edges';
[TRUNCATED]
```

src/lib/ideamap-ui-config.ts
```
1 | import { MarkerType, ConnectionLineType } from '@xyflow/react';
2 | import { I } from 'vitest/dist/chunks/reporters.d.CfRkRKN2.js';
3 | 
4 | import defaultConfig from '../config/uiOptions.json';
5 | 
6 | // 카드 보드 UI 설정 타입 정의
7 | export interface IdeaMapUIConfig {
8 |   autoSaveIntervalMinutes: number;
9 |   ideaMap: {
10 |     snapToGrid: boolean;
11 |     snapGrid: number[];
12 |     connectionLineType: string;
13 |     markerEnd: string | null;
14 |     strokeWidth: number;
15 |     markerSize: number;
16 |     edgeColor: string;
17 |     animated: boolean;
18 |     selectedEdgeColor: string;
19 |   };
20 |   card: {
21 |     defaultWidth: number;
22 |     backgroundColor: string;
23 |     borderRadius: number;
24 |     tagBackgroundColor: string;
25 |     fontSizes?: {
26 |       default: number;
27 |       title: number;
28 |       content: number;
29 |       tags: number;
30 |     };
31 |   };
32 |   handles: {
33 |     size: number;
34 |     backgroundColor: string;
35 |     borderColor: string;
36 |     borderWidth: number;
37 |   };
38 |   layout: {
39 |     defaultPadding: number;
40 |     defaultSpacing: {
41 |       horizontal: number;
42 |       vertical: number;
43 |     };
44 |     nodeSize?: {
45 |       width: number;
46 |       height: number;
47 |       maxHeight?: number;
48 |     };
49 |     graphSettings?: {
50 |       nodesep: number;
51 |       ranksep: number;
52 |       edgesep: number;
53 |     };
54 |   };
55 | }
56 | 
57 | // CSS 변수에서 값을 가져오는 함수 (클라이언트 사이드에서만 작동)
58 | export function getCssVariable(name: string, fallback: string): string {
59 |   if (typeof window !== 'undefined') {
60 |     return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback;
61 |   }
62 |   return fallback;
63 | }
64 | 
65 | // CSS 변수에서 숫자 값을 가져오는 함수
66 | export function getCssVariableAsNumber(name: string, fallback: number): number {
67 |   if (typeof window !== 'undefined') {
68 |     const value = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
69 |     if (value) {
70 |       // px 단위 제거 및 숫자로 변환
71 |       const numericValue = parseFloat(value.replace('px', '').replace('rem', ''));
72 |       return isNaN(numericValue) ? fallback : numericValue;
73 |     }
74 |   }
75 |   return fallback;
76 | }
77 | 
78 | // 기본 설정값 (타입 변환 포함)
79 | export const DEFAULT_UI_CONFIG: IdeaMapUIConfig = {
80 |   ...defaultConfig as IdeaMapUIConfig,
81 |   ideaMap: {
82 |     ...defaultConfig.ideaMap,
83 |     connectionLineType: defaultConfig.ideaMap.connectionLineType as ConnectionLineType,
84 |     markerEnd: defaultConfig.ideaMap.markerEnd as MarkerType,
85 |     selectedEdgeColor: '#000000',
86 |     snapGrid: defaultConfig.ideaMap.snapGrid as number[],
87 |   }
88 | };
89 | 
90 | /**
91 |  * 기본 설정을 불러오는 함수
92 |  * - 기본값을 불러오지 못할 경우 하드코딩된 대체 기본값을 사용
93 |  * - CSS 변수가 정의되어 있으면 CSS 변수 값을 우선 사용
94 |  */
95 | export function loadDefaultIdeaMapUIConfig(): IdeaMapUIConfig {
96 |   try {
[TRUNCATED]
```

src/lib/ideamap-utils.ts
```
1 | /**
2 |  * 파일명: src/lib/ideamap-utils.ts
3 |  * 목적: 아이디어맵 관련 유틸리티 함수 모음
4 |  * 역할: 아이디어맵 설정 관리 및 스타일 적용 유틸리티 제공
5 |  * 작성일: 2024-05-22
6 |  * 수정일: 2024-05-29 : API URL 환경 변수를 사용하도록 수정
7 |  */
8 | 
9 | import { Edge, MarkerType, ConnectionLineType } from '@xyflow/react';
10 | 
11 | import { IDEAMAP_SETTINGS_STORAGE_KEY } from './ideamap-constants';
12 | 
13 | // API URL 가져오기
14 | const getApiUrl = () => {
15 |   const apiUrl = process.env.NEXT_PUBLIC_API_URL || '';
16 |   return apiUrl;
17 | };
18 | 
19 | export interface IdeaMapSettings {
20 |   // 그리드 설정
21 |   snapToGrid: boolean;
22 |   snapGrid: [number, number];
23 |   
24 |   // 연결선 설정
25 |   connectionLineType: ConnectionLineType;
26 |   markerEnd: MarkerType | null;
27 |   strokeWidth: number;
28 |   markerSize: number;
29 |   edgeColor: string;
30 |   selectedEdgeColor: string;
31 |   animated: boolean;
32 | }
33 | 
34 | // 기본 아이디어맵 설정
35 | export const DEFAULT_IDEAMAP_SETTINGS: IdeaMapSettings = {
36 |   // 그리드 설정
37 |   snapToGrid: false,
38 |   snapGrid: [15, 15],
39 |   
40 |   // 연결선 설정
41 |   connectionLineType: ConnectionLineType.SmoothStep,
42 |   markerEnd: MarkerType.Arrow,
43 |   strokeWidth: 2,
44 |   markerSize: 20,
45 |   edgeColor: '#C1C1C1',
46 |   selectedEdgeColor: '#FF0072',
47 |   animated: false,
48 | };
49 | 
50 | /**
51 |  * 로컬 스토리지에서 아이디어맵 설정을 불러오는 함수
52 |  */
53 | export function loadIdeaMapSettings(): IdeaMapSettings {
54 |   if (typeof window === 'undefined') {
55 |     return DEFAULT_IDEAMAP_SETTINGS;
56 |   }
57 | 
58 |   try {
59 |     const savedSettings = localStorage.getItem(IDEAMAP_SETTINGS_STORAGE_KEY);
60 |     
61 |     if (!savedSettings) {
62 |       return DEFAULT_IDEAMAP_SETTINGS;
63 |     }
64 | 
65 |     // 저장된 설정 복원
66 |     const parsedSettings = JSON.parse(savedSettings);
67 |     
68 |     // 기존 설정이 없는 경우 기본값으로 통합
69 |     return {
70 |       ...DEFAULT_IDEAMAP_SETTINGS,
71 |       ...parsedSettings,
72 |     };
73 |   } catch (error) {
74 |     console.error('아이디어맵 설정 로드 중 오류:', error);
75 |     return DEFAULT_IDEAMAP_SETTINGS;
76 |   }
77 | }
78 | 
79 | /**
80 |  * 아이디어맵 설정을 로컬 스토리지에 저장하는 함수
81 |  */
82 | export function saveIdeaMapSettings(settings: IdeaMapSettings): void {
83 |   if (typeof window !== 'undefined') {
84 |     try {
85 |       localStorage.setItem(IDEAMAP_SETTINGS_STORAGE_KEY, JSON.stringify(settings));
86 |     } catch (error) {
87 |       console.error('아이디어맵 설정 저장 중 오류:', error);
88 |     }
89 |   }
90 | }
91 | 
92 | /**
93 |  * 서버 API를 통해 아이디어맵 설정을 저장하는 함수
94 |  */
95 | export const saveIdeaMapSettingsToServer = async (settings: IdeaMapSettings, userId: string): Promise<boolean> => {
96 |   try {
[TRUNCATED]
```

src/lib/layout-utils.ts
```
1 | /**
2 |  * 파일명: layout-utils.ts
3 |  * 목적: React Flow 노드 레이아웃 자동화
4 |  * 역할: 그래프 레이아웃 계산 및 노드 배치 유틸리티 함수 제공
5 |  * 작성일: 2025-03-06
6 |  * 수정일: 2025-03-27
7 |  */
8 | 
9 | import { Node, Edge, Position } from '@xyflow/react';
10 | import dagre from 'dagre';
11 | 
12 | import defaultConfig from '../config/uiOptions.json';
13 | import { useTheme } from '../contexts/ThemeContext';
14 | 
15 | // 기본 노드 크기 설정 (ThemeContext가 없을 때 폴백용)
16 | const DEFAULT_NODE_WIDTH = defaultConfig.layout.nodeSize?.width || 130;
17 | const DEFAULT_NODE_HEIGHT = defaultConfig.layout.nodeSize?.height || 48;
18 | 
19 | // 그래프 간격 설정 - 설정 파일에서 가져오기
20 | const GRAPH_SETTINGS = {
21 |   rankdir: 'LR', // 방향: LR(수평) 또는 TB(수직)
22 |   nodesep: defaultConfig.layout.graphSettings.nodesep, // 같은 레벨의 노드 간 거리 (픽셀)
23 |   ranksep: defaultConfig.layout.graphSettings.ranksep, // 레벨 간 거리 (픽셀)
24 |   edgesep: defaultConfig.layout.graphSettings.edgesep, // 엣지 간 거리
25 |   marginx: defaultConfig.layout.defaultPadding || 20, // 가로 마진은 defaultPadding 사용
26 |   marginy: defaultConfig.layout.defaultPadding || 20  // 세로 마진은 defaultPadding 사용
27 | };
28 | 
29 | /**
30 |  * React 컴포넌트에서 사용할 수 있는 레이아웃 훅
31 |  * ThemeContext에서 노드 크기를 가져와 레이아웃을 계산합니다.
32 |  */
33 | export function useLayoutedElements() {
34 |   const { theme } = useTheme();
35 |   
36 |   /**
37 |    * dagre 라이브러리를 사용하여 노드와 엣지의 레이아웃을 재배치하는 함수
38 |    * 
39 |    * @param nodes 노드 배열
40 |    * @param edges 엣지 배열
41 |    * @param direction 배치 방향 ('horizontal' 또는 'vertical')
42 |    * @returns 레이아웃이 적용된 노드와 엣지
43 |    */
44 |   const getLayoutedElements = (
45 |     nodes: Node[],
46 |     edges: Edge[],
47 |     direction: 'horizontal' | 'vertical' = 'horizontal'
48 |   ) => {
49 |     // 노드나 엣지가 없는 경우 그대로 반환
50 |     if (nodes.length === 0) return { nodes, edges };
51 | 
52 |     // ThemeContext에서 노드 크기 가져오기
53 |     const NODE_WIDTH = theme.node.width;
54 |     const NODE_HEIGHT = theme.node.height;
55 | 
56 |     // 그래프 생성
57 |     const dagreGraph = new dagre.graphlib.Graph();
58 |     dagreGraph.setDefaultEdgeLabel(() => ({}));
59 | 
60 |     // 방향 설정 (LR: 왼쪽에서 오른쪽, TB: 위에서 아래)
61 |     const isHorizontal = direction === 'horizontal';
62 |     const settings = {
63 |       ...GRAPH_SETTINGS,
64 |       rankdir: isHorizontal ? 'LR' : 'TB',
65 |     };
66 |     
67 |     dagreGraph.setGraph(settings);
68 | 
69 |     // 노드 추가
70 |     nodes.forEach(node => {
71 |       dagreGraph.setNode(node.id, { width: NODE_WIDTH, height: NODE_HEIGHT });
72 |     });
73 | 
74 |     // 엣지 추가
75 |     edges.forEach(edge => {
[TRUNCATED]
```

src/lib/logger.ts
```
1 | /**
2 |  * 파일명: logger.ts
3 |  * 목적: 통합 로깅 시스템 제공
4 |  * 역할: 브라우저와 서버 양쪽에서 로그를 기록하고 필요시 서버로 로그를 전송
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-07
7 |  */
8 | 
9 | // 로그 레벨 정의
10 | export enum LogLevel {
11 |   DEBUG = 'debug',
12 |   INFO = 'info',
13 |   WARN = 'warn',
14 |   ERROR = 'error'
15 | }
16 | 
17 | // 로그 데이터 인터페이스
18 | interface LogData {
19 |   timestamp: string;
20 |   level: LogLevel;
21 |   module: string;
22 |   message: string;
23 |   data?: any;
24 |   sessionId?: string;
25 | }
26 | 
27 | // 세션 ID 생성
28 | const generateSessionId = (): string => {
29 |   return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
30 | };
31 | 
32 | // 로그 저장소
33 | class LogStorage {
34 |   private static instance: LogStorage;
35 |   private logs: LogData[] = [];
36 |   private sessionId: string;
37 |   private readonly MAX_LOGS = 100;
38 | 
39 |   private constructor() {
40 |     this.sessionId = generateSessionId();
41 |     
42 |     // 브라우저 환경이면 로컬 스토리지에서 세션 ID 복원 시도
43 |     if (typeof window !== 'undefined') {
44 |       const storedSessionId = localStorage.getItem('logger.sessionId');
45 |       if (storedSessionId) {
46 |         this.sessionId = storedSessionId;
47 |       } else {
48 |         localStorage.setItem('logger.sessionId', this.sessionId);
49 |       }
50 |     }
51 |   }
52 | 
53 |   public static getInstance(): LogStorage {
54 |     if (!LogStorage.instance) {
55 |       LogStorage.instance = new LogStorage();
56 |     }
57 |     return LogStorage.instance;
58 |   }
59 | 
60 |   public getSessionId(): string {
61 |     return this.sessionId;
62 |   }
63 | 
64 |   public addLog(log: LogData): void {
65 |     // 세션 ID 추가
66 |     log.sessionId = this.sessionId;
67 |     
68 |     // 로그 저장
69 |     this.logs.push(log);
70 |     
71 |     // 최대 로그 수 제한
72 |     if (this.logs.length > this.MAX_LOGS) {
73 |       this.logs.shift();
74 |     }
75 |     
76 |     // 브라우저 환경이면 로컬 스토리지에 로그 저장
77 |     if (typeof window !== 'undefined') {
78 |       try {
79 |         localStorage.setItem('logger.logs', JSON.stringify(this.logs));
80 |       } catch (error) {
81 |         console.error('로그 저장 실패:', error);
82 |       }
83 |     }
84 |   }
85 | 
86 |   public getLogs(): LogData[] {
87 |     return [...this.logs];
88 |   }
89 | 
90 |   public clearLogs(): void {
91 |     this.logs = [];
92 |     if (typeof window !== 'undefined') {
93 |       localStorage.removeItem('logger.logs');
94 |     }
95 |   }
96 | }
97 | 
98 | /**
[TRUNCATED]
```

src/lib/prisma.ts
```
1 | import { PrismaClient } from '@prisma/client';
2 | 
3 | // Prisma 클라이언트 인스턴스를 글로벌로 관리하여 핫 리로드 시 연결이 중복 생성되는 것을 방지
4 | const globalForPrisma = global as unknown as { prisma: PrismaClient };
5 | 
6 | // 환경 변수 유효성 확인
7 | function validateEnv() {
8 |   const requiredEnvVars = ['DATABASE_URL'];
9 |   const missingEnvVars = requiredEnvVars.filter(envVar => !process.env[envVar]);
10 |   
11 |   if (missingEnvVars.length > 0) {
12 |     console.warn(`⚠️ 누락된 데이터베이스 환경 변수: ${missingEnvVars.join(', ')}`);
13 |     return false;
14 |   }
15 |   return true;
16 | }
17 | 
18 | // 개발 환경에서는 로깅 활성화, 프로덕션에서는 비활성화
19 | let prisma: PrismaClient;
20 | 
21 | try {
22 |   // 환경 변수 확인
23 |   const isEnvValid = validateEnv();
24 |   
25 |   if (!isEnvValid && process.env.NODE_ENV === 'production') {
26 |     console.error('❌ 프로덕션 환경에서 필수 데이터베이스 환경 변수가 누락되었습니다.');
27 |     // 프로덕션 환경에서는 명시적으로 오류를 발생시키지 않고 로깅만 수행
28 |   }
29 |   
30 |   prisma = 
31 |     globalForPrisma.prisma ||
32 |     new PrismaClient({
33 |       log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
34 |     });
35 |   
36 |   // 연결 테스트
37 |   if (process.env.NODE_ENV === 'development') {
38 |     prisma.$connect()
39 |       .then(() => console.log('✅ Prisma 데이터베이스 연결 성공'))
40 |       .catch(error => console.error('❌ Prisma 데이터베이스 연결 실패:', error));
41 |   }
42 | } catch (error) {
43 |   console.error('❌ Prisma 클라이언트 초기화 오류:', error);
44 |   // 개발 환경에서는 오류 발생 시 더미 Prisma 클라이언트를 사용
45 |   if (process.env.NODE_ENV !== 'production') {
46 |     console.warn('⚠️ 더미 Prisma 클라이언트를 사용합니다. 데이터베이스 작업이 제한됩니다.');
47 |     // @ts-ignore - 더미 클라이언트 생성
48 |     prisma = new Proxy({}, {
49 |       get: (target, prop) => {
50 |         // 기본 속성
51 |         if (prop === 'then' || prop === '$connect' || prop === '$disconnect') {
52 |           return () => Promise.resolve();
53 |         }
54 |         // 모델 접근 시 더미 모델 반환
55 |         return new Proxy({}, {
56 |           get: () => (...args: any[]) => {
57 |             console.warn(`⚠️ 데이터베이스 연결 없이 Prisma 작업이 호출되었습니다: ${String(prop)}`);
58 |             return Promise.resolve([]);
59 |           }
60 |         });
61 |       }
62 |     });
63 |   } else {
64 |     // 프로덕션 환경에서는 최소한의 기능을 갖춘 클라이언트 제공
65 |     // @ts-ignore - 더미 클라이언트 생성
66 |     prisma = new PrismaClient();
67 |   }
68 | }
69 | 
70 | // 개발 환경에서 글로벌 인스턴스 저장
71 | if (process.env.NODE_ENV !== 'production' && prisma) {
72 |   globalForPrisma.prisma = prisma;
73 | }
74 | 
75 | export default prisma;
```

src/lib/supabase-server.ts
```
1 | /**
2 |  * 파일명: supabase-server.ts
3 |  * 목적: 서버 컴포넌트에서 Supabase 클라이언트 접근
4 |  * 역할: 서버 측 Supabase 인스턴스 생성 및 관리
5 |  * 작성일: 2025-03-08
6 |  * 수정일: 2025-03-27
7 |  */
8 | 
9 | import { cookies } from 'next/headers';
10 | 
11 | import { createServerClient } from '@supabase/ssr';
12 | 
13 | import { Database } from '../types/supabase';
14 | 
15 | /**
16 |  * createServerSupabaseClient: 서버 컴포넌트에서 사용할 Supabase 클라이언트 생성
17 |  * 각 요청마다 새로운 인스턴스 생성 (서버 컴포넌트에서는 싱글톤 패턴 사용 불가)
18 |  * @returns 서버용 Supabase 클라이언트
19 |  */
20 | export async function createServerSupabaseClient() {
21 |   const cookieStore = await cookies();
22 |   
23 |   return createServerClient<Database>(
24 |     process.env.NEXT_PUBLIC_SUPABASE_URL!,
25 |     process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
26 |     {
27 |       cookies: {
28 |         get(name: string) {
29 |           return cookieStore.get(name)?.value;
30 |         },
31 |         set(name: string, value: string, options: any) {
32 |           // Next.js App Router에서는 쿠키를 직접 설정할 수 없으므로
33 |           // 이 함수는 클라이언트로의 응답에 포함될 때만 동작합니다
34 |         },
35 |         remove(name: string, options: any) {
36 |           // 마찬가지로 클라이언트로의 응답에 포함될 때만 동작
37 |         },
38 |       },
39 |     }
40 |   );
41 | }
42 | 
43 | /**
44 |  * getServerSession: 서버 컴포넌트에서 현재 세션 조회
45 |  * @returns Supabase 세션 또는 null
46 |  */
47 | export async function getServerSession() {
48 |   try {
49 |     const supabase = await createServerSupabaseClient();
50 |     const { data: { session } } = await supabase.auth.getSession();
51 |     return session;
52 |   } catch (error) {
53 |     console.error('서버 세션 조회 중 오류:', error);
54 |     return null;
55 |   }
56 | } 
```

src/lib/utils.ts
```
1 | import { type ClassValue, clsx } from "clsx"
2 | import { twMerge } from "tailwind-merge"
3 | 
4 | export function cn(...inputs: ClassValue[]) {
5 |   return twMerge(clsx(inputs))
6 | }
7 | 
8 | /**
9 |  * 날짜 문자열을 포맷팅합니다.
10 |  * @param {string | Date} dateInput - 날짜 문자열 또는 Date 객체
11 |  * @returns {string} 포맷팅된 날짜 문자열
12 |  */
13 | export function formatDate(dateInput: string | Date): string {
14 |   if (!dateInput) return '';
15 |   
16 |   try {
17 |     const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
18 |     
19 |     // 유효한 날짜인지 확인
20 |     if (isNaN(date.getTime())) {
21 |       return String(dateInput);
22 |     }
23 |     
24 |     // YYYY년 MM월 DD일 형식으로 변환
25 |     return date.toLocaleDateString('ko-KR', {
26 |       year: 'numeric',
27 |       month: 'long',
28 |       day: 'numeric',
29 |       hour: '2-digit',
30 |       minute: '2-digit'
31 |     });
32 |   } catch (error) {
33 |     console.error('날짜 포맷팅 오류:', error);
34 |     return String(dateInput);
35 |   }
36 | }
37 | 
38 | // 텍스트에서 태그 추출 (#태그 형식)
39 | export function extractTags(text: string): string[] {
40 |   const tagPattern = /#([a-zA-Z0-9가-힣_\-]+)/g;
41 |   const matches = text.match(tagPattern);
42 |   
43 |   if (!matches) return [];
44 |   
45 |   return matches.map(tag => tag.slice(1)); // # 제거
46 | }
47 | 
48 | // 텍스트에서 태그를 변환 (#태그 -> Badge 컴포넌트로 변환하기 위한 준비)
49 | export function parseTagsInText(text: string): { text: string, tags: string[] } {
50 |   const tags = extractTags(text);
51 |   return { text, tags };
52 | }
53 | 
54 | /**
55 |  * hexToHsl: 16진수 색상 코드를 HSL 색상값으로 변환
56 |  * @param {string} hex - 16진수 색상 코드 (예: "#ff0000")
57 |  * @returns {{ h: number, s: number, l: number } | null} HSL 색상값 또는 변환 실패 시 null
58 |  */
59 | export function hexToHsl(hex: string): { h: number, s: number, l: number } | null {
60 |   if (!hex) return null;
61 |   
62 |   // hex를 RGB로 변환
63 |   const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
64 |   if (!result) return null;
65 |   
66 |   const r = parseInt(result[1], 16) / 255;
67 |   const g = parseInt(result[2], 16) / 255;
68 |   const b = parseInt(result[3], 16) / 255;
69 | 
70 |   const max = Math.max(r, g, b);
71 |   const min = Math.min(r, g, b);
72 |   let h = 0, s = 0;
73 |   const l = (max + min) / 2;
74 | 
75 |   if (max !== min) {
[TRUNCATED]
```

src/store/useAppStore.ts
```
1 | import { ReactFlowInstance, Node, Edge } from '@xyflow/react'
2 | import { toast } from 'sonner'
3 | import { create } from 'zustand'
4 | import { persist, subscribeWithSelector, createJSONStorage } from 'zustand/middleware'
5 | 
6 | import { saveAllLayoutData } from '@/components/ideamap/utils/ideamap-graphUtils'
7 | import { signOut, getCurrentUser } from "@/lib/auth"
8 | import { IDEAMAP_LAYOUT_STORAGE_KEY, IDEAMAP_EDGES_STORAGE_KEY } from '@/lib/ideamap-constants'
9 | import { 
10 |   IdeaMapSettings, 
11 |   DEFAULT_IDEAMAP_SETTINGS, 
12 |   loadIdeaMapSettings,
13 |   saveIdeaMapSettings
14 | } from '@/lib/ideamap-utils'
15 | import { getLayoutedElements, getGridLayout } from '@/lib/layout-utils'
16 | import type { CreateCardInput } from '@/types/card'
17 | 
18 | // 카드 타입 정의 (src/types/card.ts와 일치하도록 수정, API 응답 고려)
19 | export interface Card {
20 |   id: string;
21 |   title: string;
22 |   content: string | null;
23 |   createdAt: string;
24 |   updatedAt: string;
25 |   userId: string;
26 |   user?: import('@/types/card').User;
27 |   cardTags?: Array<{ tag: { id: string; name: string; } }>;
28 |   [key: string]: any;
29 | }
30 | 
31 | // 프로젝트 정보 인터페이스
32 | export interface Project {
33 |   id: string;
34 |   name: string;
35 |   ownerNickname?: string;
36 |   userId: string;
37 |   createdAt: string;
38 |   updatedAt: string;
39 |   settings?: any;
40 | }
41 | 
42 | export interface AppState {
43 |   // 선택된 카드 상태 (통합된 단일 소스)
44 |   selectedCardIds: string[];
45 |   // 이전 단일 선택 상태 (내부적으로 selectedCardIds로 변환)
46 |   selectedCardId: string | null; // 하위 호환성 유지 (파생 값)
47 |   // 확장된 카드 ID
48 |   expandedCardId: string | null;
49 |   
50 |   // 선택 관련 액션들
51 |   selectCard: (cardId: string | null) => void; // 단일 카드 선택 (내부적으로 selectCards 사용)
52 |   selectCards: (cardIds: string[]) => void; // 다중 카드 선택 (주요 액션)
53 |   addSelectedCard: (cardId: string) => void; // 선택된 카드 목록에 추가
54 |   removeSelectedCard: (cardId: string) => void; // 선택된 카드 목록에서 제거
55 |   toggleSelectedCard: (cardId: string) => void; // 선택된 카드 목록에서 토글
56 |   clearSelectedCards: () => void; // 모든 선택 해제
57 |   // 카드 확장 액션
58 |   toggleExpandCard: (cardId: string) => void; // 카드 확장 토글
59 |   
60 |   // 카드 데이터 상태
61 |   cards: Card[]; // 현재 로드된 카드 목록
62 |   setCards: (cards: Card[]) => void; // 카드 목록 설정
63 |   updateCard: (updatedCard: Card) => void; // 단일 카드 업데이트
64 |   createCard: (input: CreateCardInput) => Promise<Card | null>; // 카드 생성 액션 추가
65 |   
66 |   // 사이드바 상태
67 |   isSidebarOpen: boolean;
68 |   setSidebarOpen: (open: boolean) => void;
69 |   toggleSidebar: () => void;
70 |   
71 |   // 레이아웃 옵션 (수평/수직/자동배치/없음)
72 |   layoutDirection: 'horizontal' | 'vertical' | 'auto' | 'none';
[TRUNCATED]
```

src/store/useAuthStore.ts
```
1 | /**
2 |  * 파일명: src/store/useAuthStore.ts
3 |  * 목적: Zustand를 사용한 인증 상태 관리
4 |  * 역할: 클라이언트 측 인증 상태(토큰, 사용자 ID 등)를 중앙 집중적으로 관리
5 |  * 작성일: 2025-04-09
6 |  */
7 | 
8 | 'use client';
9 | 
10 | import { create } from 'zustand';
11 | import { persist, createJSONStorage } from 'zustand/middleware';
12 | 
13 | import createLogger from '@/lib/logger';
14 | 
15 | // 로거 생성
16 | const logger = createLogger('AuthStore');
17 | 
18 | // 인증 상태 인터페이스
19 | interface AuthState {
20 |   // 상태 (State)
21 |   accessToken: string | null;
22 |   refreshToken: string | null;
23 |   userId: string | null;
24 |   provider: string | null;
25 |   codeVerifier: string | null;
26 |   isLoading: boolean;
27 |   error: Error | null;
28 |   
29 |   // 액션 (Actions)
30 |   setTokens: (accessToken: string | null, refreshToken: string | null) => void;
31 |   setUser: (userId: string | null, provider?: string | null) => void;
32 |   setCodeVerifier: (value: string | null) => void;
33 |   setLoading: (isLoading: boolean) => void;
34 |   setError: (error: Error | null) => void;
35 |   clearAuth: () => void;
36 |   removeCodeVerifier: () => void;
37 | }
38 | 
39 | // Zustand 스토어 생성
40 | export const useAuthStore = create<AuthState>()(
41 |   persist(
42 |     (set) => ({
43 |       // 초기 상태
44 |       accessToken: null,
45 |       refreshToken: null,
46 |       userId: null,
47 |       provider: null,
48 |       codeVerifier: null,
49 |       isLoading: false,
50 |       error: null,
51 |       
52 |       // 액션 구현
53 |       setTokens: (accessToken, refreshToken) => {
54 |         logger.info('인증 토큰 설정', { 
55 |           hasAccessToken: !!accessToken, 
56 |           hasRefreshToken: !!refreshToken
57 |         });
58 |         set({ accessToken, refreshToken });
59 |       },
60 |       
61 |       setUser: (userId, provider = null) => {
62 |         logger.info('사용자 정보 설정', { 
63 |           hasUserId: !!userId, 
64 |           provider
65 |         });
66 |         set({ userId, provider });
67 |       },
68 |       
69 |       setCodeVerifier: (codeVerifier) => {
70 |         if (codeVerifier) {
71 |           logger.debug('PKCE 코드 검증기 설정', { 
72 |             length: codeVerifier.length, 
73 |             firstChars: codeVerifier.substring(0, 5) + '...' 
74 |           });
75 |         } else {
76 |           logger.debug('PKCE 코드 검증기 초기화');
77 |         }
78 |         set({ codeVerifier });
79 |       },
80 |       
81 |       setLoading: (isLoading) => {
82 |         set({ isLoading });
83 |       },
84 |       
85 |       setError: (error) => {
86 |         if (error) {
87 |           logger.error('인증 오류 설정', error);
88 |         } else {
89 |           logger.debug('인증 오류 초기화');
90 |         }
91 |         set({ error });
92 |       },
93 |       
94 |       clearAuth: () => {
95 |         logger.info('인증 상태 초기화');
96 |         set({
[TRUNCATED]
```

src/store/useIdeaMapStore.ts
```
1 | /**
2 |  * 파일명: useIdeaMapStore.ts
3 |  * 목적: Zustand를 활용한 아이디어맵 관련 전역 상태 관리
4 |  * 역할: 아이디어맵의 노드, 엣지, 설정 등 모든 상태를 중앙 관리
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2023-10-27 : 미사용 함수 제거, any 타입 구체화
7 |  * 수정일: 2024-05-09 : loadIdeaMapData 함수 개선 및 syncCardsWithNodes 함수 추가
8 |  * 수정일: 2024-05-30 : loadIdeaMapData 함수에 노드-카드 동기화 로직 추가
9 |  * 수정일: 2024-06-27 : 노드 생성 관련 디버깅 로깅 강화
10 |  * 수정일: 2024-06-28 : React Flow 초기화 및 노드/엣지 정보 주입 관련 디버깅 로깅 추가
11 |  * 수정일: 2024-07-18 : saveLayout 함수 개선 및 디버깅 로그 추가
12 |  */
13 | 
14 | import { 
15 |   Node, 
16 |   Edge, 
17 |   Connection, 
18 |   applyNodeChanges, 
19 |   applyEdgeChanges,
20 |   addEdge,
21 |   NodeChange,
22 |   EdgeChange,
23 |   XYPosition,
24 |   Viewport,
25 |   ReactFlowInstance
26 | } from '@xyflow/react';
27 | import { toast } from 'sonner';
28 | import { create } from 'zustand';
29 | import { persist } from 'zustand/middleware';
30 | 
31 | import { CardData } from '@/components/ideamap/types/ideamap-types';
32 | import { IDEAMAP_LAYOUT_STORAGE_KEY, IDEAMAP_EDGES_STORAGE_KEY, IDEAMAP_TRANSFORM_STORAGE_KEY } from '@/lib/ideamap-constants';
33 | import { 
34 |   IdeaMapSettings, 
35 |   DEFAULT_IDEAMAP_SETTINGS, 
36 |   saveIdeaMapSettings,
37 |   applyIdeaMapEdgeSettings,
38 |   loadIdeaMapSettingsFromServer,
39 |   saveIdeaMapSettingsToServer
40 | } from '@/lib/ideamap-utils';
41 | import { getLayoutedElements, getGridLayout } from '@/lib/layout-utils';
42 | import { NODE_TYPES_KEYS } from '@/lib/flow-constants';
43 | import { useAppStore } from './useAppStore';
44 | 
45 | // 확장된 Viewport 타입 (width, height 속성 포함)
46 | interface ExtendedViewport extends Viewport {
47 |   width?: number;
48 |   height?: number;
49 | }
50 | 
51 | // 아이디어맵 스토어 상태 인터페이스
52 | interface IdeaMapState {
53 |   // 노드 관련 상태
54 |   nodes: Node<CardData>[];
55 |   setNodes: (nodes: Node<CardData>[]) => void;
56 |   onNodesChange: (changes: NodeChange[]) => void;
57 |   
58 |   // 엣지 관련 상태
59 |   edges: Edge[];
60 |   setEdges: (edges: Edge[]) => void;
61 |   onEdgesChange: (changes: EdgeChange[]) => void;
62 |   onConnect: (connection: Connection) => void;
63 |   
64 |   // 아이디어맵 설정 관련 상태
65 |   ideaMapSettings: IdeaMapSettings;
66 |   setIdeaMapSettings: (settings: IdeaMapSettings) => void;
67 |   updateIdeaMapSettings: (settings: Partial<IdeaMapSettings>, isAuthenticated: boolean, userId?: string) => Promise<void>;
68 |   
69 |   // 레이아웃 관련 함수
70 |   applyLayout: (direction: 'horizontal' | 'vertical' | 'auto') => void;
71 |   applyGridLayout: () => void;
72 |   
73 |   // 저장 관련 함수
74 |   saveLayout: (nodesToSave?: Node<CardData>[]) => boolean;
75 |   saveEdges: (edgesToSave?: Edge[]) => boolean;
76 |   saveAllLayoutData: () => boolean;
77 |   
78 |   // 엣지 스타일 업데이트
79 |   updateEdgeStyles: (settings: IdeaMapSettings) => void;
[TRUNCATED]
```

src/store/useNodeStore.ts
```
1 | /**
2 |  * 파일명: useNodeStore.ts
3 |  * 목적: 노드 인스펙터 관련 상태 관리
4 |  * 역할: 선택된 노드 정보와 인스펙터 UI 상태 관리
5 |  * 작성일: 2025-03-28
6 |  */
7 | 
8 | import { Node } from '@xyflow/react';
9 | import { create } from 'zustand';
10 | 
11 | // 노드 스토어 상태 인터페이스
12 | interface NodeStore {
13 |   // 인스펙터 관련 상태
14 |   inspectorOpen: boolean;
15 |   inspectedNode: Node | null;
16 |   
17 |   // 상태 변경 함수
18 |   setInspectorOpen: (open: boolean) => void;
19 |   setInspectedNode: (node: Node | null) => void;
20 |   
21 |   // 노드 검사 함수
22 |   inspectNode: (node: Node) => void;
23 |   closeInspector: () => void;
24 | }
25 | 
26 | /**
27 |  * useNodeStore: 노드 인스펙터 관련 상태 관리 스토어
28 |  */
29 | export const useNodeStore = create<NodeStore>((set) => ({
30 |   // 초기 상태
31 |   inspectorOpen: false,
32 |   inspectedNode: null,
33 |   
34 |   // 상태 변경 함수
35 |   setInspectorOpen: (open) => set({ inspectorOpen: open }),
36 |   setInspectedNode: (node) => set({ inspectedNode: node }),
37 |   
38 |   // 유틸리티 함수
39 |   inspectNode: (node) => set({ 
40 |     inspectedNode: node, 
41 |     inspectorOpen: true 
42 |   }),
43 |   
44 |   closeInspector: () => set({ 
45 |     inspectorOpen: false 
46 |   }),
47 | })); 
```

src/tests/helper.ts
```
1 | /**
2 |  * 파일명: src/tests/helper.ts
3 |  * 목적: 테스트 유틸리티 함수 제공
4 |  * 역할: 테스트 코드에서 사용되는 공통 유틸리티 함수 모음
5 |  * 작성일: 2025-03-30
6 |  */
7 | 
8 | /**
9 |  * flushPromises: 비동기 작업이 처리될 수 있도록 이벤트 루프를 비웁니다.
10 |  * @returns {Promise<void>} 비동기 작업이 완료된 후의 프로미스
11 |  */
12 | export const flushPromises = (): Promise<void> => {
13 |   return new Promise(resolve => setTimeout(resolve, 0));
14 | }; 
```

src/tests/setup.ts
```
1 | /**
2 |  * 파일명: setup.ts
3 |  * 목적: Vitest 테스트 설정
4 |  * 역할: 테스트 환경 설정 및 전역 설정 제공
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-08 - waitFor 제대로 작동하도록 setTimeout 모킹 방식 수정
7 |  * 수정일: 2023-10-27 : 린터 오류 수정 (미사용 변수/함수 제거, 타입 문제 해결)
8 |  */
9 | 
10 | import '@testing-library/jest-dom/vitest';
11 | import * as matchers from '@testing-library/jest-dom/matchers';
12 | import { cleanup } from '@testing-library/react';
13 | import { beforeEach, afterEach, vi, expect, beforeAll, afterAll } from 'vitest';
14 | 
15 | import { server } from './msw/server'; // MSW 서버 임포트
16 | 
17 | // Testing Library의 jest-dom 매처 확장
18 | expect.extend(matchers);
19 | 
20 | // --- MSW 서버 설정 ---
21 | // Node.js v20 undici 타임아웃 이슈 해결을 위한 설정
22 | beforeAll(() => {
23 |   // fetch 타임아웃 관련 이슈 해결을 위해 bypass 모드 사용
24 |   server.listen({ 
25 |     onUnhandledRequest: 'bypass',
26 |   });
27 |   
28 |   // 타이머 모킹 제거 - wait-for가 정상적으로 작동하도록 수정
29 |   // 실제 타이머를 사용하도록 설정
30 |   if (typeof window !== 'undefined') {
31 |     // 실제 타이머를 사용 (모킹하지 않음)
32 |     vi.useRealTimers(); // waitFor가 의존하는 실제 타이머 사용
33 |   }
34 | });
35 | 
36 | afterEach(() => {
37 |   // 각 테스트 후 핸들러 초기화
38 |   server.resetHandlers();
39 |   // React 컴포넌트 정리
40 |   cleanup();
41 | });
42 | 
43 | afterAll(() => {
44 |   // 모든 테스트 후 서버 정리
45 |   server.close();
46 | });
47 | // --- MSW 서버 설정 끝 ---
48 | 
49 | // 항상 document.body가 존재하도록 함
50 | if (typeof document !== 'undefined' && !document.body) {
51 |   document.body = document.createElement('body');
52 | }
53 | 
54 | // Logger 모킹 (실제 구현과 일치하도록 수정)
55 | vi.mock('@/lib/logger', () => {
56 |   const mockLogs: any[] = [];
57 |   const mockSessionId = 'test-session-id';
58 |   let isWindowDefined = true;
59 | 
60 |   const mockLogStorage = {
61 |     getInstance: vi.fn(() => ({
62 |       getSessionId: vi.fn(() => mockSessionId),
63 |       addLog: vi.fn((log: any) => {
64 |         log.sessionId = mockSessionId;
65 |         mockLogs.push(log);
66 |         if (mockLogs.length > 100) mockLogs.shift();
67 |         
68 |         if (isWindowDefined) {
69 |           try {
70 |             localStorage.setItem('logger.logs', JSON.stringify(mockLogs));
71 |           } catch (error) {
72 |             console.error('로그 저장 실패:', error);
73 |           }
74 |         }
75 |       }),
76 |       getLogs: vi.fn(() => [...mockLogs]),
77 |       clearLogs: vi.fn(() => {
78 |         mockLogs.length = 0;
79 |         if (isWindowDefined) {
80 |           localStorage.removeItem('logger.logs');
81 |         }
82 |       })
83 |     }))
[TRUNCATED]
```

src/tests/test-utils.tsx
```
1 | /**
2 |  * 파일명: test-utils.tsx
3 |  * 목적: 테스트 유틸리티 함수 및 래퍼 제공
4 |  * 역할: Next.js, React 컴포넌트를 테스트하기 위한 유틸리티 제공
5 |  * 작성일: 2025-03-30
6 |  * 수정일: 2025-04-01
7 |  * 수정일: 2023-10-27 : 린터 오류 수정 (미사용 변수 제거)
8 |  */
9 | 
10 | import React, { ReactElement } from 'react';
11 | 
12 | import { render as rtlRender, RenderOptions, RenderResult, screen as rtlScreen } from '@testing-library/react';
13 | import userEvent from '@testing-library/user-event';
14 | import { Node, Edge, ReactFlowInstance, MarkerType } from '@xyflow/react';
15 | import { vi, expect as vitestExpect } from 'vitest';
16 | 
17 | import { CardData } from '@/components/ideamap/types/ideamap-types';
18 | 
19 | // XYFlow 모킹
20 | export const mockReactFlow = {
21 |     project: vi.fn(({ x, y }) => ({ x, y })),
22 |     getIntersectingNodes: vi.fn(() => []),
23 |     getNode: vi.fn(),
24 |     getNodes: vi.fn(() => []),
25 |     getEdge: vi.fn(),
26 |     getEdges: vi.fn(() => []),
27 |     viewportInitialized: true,
28 |     getViewport: vi.fn(() => ({ x: 0, y: 0, zoom: 1 })),
29 |     screenToFlowPosition: vi.fn(({ x, y }) => ({ x, y })),
30 | } as unknown as ReactFlowInstance;
31 | 
32 | // 테스트 노드 생성 유틸리티
33 | export const createTestNode = (id: string, position = { x: 0, y: 0 }): Node<CardData> => ({
34 |     id,
35 |     type: 'default',
36 |     position,
37 |     data: {
38 |         id,
39 |         title: `Test Card ${id}`,
40 |         content: `Test Content ${id}`,
41 |         tags: [],
42 |     },
43 | });
44 | 
45 | // 테스트 엣지 생성 유틸리티
46 | export const createTestEdge = (id: string, source: string, target: string): Edge => ({
47 |     id,
48 |     source,
49 |     target,
50 |     type: 'default',
51 |     markerEnd: MarkerType.ArrowClosed,
52 | });
53 | 
54 | // 이벤트 객체 생성 유틸리티
55 | export const createDragEvent = (data: any = {}): React.DragEvent => ({
56 |     preventDefault: vi.fn(),
57 |     stopPropagation: vi.fn(),
58 |     dataTransfer: {
59 |         dropEffect: 'none',
60 |         getData: vi.fn(() => {
61 |             try {
62 |                 return typeof data === 'string' ? data : JSON.stringify(data);
63 |             } catch {
64 |                 return '';
65 |             }
66 |         }),
67 |         setData: vi.fn(),
68 |     },
69 | } as unknown as React.DragEvent);
70 | 
71 | export const createMouseEvent = (options: Partial<MouseEvent> = {}): React.MouseEvent => ({
72 |     preventDefault: vi.fn(),
73 |     stopPropagation: vi.fn(),
74 |     ctrlKey: false,
75 |     metaKey: false,
76 |     ...options,
77 | } as unknown as React.MouseEvent);
78 | 
79 | // 모킹된 screen 객체
80 | export const screen = {
81 |     ...rtlScreen,
[TRUNCATED]
```

src/types/card.ts
```
1 | export interface User {
2 |   id: string;
3 |   name: string | null;
4 | }
5 | 
6 | export interface Card {
7 |   id: string;
8 |   title: string;
9 |   content: string | null;
10 |   createdAt: string;
11 |   updatedAt: string;
12 |   userId: string;
13 |   user?: User;
14 |   cardTags?: Array<{ tag: { id: string; name: string; } }>;
15 | }
16 | 
17 | export interface CreateCardInput {
18 |   title: string;
19 |   content?: string;
20 |   userId: string;
21 |   tags?: string[];
22 | }
23 | 
24 | export interface UpdateCardInput {
25 |   title?: string;
26 |   content?: string;
27 | } 
```

src/types/flow.ts
```
1 | /**
2 |  * 파일명: src/types/flow.ts
3 |  * 목적: ReactFlow 관련 타입 정의
4 |  * 역할: 애플리케이션에서 사용되는 ReactFlow 관련 타입들을 정의
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2023-10-27 : RefObject와 Edge 타입 관련 오류 수정
7 |  * 수정일: 2023-10-27 : ESLint 오류 수정 (import 순서, 미사용 변수 제거, any 타입 제거)
8 |  */
9 | 
10 | import React from 'react';
11 | 
12 | import { Edge as ReactFlowEdge } from '@xyflow/react';
13 | 
14 | export interface NodeData {
15 |   id: string;
16 |   title: string;
17 |   content: string;
18 |   type?: string;
19 |   width?: number;
20 |   height?: number;
21 |   color?: string;
22 |   tags?: string[];
23 |   position?: {
24 |     x: number;
25 |     y: number;
26 |   };
27 |   // 추가 속성들
28 |   [key: string]: unknown;
29 | }
30 | 
31 | /**
32 |  * SafeRefObject: HTMLElement에 대한 RefObject 타입 확장
33 |  * - null 허용하지 않는 RefObject<HTMLElement> 타입을 안전하게 사용하기 위한 타입
34 |  */
35 | export type SafeRefObject<T extends HTMLElement> = React.RefObject<T>;
36 | 
37 | /**
38 |  * Edge: ReactFlow Edge 타입 확장
39 |  * - ReactFlow의 Edge 타입을 확장하여 애플리케이션에서 필요한 속성 추가
40 |  */
41 | export type Edge = ReactFlowEdge;
42 | 
43 | /**
44 |  * EdgeChangeHandler: Edge 변경 핸들러 타입
45 |  * - Edge 배열을 변경하는 함수의 타입 정의
46 |  */
47 | export type EdgeChangeHandler = (edges: Edge[]) => void; 
```

src/types/global.d.ts
```
1 | /**
2 |  * 파일명: global.d.ts
3 |  * 목적: 전역 타입 선언
4 |  * 역할: 전역 변수 및 확장 타입을 선언
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2023-10-27 : any 타입을 unknown으로 변경하여 ESLint 오류 수정
7 |  */
8 | 
9 | import { SupabaseClient } from '@supabase/supabase-js';
10 | 
11 | import { Database } from './supabase';
12 | 
13 | declare global {
14 |   interface Window {
15 |     /**
16 |      * 전역 Supabase 싱글톤 인스턴스
17 |      */
18 |     __SUPABASE_SINGLETON_CLIENT?: SupabaseClient<Database>;
19 |     
20 |     /**
21 |      * Supabase 경고 비활성화 플래그
22 |      */
23 |     __SUPABASE_DISABLE_WARNING?: boolean;
24 |   }
25 |   
26 |   /**
27 |    * 콘솔 메서드 오버라이드를 위한 타입 선언
28 |    */
29 |   interface Console {
30 |     warn: (...data: unknown[]) => void;
31 |     originalWarn?: (...data: unknown[]) => void;
32 |   }
33 | } 
```

src/types/supabase.ts
```
1 | /**
2 |  * 파일명: src/types/supabase.ts
3 |  * 목적: Supabase 데이터베이스 타입 정의
4 |  * 역할: Supabase 데이터베이스 스키마 타입을 정의하여 타입 안정성 제공
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2023-10-27 : 빈 객체 타입({})을 명시적인 타입으로 변경
7 |  */
8 | 
9 | export type Json =
10 |   | string
11 |   | number
12 |   | boolean
13 |   | null
14 |   | { [key: string]: Json | undefined }
15 |   | Json[]
16 | 
17 | // Supabase 데이터베이스의 타입 정의
18 | export interface Database {
19 |   public: {
20 |     Tables: {
21 |       users: {
22 |         Row: {
23 |           id: string
24 |           email: string
25 |           name: string | null
26 |           created_at: string
27 |           updated_at: string
28 |         }
29 |         Insert: {
30 |           id?: string
31 |           email: string
32 |           name?: string | null
33 |           created_at?: string
34 |           updated_at?: string
35 |         }
36 |         Update: {
37 |           id?: string
38 |           email?: string
39 |           name?: string | null
40 |           updated_at?: string
41 |         }
42 |       }
43 |       cards: {
44 |         Row: {
45 |           id: string
46 |           title: string
47 |           content: string | null
48 |           user_id: string
49 |           created_at: string
50 |           updated_at: string
51 |         }
52 |         Insert: {
53 |           id?: string
54 |           title: string
55 |           content?: string | null
56 |           user_id: string
57 |           created_at?: string
58 |           updated_at?: string
59 |         }
60 |         Update: {
61 |           id?: string
62 |           title?: string
63 |           content?: string | null
64 |           user_id?: string
65 |           updated_at?: string
66 |         }
67 |       }
68 |       tags: {
69 |         Row: {
70 |           id: string
71 |           name: string
72 |           created_at: string
73 |           updated_at: string
74 |         }
75 |         Insert: {
76 |           id?: string
77 |           name: string
78 |           created_at?: string
79 |           updated_at?: string
80 |         }
81 |         Update: {
82 |           id?: string
83 |           name?: string
84 |           updated_at?: string
85 |         }
86 |       }
87 |       card_tags: {
88 |         Row: {
89 |           id: string
90 |           card_id: string
91 |           tag_id: string
92 |           created_at: string
93 |         }
94 |         Insert: {
95 |           id?: string
96 |           card_id: string
97 |           tag_id: string
98 |           created_at?: string
99 |         }
100 |         Update: {
101 |           id?: string
102 |           card_id?: string
103 |           tag_id?: string
104 |         }
105 |       }
106 |       board_settings: {
107 |         Row: {
108 |           id: string
109 |           user_id: string
[TRUNCATED]
```

src/types/vitest.d.ts
```
1 | /**
2 |  * 파일명: src/types/vitest.d.ts
3 |  * 목적: Vitest와 Testing Library 타입 확장 선언
4 |  * 역할: 전역 타입 확장 및 테스트 관련 타입 정의
5 |  * 작성일: 2025-05-15
6 |  * 수정일: 2023-10-27 : ESLint 오류 수정 (미사용 import 제거, 빈 인터페이스 수정)
7 |  */
8 | 
9 | import type { TestingLibraryMatchers } from '@testing-library/jest-dom/matchers';
10 | 
11 | declare global {
12 |   namespace Vi {
13 |     // jest.Matchers 타입을 상속받아 JestAssertion 확장
14 |     interface JestAssertion<T = unknown> extends jest.Matchers<void, T> {
15 |       // 추가 확장 기능이 필요한 경우 여기에 구현
16 |       toBeSomething(): void;
17 |     }
18 |   }
19 | 
20 |   // @testing-library/jest-dom 확장
21 |   interface Matchers<R = void> extends TestingLibraryMatchers<typeof expect.stringContaining, R> {
22 |     // 추가 확장 기능이 필요한 경우 여기에 구현
23 |     toBeSomethingElse(): R;
24 |   }
25 | } 
```

src/app/cards/page.test.tsx
```
1 | /**
2 |  * @vitest-environment jsdom
3 |  */
4 | 
5 | import React from 'react';
6 | 
7 | import { render, screen } from '@testing-library/react';
8 | import { describe, it, expect, vi } from 'vitest';
9 | import '@testing-library/jest-dom/vitest';
10 | 
11 | import CardsPage from './page';
12 | 
13 | // Next.js의 router 훅 모킹
14 | vi.mock('next/navigation', () => ({
15 |   useRouter: vi.fn(() => ({
16 |     push: vi.fn(),
17 |     replace: vi.fn(),
18 |     prefetch: vi.fn(),
19 |     pathname: '/cards',
20 |   })),
21 |   useSearchParams: vi.fn(() => ({
22 |     get: vi.fn(() => null),
23 |     has: vi.fn(() => false),
24 |     forEach: vi.fn(),
25 |   })),
26 | }));
27 | 
28 | // TagFilter 컴포넌트 모킹
29 | vi.mock('@/components/cards/TagFilter', () => ({
30 |   TagFilter: vi.fn(() => <div data-testid="tag-filter">태그 필터</div>)
31 | }));
32 | 
33 | // React.Suspense 모킹
34 | vi.mock('react', async () => {
35 |   const originalReact = await vi.importActual('react');
36 |   return {
37 |     ...originalReact,
38 |     Suspense: ({ children, fallback }: { children: React.ReactNode; fallback: React.ReactNode }) => {
39 |       return (
40 |         <>
41 |           <div data-testid="suspense-fallback">{fallback}</div>
42 |           <div data-testid="suspense-children">{children}</div>
43 |         </>
44 |       );
45 |     },
46 |   };
47 | });
48 | 
49 | // 테스트용 CardListSkeleton (page 모듈에서 가져오지 않고 테스트에서 직접 정의)
50 | const CardListSkeleton = () => (
51 |   <div data-testid="skeleton-grid" className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
52 |     {Array(6).fill(0).map((_, index) => (
53 |       <div key={index} className="border rounded-md p-4 space-y-4">
54 |         <div data-testid="skeleton" className="h-6 w-3/4" />
55 |         <div data-testid="skeleton" className="h-24" />
56 |         <div className="flex justify-between">
57 |           <div data-testid="skeleton" className="h-4 w-1/4" />
58 |           <div data-testid="skeleton" className="h-8 w-1/4" />
59 |         </div>
60 |       </div>
61 |     ))}
62 |   </div>
63 | );
64 | 
65 | // Suspense 내부 컴포넌트 모킹
66 | vi.mock('@/components/cards/CardList', () => {
67 |   return {
68 |     default: vi.fn(() => <div data-testid="card-list">카드 목록 컴포넌트</div>)
69 |   };
70 | });
71 | 
72 | // CreateCardButton 모킹을 CreateCardModal로 변경
73 | vi.mock('@/components/cards/CreateCardModal', () => {
74 |   return {
75 |     default: vi.fn(() => <button data-testid="create-card-modal-button">새 카드 만들기</button>)
[TRUNCATED]
```

src/app/cards/page.tsx
```
1 | /**
2 |  * 파일명: src/app/cards/page.tsx
3 |  * 목적: 카드 목록을 표시하고 필터링 기능 제공
4 |  * 역할: 카드 목록 페이지의 레이아웃과 컴포넌트 구성
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-04-08
7 |  * 수정일: 2025-05-30 : TagFilter를 Suspense로 감싸 useSearchParams 오류 해결
8 |  */
9 | 
10 | import { Suspense } from 'react';
11 | 
12 | import { Metadata } from "next";
13 | 
14 | import CardList from "@/components/cards/CardList";
15 | import CreateCardModal from "@/components/cards/CreateCardModal";
16 | import { TagFilter } from "@/components/cards/TagFilter";
17 | import { Skeleton } from '@/components/ui/skeleton';
18 | 
19 | 
20 | 
21 | export const metadata: Metadata = {
22 |   title: "카드 목록 | Backyard",
23 |   description: "백야드 카드 목록 페이지입니다.",
24 | };
25 | 
26 | // 카드 목록 로딩 스켈레톤
27 | function CardListSkeleton() {
28 |   return (
29 |     <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
30 |       {Array(6).fill(0).map((_, index) => (
31 |         <div key={index} className="border rounded-md p-4 space-y-4">
32 |           <Skeleton className="h-6 w-3/4" />
33 |           <Skeleton className="h-24" />
34 |           <div className="flex justify-between">
35 |             <Skeleton className="h-4 w-1/4" />
36 |             <Skeleton className="h-8 w-1/4" />
37 |           </div>
38 |         </div>
39 |       ))}
40 |     </div>
41 |   );
42 | }
43 | 
44 | // 태그 필터 로딩 스켈레톤
45 | function TagFilterSkeleton() {
46 |   return (
47 |     <div className="space-y-2 p-3 border rounded-md">
48 |       <Skeleton className="h-6 w-1/2" />
49 |       <Skeleton className="h-4 w-full" />
50 |       <Skeleton className="h-4 w-full" />
51 |       <Skeleton className="h-4 w-3/4" />
52 |     </div>
53 |   );
54 | }
55 | 
56 | export default function CardsPage() {
57 |   return (
58 |     <div className="container mx-auto py-8">
59 |       {/* 페이지 헤더 */}
60 |       <div className="mb-6">
61 |         <div className="flex justify-between items-center mb-2">
62 |           <div>
63 |             {/* <div className="flex items-center text-sm text-muted-foreground mb-1">
64 |               <Link href="/" className="hover:underline">홈</Link>
65 |               <ChevronRight className="h-4 w-4 mx-1" />
66 |               <span>카드 목록</span>
67 |             </div> */}
68 |             <h1 className="text-3xl font-bold">카드 목록</h1>
69 |           </div>
70 |           <CreateCardModal />
71 |         </div>
72 |         <p className="text-muted-foreground">
[TRUNCATED]
```

src/app/ideamap/page.test.tsx
```
1 | /**
2 |  * 파일명: page.test.tsx
3 |  * 목적: 아이디어맵 페이지 컴포넌트 테스트
4 |  * 역할: IdeaMap 컴포넌트를 사용하는 페이지 컴포넌트 테스트
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-04-15
7 |  * 수정일: 2025-04-25 : 사용하지 않는 import 및 변수 제거
8 |  */
9 | 
10 | import { render, screen } from '@testing-library/react';
11 | import { Node, Edge, NodeChange } from '@xyflow/react';
12 | import { describe, test, expect, vi, beforeEach } from 'vitest';
13 | 
14 | import IdeaMapPage from './page';
15 | import '@testing-library/jest-dom/vitest';
16 | import { autoLayoutNodes } from './page';
17 | 
18 | // LocalStorage 모킹
19 | const localStorageMock = (() => {
20 |   let store: Record<string, string> = {};
21 |   return {
22 |     getItem: vi.fn((key: string) => store[key] || null),
23 |     setItem: vi.fn((key: string, value: string) => {
24 |       store[key] = value.toString();
25 |     }),
26 |     clear: vi.fn(() => {
27 |       store = {};
28 |     }),
29 |   };
30 | })();
31 | 
32 | Object.defineProperty(window, 'localStorage', {
33 |   value: localStorageMock,
34 | });
35 | 
36 | // ResizeObserver 모킹 (ReactFlow에서 필요)
37 | class ResizeObserverMock {
38 |   observe = vi.fn();
39 |   unobserve = vi.fn();
40 |   disconnect = vi.fn();
41 | }
42 | 
43 | global.ResizeObserver = ResizeObserverMock;
44 | 
45 | // React Flow의 applyNodeChanges 함수 결과를 모킹하기 위한 변수
46 | let mockAppliedNodes: Node[] = [];
47 | 
48 | // ReactFlow 전체 모킹 - 테스트에서는 실제 렌더링 없이 모킹된 구성요소만 사용
49 | const nodesMock: Node[] = [];
50 | const edgesMock: Edge[] = [];
51 | const setNodesMock = vi.fn();
52 | const setEdgesMock = vi.fn();
53 | const onNodesChangeMock = vi.fn();
54 | const onEdgesChangeMock = vi.fn();
55 | 
56 | // ReactFlow의 ReactFlowProvider와 useReactFlow hook 모킹
57 | vi.mock('@xyflow/react', () => {
58 |   // ReactFlow 컴포넌트 모킹
59 |   const ReactFlowMock = ({ children, onNodesChange }: { children?: React.ReactNode, onNodesChange?: (changes: NodeChange[]) => void }) => (
60 |     <div
61 |       data-testid="react-flow-mock"
62 |       onClick={() => {
63 |         // 노드 위치 변경 시뮬레이션
64 |         if (onNodesChange) {
65 |           onNodesChange([{
66 |             type: 'position',
67 |             id: '1',
68 |             position: { x: 200, y: 200 },
69 |           } as NodeChange]);
70 |         }
71 |       }}
72 |     >
73 |       {children}
74 |     </div>
75 |   );
76 | 
77 |   return {
78 |     // default export 추가 (중요!)
79 |     default: ReactFlowMock,
80 |     // 필요한 다른 export들
81 |     ReactFlow: ReactFlowMock,
82 |     ReactFlowProvider: ({ children }: { children: React.ReactNode }) => (
83 |       <div data-testid="react-flow-provider">{children}</div>
84 |     ),
[TRUNCATED]
```

src/app/ideamap/page.tsx
```
1 | /**
2 |  * 파일명: page.tsx
3 |  * 목적: 아이디어맵 페이지 컴포넌트
4 |  * 역할: 아이디어맵 기능의 페이지 레벨 컴포넌트, 리팩토링된 IdeaMap 컴포넌트 사용
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-04-15
7 |  * 수정일: 2025-04-27 : any 타입을 Node 타입으로 변경
8 |  */
9 | 
10 | 'use client';
11 | 
12 | import { Node, ReactFlowProvider } from '@xyflow/react';
13 | 
14 | import IdeaMap from '@/components/ideamap/components/IdeaMap';
15 | import { useAppStore } from '@/store/useAppStore';
16 | 
17 | // 기존 코드 보존을 위한 주석 처리된 함수들 (테스트에서 참조할 수 있음)
18 | export const autoLayoutNodes = (nodes: Node[]) => {
19 |   return nodes.map((node: Node, index: number) => ({
20 |     ...node,
21 |     position: {
22 |       x: (index % 3) * 300 + 50,
23 |       y: Math.floor(index / 3) * 200 + 50
24 |     }
25 |   }));
26 | };
27 | 
28 | // 아이디어맵 페이지 컴포넌트
29 | export default function IdeaMapPage() {
30 |   const { selectCard } = useAppStore();
31 | 
32 |   return (
33 |     <div className="w-full h-full relative">
34 |       <ReactFlowProvider>
35 |         <IdeaMap
36 |           onSelectCard={selectCard}
37 |           className="bg-background"
38 |           showControls={true}
39 |         />
40 |       </ReactFlowProvider>
41 |     </div>
42 |   );
43 | } 
```

src/app/login/actions.ts
```
1 | /**
2 |  * 파일명: actions.ts
3 |  * 목적: 로그인 및 회원가입 서버 액션 제공
4 |  * 역할: 사용자 인증 처리
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-05 : OAuth 리다이렉션 URL 환경변수 수정
7 |  */
8 | 
9 | 'use server'
10 | 
11 | import { redirect } from 'next/navigation'
12 | 
13 | import { createClient } from '@/lib/supabase/server'
14 | 
15 | export async function login(formData: FormData) {
16 |   const email = formData.get('email') as string
17 |   const password = formData.get('password') as string
18 | 
19 |   const supabase = await createClient()
20 | 
21 |   const { error } = await supabase.auth.signInWithPassword({
22 |     email,
23 |     password,
24 |   })
25 | 
26 |   if (error) {
27 |     console.error('로그인 오류:', error)
28 |     return redirect(`/login?error=${encodeURIComponent(error.message)}`)
29 |   }
30 | 
31 |   return redirect('/')
32 | }
33 | 
34 | export async function signup(formData: FormData) {
35 |   const email = formData.get('email') as string
36 |   const password = formData.get('password') as string
37 | 
38 |   const supabase = await createClient()
39 | 
40 |   const { error } = await supabase.auth.signUp({
41 |     email,
42 |     password,
43 |     options: {
44 |       emailRedirectTo: `${process.env.NEXT_PUBLIC_OAUTH_REDIRECT_URL || 'http://localhost:3000'}/auth/callback`,
45 |     },
46 |   })
47 | 
48 |   if (error) {
49 |     console.error('회원가입 오류:', error)
50 |     return redirect(`/login?error=${encodeURIComponent(error.message)}`)
51 |   }
52 | 
53 |   // 회원가입 성공 메시지로 리다이렉션
54 |   return redirect('/login?message=확인 이메일을 발송했습니다. 이메일을 확인해주세요.')
55 | }
56 | 
57 | export async function signInWithGoogle() {
58 |   // Supabase 클라이언트 생성
59 |   const supabase = await createClient()
60 |   
61 |   // 현재 앱 도메인 (NEXT_PUBLIC_OAUTH_REDIRECT_URL 사용)
62 |   const origin = process.env.NEXT_PUBLIC_OAUTH_REDIRECT_URL || 'http://localhost:3000'
63 |   
64 |   // 콜백 URL 설정
65 |   const redirectUrl = `${origin}/auth/callback`
66 |   
67 |   console.log('[GoogleSignIn] Using redirect URL:', redirectUrl)
68 |   
69 |   // Google OAuth 로그인 프로세스 시작
70 |   const { data, error } = await supabase.auth.signInWithOAuth({
71 |     provider: 'google',
72 |     options: {
73 |       redirectTo: redirectUrl,
74 |       queryParams: {
75 |         access_type: 'offline',
76 |         prompt: 'consent',
77 |       },
78 |     },
79 |   })
80 | 
81 |   if (error) {
82 |     // 오류 발생 시 로그인 페이지로 리다이렉트
83 |     return redirect(`/login?error=${encodeURIComponent(error.message)}`)
84 |   }
85 | 
86 |   // 구글 OAuth URL로 리다이렉션
87 |   if (data?.url) {
[TRUNCATED]
```

src/app/login/layout.tsx
```
1 | /**
2 |  * 파일명: src/app/login/layout.tsx
3 |  * 목적: 로그인 페이지 레이아웃
4 |  * 역할: PublicOnlyLayout을 적용하여 이미 인증된 사용자 리디렉션
5 |  * 작성일: 2024-05-08
6 |  */
7 | 
8 | import { PublicOnlyLayout } from '@/components/layout/PublicOnlyLayout';
9 | 
10 | export default function LoginLayout({ children }: { children: React.ReactNode }) {
11 |     return <PublicOnlyLayout>{children}</PublicOnlyLayout>;
12 | } 
```

src/app/login/page.test.tsx
```
1 | /**
2 |  * 파일명: src/app/login/page.test.tsx
3 |  * 목적: 로그인 페이지 테스트
4 |  * 역할: 로그인 페이지 렌더링 및 기능 검증
5 |  * 작성일: 2025-02-15
6 |  * 수정일: 2025-03-27
7 |  * 수정일: 2024-05-16 : Triple-slash 참조 제거 및 import 문으로 변경
8 |  * 수정일: 2025-04-27 : 사용되지 않는 import 제거
9 |  */
10 | 
11 | import React from 'react';
12 | 
13 | import { render, screen } from '@testing-library/react';
14 | import { describe, it, expect, vi, beforeEach } from 'vitest';
15 | import '@testing-library/jest-dom/vitest';
16 | 
17 | import LoginPage from './page';
18 | 
19 | // 서버 액션 모킹
20 | const mockLogin = vi.fn();
21 | const mockSignup = vi.fn();
22 | const mockSignInWithGoogle = vi.fn();
23 | 
24 | vi.mock('./actions', () => ({
25 |   login: vi.fn(() => mockLogin),
26 |   signup: vi.fn(() => mockSignup),
27 |   signInWithGoogle: vi.fn(() => mockSignInWithGoogle)
28 | }));
29 | 
30 | // searchParams 모킹
31 | const mockSearchParams = new Map();
32 | 
33 | vi.mock('next/navigation', () => ({
34 |   useSearchParams: vi.fn(() => ({
35 |     get: (key: string) => mockSearchParams.get(key)
36 |   }))
37 | }));
38 | 
39 | describe('LoginPage', () => {
40 |   beforeEach(() => {
41 |     vi.clearAllMocks();
42 |     mockSearchParams.clear();
43 |   });
44 | 
45 |   it('로그인 페이지가 올바르게 렌더링되어야 함', () => {
46 |     render(<LoginPage />);
47 | 
48 |     // 페이지 제목이 존재하는지 확인
49 |     expect(screen.getByRole('heading', { name: '로그인' })).toBeInTheDocument();
50 | 
51 |     // 폼 요소들이 존재하는지 확인
52 |     expect(screen.getByLabelText('이메일')).toBeInTheDocument();
53 |     expect(screen.getByLabelText('비밀번호')).toBeInTheDocument();
54 | 
55 |     // 버튼들이 존재하는지 확인
56 |     expect(screen.getByRole('button', { name: '로그인' })).toBeInTheDocument();
57 |     expect(screen.getByRole('button', { name: '회원가입' })).toBeInTheDocument();
58 |     expect(screen.getByRole('button', { name: /Google로 계속하기/ })).toBeInTheDocument();
59 |   });
60 | 
61 |   it('오류 메시지가 URL 파라미터로부터 표시되어야 함', () => {
62 |     // 오류 메시지 파라미터 설정
63 |     mockSearchParams.set('error', '로그인에 실패했습니다.');
64 | 
65 |     render(<LoginPage />);
66 | 
67 |     // 오류 메시지가 화면에 표시되는지 확인
68 |     expect(screen.getByText('로그인에 실패했습니다.')).toBeInTheDocument();
69 |   });
70 | 
71 |   it('성공 메시지가 URL 파라미터로부터 표시되어야 함', () => {
72 |     // 성공 메시지 파라미터 설정
73 |     mockSearchParams.set('message', '확인 이메일을 발송했습니다.');
74 | 
75 |     render(<LoginPage />);
76 | 
77 |     // 성공 메시지가 화면에 표시되는지 확인
78 |     expect(screen.getByText('확인 이메일을 발송했습니다.')).toBeInTheDocument();
79 |   });
80 | 
81 |   it('URL 인코딩된 메시지가 올바르게 디코딩되어야 함', () => {
82 |     // 인코딩된 메시지 설정
[TRUNCATED]
```

src/app/login/page.tsx
```
1 | /**
2 |  * 파일명: src/app/login/page.tsx
3 |  * 목적: 로그인 페이지 제공
4 |  * 역할: 사용자 로그인 UI 렌더링
5 |  * 작성일: 2025-03-08
6 |  * 수정일: 2025-03-27
7 |  * 수정일: 2024-05-29 : 이미지 표시 방식 변경 (object-cover)
8 |  * 수정일: 2024-05-30 : 이미지 캐싱 및 애니메이션 효과 추가 (지연 없는 동시 로딩)
9 |  * 수정일: 2025-05-30 : LoginForm을 Suspense로 감싸서 useSearchParams 오류 해결
10 |  */
11 | 
12 | 'use client';
13 | 
14 | import React, { useEffect, useState, Suspense } from 'react';
15 | 
16 | import Image from 'next/image';
17 | 
18 | import LoginForm from '@/components/login/loginForm';
19 | import { Skeleton } from '@/components/ui/skeleton';
20 | 
21 | // 배경 이미지 배열 (v0 디자인에서 가져온 이미지)
22 | const backgroundImages = [
23 |   '/images/blockchain-cubes.png',
24 |   '/images/fiber-optic-lights.png',
25 |   '/images/lightbulb-blue.png',
26 |   '/images/lightbulb-hands.png',
27 |   '/images/lightbulb-sunset.png',
28 |   '/images/network-visualization.png',
29 | ];
30 | 
31 | /**
32 |  * getCachedImagePath: 캐시된 이미지 경로 반환 또는 새 이미지 캐싱
33 |  * @returns {string} 이미지 경로
34 |  */
35 | const getCachedImagePath = () => {
36 |   // 클라이언트 사이드에서만 실행
37 |   if (typeof window === 'undefined') return null;
38 | 
39 |   // 캐시에서 이미지 경로 가져오기
40 |   const cachedImage = localStorage.getItem('loginBackgroundImage');
41 | 
42 |   if (cachedImage && backgroundImages.includes(cachedImage)) {
43 |     return cachedImage;
44 |   }
45 | 
46 |   // 새 랜덤 이미지 선택 및 캐싱
47 |   const randomIndex = Math.floor(Math.random() * backgroundImages.length);
48 |   const newImagePath = backgroundImages[randomIndex];
49 |   localStorage.setItem('loginBackgroundImage', newImagePath);
50 |   return newImagePath;
51 | };
52 | 
53 | // 로그인 폼 로딩 상태를 위한 스켈레톤 컴포넌트
54 | function LoginFormSkeleton() {
55 |   return (
56 |     <div className="w-full max-w-md p-6 md:p-12 space-y-6">
57 |       <div className="mb-4 text-center">
58 |         <Skeleton className="h-8 w-40 mx-auto mb-2" />
59 |         <Skeleton className="h-4 w-32 mx-auto" />
60 |       </div>
61 |       <div className="border rounded-lg p-6 space-y-4">
62 |         <Skeleton className="h-8 w-1/2 mb-6" />
63 |         <div className="space-y-2">
64 |           <Skeleton className="h-4 w-16" />
65 |           <Skeleton className="h-10 w-full" />
66 |         </div>
67 |         <div className="space-y-2">
68 |           <Skeleton className="h-4 w-16" />
69 |           <Skeleton className="h-10 w-full" />
70 |         </div>
[TRUNCATED]
```

src/app/tags/page.test.tsx
```
1 | /**
2 |  * 파일명: src/app/tags/page.test.tsx
3 |  * 목적: 태그 관리 페이지 테스트
4 |  * 역할: 태그 페이지 렌더링 및 기능 검증
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-03-27
7 |  * 수정일: 2024-05-16 : Triple-slash 참조 제거 및 import 문으로 변경
8 |  */
9 | 
10 | import React from 'react';
11 | 
12 | import { render, screen, cleanup } from '@testing-library/react';
13 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
14 | 
15 | import TagsPage from './page';
16 | import '@testing-library/jest-dom/vitest';
17 | 
18 | // vi.hoisted를 사용하여 모킹 객체 생성
19 | const mocks = vi.hoisted(() => ({
20 |   findMany: vi.fn()
21 | }));
22 | 
23 | // prisma 모킹
24 | vi.mock('@/lib/prisma', () => ({
25 |   default: {
26 |     tag: {
27 |       findMany: mocks.findMany
28 |     }
29 |   }
30 | }));
31 | 
32 | // formatDate 모킹
33 | vi.mock('@/lib/utils', () => ({
34 |   // eslint-disable-next-line @typescript-eslint/no-unused-vars
35 |   formatDate: vi.fn((_: string | Date) => '2023년 1월 1일'),
36 |   cn: vi.fn((...args: any[]) => args.join(' '))
37 | }));
38 | 
39 | // 컴포넌트 모킹 - 올바른 경로로 수정
40 | vi.mock('@/components/tags/TagForm', () => ({
41 |   default: () => <div data-testid="tag-form">태그 추가 폼</div>
42 | }));
43 | 
44 | vi.mock('@/components/tags/TagList', () => ({
45 |   default: ({ initialTags }: { initialTags: any[] }) => (
46 |     <div data-testid="tag-list">
47 |       태그 수: {initialTags.length}
48 |     </div>
49 |   )
50 | }));
51 | 
52 | // Card 모킹
53 | vi.mock('@/components/ui/card', () => ({
54 |   Card: ({ children }: { children: React.ReactNode }) => <div data-slot="card" className="bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm ">{children}</div>,
55 |   CardHeader: ({ children }: { children: React.ReactNode }) => <div data-slot="card-header" className="@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6 ">{children}</div>,
56 |   CardTitle: ({ children }: { children: React.ReactNode }) => <div data-slot="card-title" className="leading-none font-semibold ">{children}</div>,
57 |   CardDescription: ({ children }: { children: React.ReactNode }) => <div data-slot="card-description" className="text-sm text-muted-foreground ">{children}</div>,
58 |   CardContent: ({ children }: { children: React.ReactNode }) => <div data-slot="card-content" className="px-6 ">{children}</div>,
[TRUNCATED]
```

src/app/tags/page.tsx
```
1 | import { Tag } from "@prisma/client";
2 | import { Metadata } from "next";
3 | 
4 | import TagForm from "@/components/tags/TagForm";
5 | import TagList from "@/components/tags/TagList";
6 | import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
7 | import prisma from "@/lib/prisma";
8 | import { formatDate } from "@/lib/utils";
9 | 
10 | export const metadata: Metadata = {
11 |   title: "태그 관리 | Backyard",
12 |   description: "태그를 생성하고 관리하는 페이지입니다.",
13 | };
14 | 
15 | type TagWithCount = Tag & {
16 |   _count: {
17 |     cardTags: number;
18 |   };
19 | };
20 | 
21 | export default async function TagsPage() {
22 |   let tags: TagWithCount[] = [];
23 |   
24 |   try {
25 |     tags = await prisma.tag.findMany({
26 |       orderBy: {
27 |         name: 'asc'
28 |       },
29 |       include: {
30 |         _count: {
31 |           select: { cardTags: true }
32 |         }
33 |       }
34 |     });
35 |   } catch (error) {
36 |     console.error("태그 조회 오류:", error);
37 |     // 오류 발생 시 빈 배열 사용
38 |   }
39 | 
40 |   const formattedTags = tags.map(tag => ({
41 |     id: tag.id,
42 |     name: tag.name,
43 |     count: tag._count.cardTags,
44 |     createdAt: formatDate(tag.createdAt)
45 |   }));
46 | 
47 |   return (
48 |     <div className="container mx-auto py-8">
49 |       <h1 className="text-3xl font-bold mb-6">태그 관리</h1>
50 |       
51 |       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
52 |         <div className="md:col-span-1">
53 |           <Card>
54 |             <CardHeader>
55 |               <CardTitle>새 태그 추가</CardTitle>
56 |             </CardHeader>
57 |             <CardContent>
58 |               <TagForm />
59 |             </CardContent>
60 |           </Card>
61 |         </div>
62 |         
63 |         <div className="md:col-span-2">
64 |           <Card>
65 |             <CardHeader>
66 |               <CardTitle>태그 목록</CardTitle>
67 |             </CardHeader>
68 |             <CardContent>
69 |               <TagList initialTags={formattedTags} />
70 |             </CardContent>
71 |           </Card>
72 |         </div>
73 |       </div>
74 |     </div>
75 |   );
76 | } 
```

src/app/test-db/page.test.tsx
```
1 | /**
2 |  * 파일명: page.test.tsx
3 |  * 목적: 데이터베이스 연결 테스트 페이지 컴포넌트 테스트
4 |  * 역할: TestDatabasePage 컴포넌트의 다양한 상태 및 동작 검증
5 |  * 작성일: 2025-04-01
6 |  */
7 | 
8 | import { render, screen } from '@testing-library/react';
9 | import { describe, it, expect, vi, beforeEach } from 'vitest';
10 | 
11 | import TestDatabasePage from './page';
12 | 
13 | // Prisma 클라이언트 모킹
14 | vi.mock('@/lib/prisma', () => ({
15 |     default: {
16 |         tag: {
17 |             findMany: vi.fn(),
18 |         },
19 |         $disconnect: vi.fn(),
20 |     },
21 | }));
22 | 
23 | // console.error 모킹
24 | vi.spyOn(console, 'error').mockImplementation(() => { });
25 | 
26 | describe('TestDatabasePage 컴포넌트', () => {
27 |     let mockPrisma: any;
28 | 
29 |     beforeEach(async () => {
30 |         vi.clearAllMocks();
31 |         // 각 테스트 전에 모킹된 Prisma 인스턴스 가져오기
32 |         mockPrisma = (await import('@/lib/prisma')).default;
33 |     });
34 | 
35 |     it('태그 목록이 있을 때 올바르게 렌더링해야 함', async () => {
36 |         // 태그 데이터 모킹
37 |         const mockTags = [
38 |             { id: 1, name: '리액트', _count: { cardTags: 5 } },
39 |             { id: 2, name: '타입스크립트', _count: { cardTags: 3 } },
40 |             { id: 3, name: '백엔드', _count: { cardTags: 2 } },
41 |         ];
42 | 
43 |         // Prisma 응답 모킹
44 |         (mockPrisma.tag.findMany as any).mockResolvedValueOnce(mockTags);
45 | 
46 |         // 컴포넌트 렌더링 (비동기 컴포넌트이므로 임시 변환 사용)
47 |         const Component = await TestDatabasePage();
48 |         render(Component);
49 | 
50 |         // 페이지 제목 확인
51 |         expect(screen.getByText('데이터베이스 연결 테스트')).toBeInTheDocument();
52 | 
53 |         // 각 태그가 올바르게 표시되는지 확인
54 |         expect(screen.getByText('리액트')).toBeInTheDocument();
55 |         expect(screen.getByText('타입스크립트')).toBeInTheDocument();
56 |         expect(screen.getByText('백엔드')).toBeInTheDocument();
57 | 
58 |         // 태그 개수가 올바르게 표시되는지 확인
59 |         expect(screen.getByText('연결된 카드: 5개')).toBeInTheDocument();
60 |         expect(screen.getByText('연결된 카드: 3개')).toBeInTheDocument();
61 |         expect(screen.getByText('연결된 카드: 2개')).toBeInTheDocument();
62 | 
63 |         // 성공 메시지 확인
64 |         expect(screen.getByText('이 페이지가 정상적으로 로드되었다면 Prisma와 Supabase 연결이 성공적으로 구성된 것입니다!')).toBeInTheDocument();
65 | 
66 |         // Prisma 호출 확인
67 |         expect(mockPrisma.tag.findMany).toHaveBeenCalledTimes(1);
68 |         expect(mockPrisma.tag.findMany).toHaveBeenCalledWith({
69 |             include: {
70 |                 _count: {
71 |                     select: {
72 |                         cardTags: true,
73 |                     },
74 |                 },
75 |             },
76 |         });
77 |     });
78 | 
79 |     it('태그가 없을 때 적절한 메시지를 표시해야 함', async () => {
80 |         // 빈 태그 목록 모킹
81 |         (mockPrisma.tag.findMany as any).mockResolvedValueOnce([]);
82 | 
83 |         // 컴포넌트 렌더링
84 |         const Component = await TestDatabasePage();
85 |         render(Component);
86 | 
[TRUNCATED]
```

src/app/test-db/page.tsx
```
1 | import React from 'react';
2 | 
3 | import type { Tag } from '@prisma/client';
4 | 
5 | import prisma from '@/lib/prisma';
6 | 
7 | // 태그와 연결된 카드 수를 포함하는 타입 정의
8 | type TagWithCount = Tag & {
9 |   _count: {
10 |     cardTags: number;
11 |   };
12 | };
13 | 
14 | export default async function TestDatabasePage() {
15 |   let tags: TagWithCount[] = [];
16 |   let error: string | null = null;
17 |   
18 |   try {
19 |     // Prisma를 사용하여 태그 목록을 가져옵니다
20 |     tags = await prisma.tag.findMany({
21 |       include: {
22 |         _count: {
23 |           select: {
24 |             cardTags: true,
25 |           },
26 |         },
27 |       },
28 |     });
29 |   } catch (e) {
30 |     console.error('데이터베이스 연결 오류:', e);
31 |     error = e instanceof Error ? e.message : '알 수 없는 오류가 발생했습니다.';
32 |   }
33 | 
34 |   return (
35 |     <div className="container mx-auto p-6">
36 |       <h1 className="text-3xl font-bold mb-6">데이터베이스 연결 테스트</h1>
37 |       
38 |       <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
39 |         <h2 className="text-2xl font-semibold mb-4">태그 목록</h2>
40 |         
41 |         {error ? (
42 |           <div className="p-4 mb-4 bg-red-50 dark:bg-red-900/20 rounded">
43 |             <p className="text-red-700 dark:text-red-400">
44 |               데이터베이스 연결 오류: {error}
45 |             </p>
46 |             <p className="mt-2 text-sm text-red-600 dark:text-red-300">
47 |               Vercel 환경 변수가 올바르게 설정되었는지 확인하세요.
48 |             </p>
49 |           </div>
50 |         ) : tags.length === 0 ? (
51 |           <p className="text-gray-500 dark:text-gray-400">등록된 태그가 없습니다.</p>
52 |         ) : (
53 |           <ul className="space-y-2">
54 |             {tags.map((tag) => (
55 |               <li 
56 |                 key={tag.id}
57 |                 className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded"
58 |               >
59 |                 <span className="font-medium">{tag.name}</span>
60 |                 <span className="text-sm text-gray-500 dark:text-gray-400">
61 |                   연결된 카드: {tag._count.cardTags}개
62 |                 </span>
63 |               </li>
64 |             ))}
65 |           </ul>
66 |         )}
67 |         
68 |         <div className="mt-6 p-4 bg-green-50 dark:bg-green-900/20 rounded">
69 |           <p className="text-green-700 dark:text-green-400">
70 |             {!error 
71 |               ? '이 페이지가 정상적으로 로드되었다면 Prisma와 Supabase 연결이 성공적으로 구성된 것입니다!' 
[TRUNCATED]
```

src/components/auth/AuthErrorDisplay.test.tsx
```
1 | /**
2 |  * 파일명: src/components/auth/AuthErrorDisplay.test.tsx
3 |  * 목적: AuthErrorDisplay 컴포넌트 테스트
4 |  * 역할: 인증 오류 정보 표시 컴포넌트의 기능 검증
5 |  * 작성일: 2024-09-28
6 |  */
7 | 
8 | import { render, screen } from '@testing-library/react';
9 | import { describe, expect, it, vi, beforeEach } from 'vitest';
10 | 
11 | import AuthErrorDisplay from './AuthErrorDisplay';
12 | 
13 | // 모킹 설정
14 | const mockGet = vi.fn();
15 | 
16 | vi.mock('next/navigation', () => ({
17 |     useSearchParams: () => ({
18 |         get: mockGet
19 |     })
20 | }));
21 | 
22 | describe('AuthErrorDisplay', () => {
23 |     beforeEach(() => {
24 |         vi.clearAllMocks();
25 |         vi.spyOn(console, 'error').mockImplementation(() => { });
26 |         mockGet.mockImplementation((param: string) => {
27 |             if (param === 'error') return 'default';
28 |             if (param === 'error_description') return '';
29 |             return null;
30 |         });
31 |     });
32 | 
33 |     it('기본 오류 메시지를 올바르게 표시해야 합니다', () => {
34 |         render(<AuthErrorDisplay />);
35 |         expect(screen.getByText('인증 과정에서 오류가 발생했습니다.')).toBeInTheDocument();
36 |     });
37 | 
38 |     it('특정 오류 유형에 대한 메시지를 올바르게 표시해야 합니다', () => {
39 |         mockGet.mockImplementation((param: string) => {
40 |             if (param === 'error') return 'invalid_callback';
41 |             if (param === 'error_description') return '';
42 |             return null;
43 |         });
44 | 
45 |         render(<AuthErrorDisplay />);
46 |         expect(screen.getByText('유효하지 않은 인증 콜백입니다.')).toBeInTheDocument();
47 |     });
48 | 
49 |     it('오류 설명이 있을 경우 함께 표시해야 합니다', () => {
50 |         mockGet.mockImplementation((param: string) => {
51 |             if (param === 'error') return 'verification_failed';
52 |             if (param === 'error_description') return '이메일 주소가 확인되지 않았습니다.';
53 |             return null;
54 |         });
55 | 
56 |         render(<AuthErrorDisplay />);
57 |         expect(screen.getByText('이메일 인증에 실패했습니다.')).toBeInTheDocument();
58 |         expect(screen.getByText('이메일 주소가 확인되지 않았습니다.')).toBeInTheDocument();
59 |     });
60 | 
61 |     it('알 수 없는 오류 유형에 대해 기본 메시지를 표시해야 합니다', () => {
62 |         mockGet.mockImplementation((param: string) => {
63 |             if (param === 'error') return 'unknown_error';
64 |             return null;
65 |         });
66 | 
67 |         render(<AuthErrorDisplay />);
68 |         expect(screen.getByText('인증 과정에서 오류가 발생했습니다.')).toBeInTheDocument();
69 |     });
70 | 
71 |     it('로그인 페이지로 돌아가기 링크가 올바르게 작동해야 합니다', async () => {
72 |         render(<AuthErrorDisplay />);
73 |         const loginLink = screen.getByRole('link', { name: '로그인 페이지로 돌아가기' });
74 |         expect(loginLink).toHaveAttribute('href', '/login');
75 |     });
76 | 
77 |     it('홈으로 돌아가기 링크가 올바르게 작동해야 합니다', async () => {
78 |         render(<AuthErrorDisplay />);
79 |         const homeLink = screen.getByRole('link', { name: '홈으로 돌아가기' });
[TRUNCATED]
```

src/components/auth/AuthErrorDisplay.tsx
```
1 | /**
2 |  * 파일명: src/components/auth/AuthErrorDisplay.tsx
3 |  * 목적: 인증 오류 정보 표시 클라이언트 컴포넌트
4 |  * 역할: URL 파라미터에서 오류 정보를 가져와 해당 오류 메시지를 표시
5 |  * 작성일: 2024-09-28
6 |  */
7 | 
8 | 'use client';
9 | 
10 | import { useEffect, useState } from 'react'
11 | import Link from 'next/link'
12 | import { useSearchParams } from 'next/navigation'
13 | 
14 | // 오류 메시지 매핑
15 | const ERROR_MESSAGES: Record<string, string> = {
16 |     invalid_callback: '유효하지 않은 인증 콜백입니다.',
17 |     verification_failed: '이메일 인증에 실패했습니다.',
18 |     exchange_error: '인증 토큰 교환 중 오류가 발생했습니다.',
19 |     no_code: '인증 코드가 없습니다.',
20 |     no_session: '세션을 생성할 수 없습니다.',
21 |     default: '인증 과정에서 오류가 발생했습니다.'
22 | }
23 | 
24 | export default function AuthErrorDisplay() {
25 |     const searchParams = useSearchParams()
26 |     const [error, setError] = useState<string>('default')
27 |     const [description, setDescription] = useState<string>('')
28 | 
29 |     useEffect(() => {
30 |         // URL 파라미터에서 오류 정보 추출
31 |         const errorParam = searchParams.get('error') || 'default'
32 |         const errorDescription = searchParams.get('error_description') || ''
33 | 
34 |         setError(errorParam)
35 |         setDescription(errorDescription)
36 | 
37 |         // 오류 로깅
38 |         console.error('인증 오류:', {
39 |             error: errorParam,
40 |             description: errorDescription
41 |         })
42 |     }, [searchParams])
43 | 
44 |     return (
45 |         <>
46 |             <p className="text-gray-700 mb-4">
47 |                 {ERROR_MESSAGES[error] || ERROR_MESSAGES.default}
48 |             </p>
49 | 
50 |             {description && (
51 |                 <p className="text-sm text-gray-500 mb-6 p-3 bg-gray-50 rounded">
52 |                     {description}
53 |                 </p>
54 |             )}
55 | 
56 |             <div className="flex flex-col space-y-3">
57 |                 <Link
58 |                     href="/login"
59 |                     className="w-full py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors"
60 |                 >
61 |                     로그인 페이지로 돌아가기
62 |                 </Link>
63 | 
64 |                 <Link
65 |                     href="/"
66 |                     className="w-full py-2 px-4 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded transition-colors"
67 |                 >
68 |                     홈으로 돌아가기
69 |                 </Link>
70 |             </div>
71 |         </>
72 |     )
73 | } 
```

src/components/auth/AuthForm.tsx
```
1 | 'use client';
2 | 
3 | import { useState } from 'react';
4 | 
5 | import { setCookie } from 'cookies-next';
6 | import { toast } from 'sonner';
7 | 
8 | import { Button } from '@/components/ui/button';
9 | import { Input } from '@/components/ui/input';
10 | import { Label } from '@/components/ui/label';
11 | import { signIn, signUp, signInWithGoogle } from '@/lib/auth';
12 | 
13 | type AuthMode = 'login' | 'register';
14 | 
15 | export default function AuthForm() {
16 |   const [mode, setMode] = useState<AuthMode>('login');
17 |   const [email, setEmail] = useState('');
18 |   const [password, setPassword] = useState('');
19 |   const [name, setName] = useState('');
20 |   const [isLoading, setIsLoading] = useState(false);
21 |   const [isGoogleLoading, setIsGoogleLoading] = useState(false);
22 | 
23 |   const toggleMode = () => {
24 |     setMode(mode === 'login' ? 'register' : 'login');
25 |     // 폼 초기화
26 |     setEmail('');
27 |     setPassword('');
28 |     setName('');
29 |   };
30 | 
31 |   const handleSubmit = async (e: React.FormEvent) => {
32 |     e.preventDefault();
33 |     setIsLoading(true);
34 | 
35 |     try {
36 |       if (mode === 'login') {
37 |         const { session } = await signIn(email, password);
38 | 
39 |         // 추가: 쿠키를 여기서도 직접 설정 (보완책)
40 |         if (session) {
41 |           // 현재 호스트 가져오기
42 |           const host = window.location.hostname;
43 |           const isLocalhost = host === 'localhost' || host === '127.0.0.1';
44 | 
45 |           // 도메인 설정 (로컬호스트가 아닌 경우에만)
46 |           let domain = undefined;
47 |           if (!isLocalhost) {
48 |             // 서브도메인 포함하기 위해 최상위 도메인만 설정
49 |             const hostParts = host.split('.');
50 |             if (hostParts.length > 1) {
51 |               // vercel.app 또는 yoursite.com 형태일 경우
52 |               domain = '.' + hostParts.slice(-2).join('.');
53 |             } else {
54 |               domain = host;
55 |             }
56 |           }
57 | 
58 |           // cookies-next 라이브러리 사용
59 |           setCookie('sb-access-token', session.access_token, {
60 |             maxAge: 60 * 60 * 24 * 7, // 7일
61 |             path: '/',
62 |             domain: domain,
63 |             secure: window.location.protocol === 'https:',
64 |             sameSite: 'lax'
65 |           });
66 | 
67 |           if (session.refresh_token) {
68 |             setCookie('sb-refresh-token', session.refresh_token, {
69 |               maxAge: 60 * 60 * 24 * 30, // 30일
70 |               path: '/',
71 |               domain: domain,
72 |               secure: window.location.protocol === 'https:',
73 |               sameSite: 'lax'
74 |             });
75 |           }
76 | 
77 |           console.log('AuthForm: 쿠키에 인증 정보 저장됨', {
78 |             호스트: host,
79 |             도메인설정: domain || '없음'
80 |           });
81 |         }
82 | 
83 |         toast.success('로그인 성공!');
84 |       } else {
85 |         await signUp(email, password, name);
[TRUNCATED]
```

src/components/auth/UserProfile.tsx
```
1 | 'use client';
2 | 
3 | import { useState, useEffect } from 'react';
4 | 
5 | import { useRouter } from 'next/navigation';
6 | 
7 | import { toast } from 'sonner';
8 | 
9 | import { Avatar, AvatarImage, AvatarFallback } from '@/components/ui/avatar';
10 | import { Button } from '@/components/ui/button';
11 | import {
12 |   DropdownMenu,
13 |   DropdownMenuTrigger,
14 |   DropdownMenuContent,
15 |   DropdownMenuItem,
16 |   DropdownMenuSeparator
17 | } from '@/components/ui/dropdown-menu';
18 | import { getCurrentUser, signOut } from '@/lib/auth';
19 | 
20 | 
21 | 
22 | type User = {
23 |   id: string;
24 |   email: string;
25 |   dbUser?: {
26 |     name: string | null;
27 |   } | null;
28 |   user_metadata?: {
29 |     full_name?: string;
30 |     avatar_url?: string;
31 |   };
32 | };
33 | 
34 | export default function UserProfile() {
35 |   const [user, setUser] = useState<User | null>(null);
36 |   const [isLoading, setIsLoading] = useState(true);
37 |   const router = useRouter();
38 | 
39 |   useEffect(() => {
40 |     const fetchUser = async () => {
41 |       try {
42 |         const currentUser = await getCurrentUser();
43 |         setUser(currentUser);
44 |       } catch (error) {
45 |         console.error('사용자 정보 로드 오류:', error);
46 |       } finally {
47 |         setIsLoading(false);
48 |       }
49 |     };
50 | 
51 |     fetchUser();
52 |   }, []);
53 | 
54 |   const handleSignOut = async () => {
55 |     try {
56 |       await signOut();
57 |       toast.success('로그아웃 되었습니다.');
58 |       router.push('/login');
59 |     } catch (error) {
60 |       toast.error('로그아웃 중 오류가 발생했습니다.');
61 |       console.error('로그아웃 오류:', error);
62 |     }
63 |   };
64 | 
65 |   // 사용자 이름을 가져오는 헬퍼 함수
66 |   const getUserName = () => {
67 |     if (!user) return '';
68 | 
69 |     // 우선순위: 1. Google 프로필 이름, 2. DB에 저장된 이름, 3. 이메일 앞부분
70 |     return user.user_metadata?.full_name ||
71 |       user.dbUser?.name ||
72 |       (user.email ? user.email.split('@')[0] : '사용자');
73 |   };
74 | 
75 |   // 아바타 이미지 URL 또는 이니셜을 가져오는 헬퍼 함수
76 |   const getAvatar = () => {
77 |     if (!user) return '';
78 | 
79 |     return user.user_metadata?.avatar_url || '';
80 |   };
81 | 
82 |   // 이니셜 생성 헬퍼 함수
83 |   const getInitials = () => {
84 |     const name = getUserName();
85 |     return name.substring(0, 2).toUpperCase();
86 |   };
87 | 
88 |   if (isLoading) {
89 |     return <div className="h-8 w-8 rounded-full bg-gray-200 animate-pulse" />;
90 |   }
91 | 
92 |   if (!user) {
93 |     return (
94 |       <Button variant="outline" size="sm" onClick={() => router.push('/login')}>
95 |         로그인
[TRUNCATED]
```

src/components/cards/CardList.test.tsx
```
1 | /**
2 |  * 파일명: ./src/components/cards/CardList.test.tsx
3 |  * 목적: 카드 목록 컴포넌트 테스트
4 |  * 역할: 카드 목록 렌더링 및 동작 검증
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-04-25 : lint 오류 수정
7 |  */
8 | 
9 | import React from 'react';
10 | 
11 | import { useSearchParams, useRouter } from 'next/navigation';
12 | 
13 | import { render, screen, fireEvent, cleanup } from '@testing-library/react';
14 | import '@testing-library/jest-dom/vitest';
15 | import { toast } from 'sonner';
16 | import { describe, it, expect, beforeEach, afterEach, afterAll, vi } from 'vitest';
17 | 
18 | import CardList from './CardList';
19 | 
20 | // DOM 변경을 기다리는 헬퍼 함수
21 | const waitForDomChanges = () => new Promise(resolve => setTimeout(resolve, 30));
22 | 
23 | // 토스트 모킹
24 | vi.mock('sonner', () => ({
25 |   toast: {
26 |     error: vi.fn(),
27 |     success: vi.fn(),
28 |   },
29 | }));
30 | 
31 | // Next.js useSearchParams 모킹 개선
32 | vi.mock('next/navigation', async () => {
33 |   const actual = await vi.importActual('next/navigation');
34 |   return {
35 |     ...actual,
36 |     useSearchParams: vi.fn(() => ({
37 |       // eslint-disable-next-line @typescript-eslint/no-unused-vars
38 |       get: (_: string) => null,
39 |       toString: () => '',
40 |     })),
41 |     useRouter: vi.fn(() => ({
42 |       push: vi.fn(),
43 |       replace: vi.fn(),
44 |       prefetch: vi.fn(),
45 |       back: vi.fn(),
46 |     })),
47 |   };
48 | });
49 | 
50 | // fetch는 setupTests.ts에서 이미 전역으로 모킹되어 있음
51 | 
52 | describe('CardList 컴포넌트', () => {
53 |   // console.error 모킹 추가
54 |   const originalConsoleError = console.error;
55 |   beforeEach(() => {
56 |     vi.clearAllMocks();
57 |     console.error = vi.fn();
58 | 
59 |     // 모킹된 카드 데이터 (기본 테스트용)
60 |     const mockCards = [
61 |       {
62 |         id: 'card1',
63 |         title: '테스트 카드 1',
64 |         content: '테스트 내용 1',
65 |         createdAt: '2023-01-01T00:00:00.000Z',
66 |         updatedAt: '2023-01-01T00:00:00.000Z',
67 |         userId: 'user1',
68 |       },
69 |       {
70 |         id: 'card2',
71 |         title: '테스트 카드 2',
72 |         content: '테스트 내용 2',
73 |         createdAt: '2023-01-02T00:00:00.000Z',
74 |         updatedAt: '2023-01-02T00:00:00.000Z',
75 |         userId: 'user2',
76 |       },
77 |     ];
78 | 
79 |     // 기본 fetch 응답 모킹
80 |     (global.fetch as any).mockResolvedValue({
81 |       ok: true,
82 |       json: async () => mockCards,
83 |     });
84 |   });
85 | 
86 |   afterEach(async () => {
87 |     await waitForDomChanges();
88 |     cleanup();
89 |   });
90 | 
[TRUNCATED]
```

src/components/cards/CardList.tsx
```
1 | "use client";
2 | 
3 | import React, { useEffect, useState, useCallback } from "react";
4 | 
5 | import { useSearchParams } from "next/navigation";
6 | import { useRouter } from "next/navigation";
7 | 
8 | import { Trash2, Eye } from "lucide-react";
9 | import { toast } from "sonner";
10 | 
11 | import TiptapViewer from "@/components/editor/TiptapViewer";
12 | import { Badge } from "@/components/ui/badge";
13 | import { Button } from "@/components/ui/button";
14 | import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
15 | import {
16 |   Dialog,
17 |   DialogContent,
18 |   DialogHeader,
19 |   DialogTitle,
20 |   DialogDescription,
21 |   DialogFooter,
22 |   DialogTrigger,
23 |   DialogClose,
24 | } from "@/components/ui/dialog";
25 | import { formatDate } from "@/lib/utils";
26 | import { useAppStore } from "@/store/useAppStore";
27 | 
28 | import { SearchBar } from "./SearchBar";
29 | 
30 | 
31 | 
32 | 
33 | 
34 | interface Tag {
35 |   id: string;
36 |   name: string;
37 | }
38 | 
39 | interface CardTag {
40 |   id: string;
41 |   tag: Tag;
42 | }
43 | 
44 | interface CardItem {
45 |   id: string;
46 |   title: string;
47 |   content: string;
48 |   createdAt: string;
49 |   cardTags?: CardTag[];
50 | }
51 | 
52 | export default function CardList() {
53 |   const { cards, setCards } = useAppStore();
54 |   const [loading, setLoading] = useState(false);
55 |   const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
56 |   const [deletingCardId, setDeletingCardId] = useState<string | null>(null);
57 |   const [isDeleting, setIsDeleting] = useState(false);
58 |   const searchParams = useSearchParams();
59 |   const router = useRouter();
60 | 
61 |   const filteredCards = React.useMemo(() => {
62 |     const q = searchParams.get('q')?.toLowerCase();
63 |     const tag = searchParams.get('tag')?.toLowerCase();
64 | 
65 |     if (!q && !tag) return cards as CardItem[];
66 | 
67 |     return (cards as CardItem[]).filter(card => {
68 |       const matchesQuery = !q ||
69 |         card.title.toLowerCase().includes(q) ||
70 |         (card.content && card.content.toLowerCase().includes(q));
71 | 
72 |       const matchesTag = !tag ||
73 |         card.cardTags?.some(cardTag =>
74 |           cardTag.tag.name.toLowerCase() === tag
75 |         );
76 | 
77 |       return matchesQuery && matchesTag;
78 |     });
79 |   }, [cards, searchParams]);
80 | 
81 |   const fetchCards = useCallback(async () => {
82 |     setLoading(true);
83 |     try {
84 |       const q = searchParams.get('q');
85 |       const tag = searchParams.get('tag');
86 | 
87 |       const params = new URLSearchParams();
88 |       if (q) params.append('q', q);
89 |       if (tag) params.append('tag', tag);
90 | 
91 |       const queryString = params.toString();
[TRUNCATED]
```

src/components/cards/CreateCardModal.test.tsx
```
1 | /**
2 |  * 파일명: src/components/cards/CreateCardModal.test.tsx
3 |  * 목적: CreateCardModal 컴포넌트의 기능 테스트
4 |  * 역할: 카드 생성 모달의 동작, 입력 유효성 검사, API 호출, 태그 관리 등을 테스트
5 |  * 작성일: 2025-04-08
6 |  * 수정일: 2025-04-25 : lint 오류 수정 - 사용되지 않는 import 및 변수 제거
7 |  */
8 | 
9 | import { useState } from 'react';
10 | 
11 | import { render, screen, waitFor } from '@testing-library/react';
12 | import userEvent from '@testing-library/user-event';
13 | import { http, HttpResponse } from 'msw';
14 | import { act } from 'react-dom/test-utils';
15 | import { vi } from 'vitest';
16 | 
17 | import { useAppStore } from '@/store/useAppStore';
18 | import { server } from '@/tests/msw/server';
19 | 
20 | import CreateCardModal from './CreateCardModal';
21 | 
22 | // useRouter 모킹
23 | const mockRouter = {
24 |     refresh: vi.fn(),
25 |     push: vi.fn(),
26 |     replace: vi.fn(),
27 | };
28 | 
29 | vi.mock('next/navigation', () => ({
30 |     useRouter: () => mockRouter,
31 | }));
32 | 
33 | // TipTap 에디터 모킹
34 | vi.mock('@/components/editor/TiptapEditor', () => ({
35 |     default: ({ onUpdate, onChange, content }: { onUpdate?: (content: string) => void, onChange?: (content: string) => void, content?: string }) => {
36 |         const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
37 |             if (onUpdate) {
38 |                 onUpdate(e.target.value);
39 |             }
40 |             if (onChange) {
41 |                 onChange(e.target.value);
42 |             }
43 |         };
44 | 
45 |         return (
46 |             <div data-testid="tiptap-editor">
47 |                 <textarea
48 |                     data-testid="tiptap-content"
49 |                     onChange={handleChange}
50 |                     aria-label="내용"
51 |                     value={content || ""}
52 |                 />
53 |             </div>
54 |         );
55 |     }
56 | }));
57 | 
58 | // toast 모킹
59 | vi.mock('sonner', () => {
60 |     return {
61 |         toast: {
62 |             error: vi.fn(),
63 |             success: vi.fn(),
64 |         }
65 |     };
66 | });
67 | 
68 | // window.location.reload 모킹
69 | const mockReload = vi.fn();
70 | Object.defineProperty(window, 'location', {
71 |     value: { reload: mockReload },
72 |     writable: true
73 | });
74 | 
75 | // console.error 모킹
76 | const originalConsoleError = console.error;
77 | beforeAll(() => {
78 |     console.error = vi.fn();
79 | });
80 | 
81 | afterAll(() => {
82 |     console.error = originalConsoleError;
83 | });
84 | 
85 | // 모의 createCard 함수 정의 추가
86 | const mockCreateCard = vi.fn();
87 | 
88 | // 테스트 사용자 ID 상수 (CreateCardButton.tsx와 동일한 값)
89 | const TEST_USER_ID = "13ce1b15-aa4e-452b-af81-124d06413662";
90 | 
[TRUNCATED]
```

src/components/cards/CreateCardModal.tsx
```
1 | /**
2 |  * 파일명: ./src/components/cards/CreateCardModal.tsx
3 |  * 목적: 새로운 카드 생성을 위한 모달 컴포넌트
4 |  * 역할: 카드 작성 양식을 제공하고 카드 생성 기능 수행
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-04-25 : lint 오류 수정 - 사용되지 않는 import 및 변수 제거
7 |  */
8 | 
9 | "use client";
10 | 
11 | import React, { useState, useRef, useEffect } from "react";
12 | 
13 | import { X, Loader2, PlusCircle } from "lucide-react";
14 | 
15 | import TiptapEditor from "@/components/editor/TiptapEditor";
16 | import { Badge } from "@/components/ui/badge";
17 | import { Button } from "@/components/ui/button";
18 | import {
19 |   Dialog,
20 |   DialogContent,
21 |   DialogHeader,
22 |   DialogTitle,
23 |   DialogTrigger,
24 |   DialogDescription,
25 |   DialogClose,
26 | } from "@/components/ui/dialog";
27 | import { Input } from "@/components/ui/input";
28 | import { Label } from "@/components/ui/label";
29 | import { DEFAULT_USER_ID } from "@/lib/constants";
30 | import { useAppStore } from "@/store/useAppStore";
31 | import { CreateCardInput, Card } from "@/types/card";
32 | 
33 | // 컴포넌트에 props 타입 정의
34 | interface CreateCardModalProps {
35 |   onCardCreated?: (cardData: Card) => void;
36 |   autoOpen?: boolean; // 자동으로 모달을 열지 여부
37 |   onClose?: () => void; // 모달이 닫힐 때 콜백
38 |   customTrigger?: React.ReactNode; // 커스텀 트리거 버튼
39 | }
40 | 
41 | export default function CreateCardModal({
42 |   onCardCreated,
43 |   autoOpen = false,
44 |   onClose,
45 |   customTrigger,
46 | }: CreateCardModalProps) {
47 |   const [open, setOpen] = useState(false);
48 |   const [title, setTitle] = useState("");
49 |   const [content, setContent] = useState("");
50 |   const [tagInput, setTagInput] = useState("");
51 |   const [tags, setTags] = useState<string[]>([]);
52 |   const [firstUserId, setFirstUserId] = useState<string>("");
53 |   const isComposing = useRef(false);
54 | 
55 |   // useAppStore 훅 사용
56 |   const { createCard, isLoading } = useAppStore();
57 | 
58 |   // 자동으로 모달 열기
59 |   useEffect(() => {
60 |     if (autoOpen) {
61 |       setOpen(true);
62 |     }
63 |   }, [autoOpen]);
64 | 
65 |   // 모달 상태 변경 처리 핸들러
66 |   const handleOpenChange = (newOpenState: boolean) => {
67 |     setOpen(newOpenState);
68 | 
69 |     // 모달이 닫힐 때 onClose 콜백 호출
70 |     if (!newOpenState && onClose) {
71 |       onClose();
72 |     }
73 |   };
74 | 
75 |   // 사용자 ID 가져오기
76 |   useEffect(() => {
77 |     async function fetchFirstUserId() {
78 |       try {
79 |         const response = await fetch('/api/users/first');
80 |         if (response.ok) {
81 |           const data = await response.json();
82 |           if (data && data.id) {
83 |             setFirstUserId(data.id);
84 |             console.log('사용자 ID 가져옴:', data.id);
85 |           } else {
[TRUNCATED]
```

src/components/cards/EditCardContent.tsx
```
1 | "use client";
2 | 
3 | import React, { useState } from "react";
4 | 
5 | import { Pencil, Check, X } from "lucide-react";
6 | import { toast } from "sonner";
7 | 
8 | import TiptapEditor from "@/components/editor/TiptapEditor";
9 | import TiptapViewer from "@/components/editor/TiptapViewer";
10 | import { Button } from "@/components/ui/button";
11 | 
12 | 
13 | interface EditCardContentProps {
14 |   cardId: string;
15 |   initialContent: string;
16 | }
17 | 
18 | export default function EditCardContent({ cardId, initialContent }: EditCardContentProps) {
19 |   const [isEditing, setIsEditing] = useState(false);
20 |   const [content, setContent] = useState(initialContent);
21 |   const [isSubmitting, setIsSubmitting] = useState(false);
22 | 
23 |   const handleSubmit = async () => {
24 |     if (content === initialContent) {
25 |       setIsEditing(false);
26 |       return;
27 |     }
28 | 
29 |     if (!content.trim()) {
30 |       toast.error("내용을 입력해주세요.");
31 |       return;
32 |     }
33 | 
34 |     setIsSubmitting(true);
35 | 
36 |     try {
37 |       const response = await fetch(`/api/cards/${cardId}`, {
38 |         method: "PATCH",
39 |         headers: {
40 |           "Content-Type": "application/json",
41 |         },
42 |         body: JSON.stringify({
43 |           content,
44 |         }),
45 |       });
46 | 
47 |       if (!response.ok) {
48 |         const errorData = await response.json();
49 |         throw new Error(errorData.error || "내용 수정에 실패했습니다.");
50 |       }
51 | 
52 |       toast.success("내용이 수정되었습니다.");
53 |       setIsEditing(false);
54 |     } catch (error) {
55 |       console.error("Error updating card content:", error);
56 |       toast.error(error instanceof Error ? error.message : "내용 수정에 실패했습니다.");
57 |     } finally {
58 |       setIsSubmitting(false);
59 |     }
60 |   };
61 | 
62 |   const handleCancel = () => {
63 |     setContent(initialContent);
64 |     setIsEditing(false);
65 |   };
66 | 
67 |   if (isEditing) {
68 |     return (
69 |       <div className="space-y-4">
70 |         <TiptapEditor
71 |           content={content}
72 |           onChange={setContent}
73 |           placeholder="카드 내용을 입력하세요..."
74 |         />
75 |         <div className="flex justify-end space-x-2">
76 |           <Button
77 |             variant="outline"
78 |             size="sm"
79 |             onClick={handleCancel}
80 |             disabled={isSubmitting}
81 |           >
82 |             <X className="h-4 w-4 mr-1" />
83 |             취소
84 |           </Button>
85 |           <Button
86 |             size="sm"
87 |             onClick={handleSubmit}
88 |             disabled={isSubmitting}
89 |           >
90 |             <Check className="h-4 w-4 mr-1" />
91 |             {isSubmitting ? "저장 중..." : "저장"}
92 |           </Button>
93 |         </div>
94 |       </div>
95 |     );
96 |   }
97 | 
98 |   return (
[TRUNCATED]
```

src/components/cards/EditCardForm.tsx
```
1 | /**
2 |  * 파일명: src/components/cards/EditCardForm.tsx
3 |  * 목적: 카드 수정 폼 컴포넌트
4 |  * 역할: 카드 정보를 수정하기 위한 폼을 제공
5 |  * 작성일: 2024-05-17
6 |  */
7 | 
8 | "use client";
9 | 
10 | import React, { useState, useEffect } from "react";
11 | 
12 | import { X } from "lucide-react";
13 | import { toast } from "sonner";
14 | 
15 | import TiptapEditor from "@/components/editor/TiptapEditor";
16 | import { Badge } from "@/components/ui/badge";
17 | import { Button } from "@/components/ui/button";
18 | import { Input } from "@/components/ui/input";
19 | import { Label } from "@/components/ui/label";
20 | 
21 | // 카드 타입 정의
22 | export interface CardData {
23 |   id: string;
24 |   title: string;
25 |   content: string;
26 |   cardTags?: Array<{ tag: { name: string } }>;
27 |   [key: string]: unknown; // 추가 속성을 위한 인덱스 시그니처
28 | }
29 | 
30 | // 컴포넌트 props 타입 정의
31 | interface EditCardFormProps {
32 |   card: CardData; // 카드 데이터
33 |   onSuccess?: (updatedCard?: CardData) => void; // 수정 성공 시 호출할 콜백
34 |   onCancel?: () => void; // 취소 버튼 클릭 시 호출할 콜백
35 | }
36 | 
37 | // EditCardForm 컴포넌트
38 | export default function EditCardForm({ card, onSuccess, onCancel }: EditCardFormProps) {
39 |   const [title, setTitle] = useState('');
40 |   const [content, setContent] = useState('');
41 |   const [tagInput, setTagInput] = useState('');
42 |   const [tags, setTags] = useState<string[]>([]);
43 |   const [isSubmitting, setIsSubmitting] = useState(false);
44 |   const [isComposing, setIsComposing] = useState(false);
45 | 
46 |   // 초기 데이터 로딩
47 |   useEffect(() => {
48 |     if (card) {
49 |       setTitle(card.title || '');
50 |       setContent(card.content || '');
51 |       // CardTag에서 태그 이름을 추출
52 |       if (card.cardTags && Array.isArray(card.cardTags)) {
53 |         const tagNames = card.cardTags.map((cardTag) => cardTag.tag.name);
54 |         setTags(tagNames);
55 |       }
56 |     }
57 |   }, [card]);
58 | 
59 |   // 입력 조합(IME) 시작 핸들러
60 |   const handleCompositionStart = () => {
61 |     setIsComposing(true);
62 |   };
63 | 
64 |   // 입력 조합(IME) 종료 핸들러
65 |   const handleCompositionEnd = () => {
66 |     setIsComposing(false);
67 |   };
68 | 
69 |   // 태그 입력 변경 핸들러
70 |   const handleTagInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
71 |     const value = e.target.value;
72 |     setTagInput(value);
73 | 
74 |     // 쉼표가 포함되어 있으면 태그 추가
75 |     if (value.includes(',') && !isComposing) {
76 |       const newTag = value.replace(',', '').trim();
77 |       if (newTag && !tags.includes(newTag)) {
78 |         setTags([...tags, newTag]);
79 |       }
80 |       setTagInput('');
81 |     }
82 |   };
83 | 
84 |   // 태그 추가 핸들러 (Enter 키)
[TRUNCATED]
```

src/components/cards/EditCardModal.tsx
```
1 | /**
2 |  * 파일명: src/components/cards/EditCardModal.tsx
3 |  * 목적: 카드 수정 모달 컴포넌트
4 |  * 역할: 카드 정보를 수정하기 위한 모달 인터페이스 제공
5 |  * 작성일: 2024-05-17
6 |  */
7 | 
8 | "use client";
9 | 
10 | import React, { useState, useEffect } from 'react';
11 | 
12 | import { X } from 'lucide-react';
13 | 
14 | import EditCardForm from "@/components/cards/EditCardForm";
15 | import type { CardData } from "@/components/cards/EditCardForm";
16 | import { Button } from "@/components/ui/button";
17 | 
18 | interface EditCardModalProps {
19 |   cardId: string;
20 |   onClose: () => void;
21 |   onCardUpdated?: (updatedCard: CardData) => void;
22 | }
23 | 
24 | /**
25 |  * 카드 수정을 위한 모달 컴포넌트
26 |  */
27 | export function EditCardModal({
28 |   cardId,
29 |   onClose,
30 |   onCardUpdated
31 | }: EditCardModalProps) {
32 |   const [card, setCard] = useState<CardData | null>(null);
33 |   const [loading, setLoading] = useState(true);
34 |   const [error, setError] = useState<string | null>(null);
35 | 
36 |   // 카드 데이터 로드
37 |   useEffect(() => {
38 |     const fetchCard = async () => {
39 |       try {
40 |         setLoading(true);
41 |         const response = await fetch(`/api/cards/${cardId}`);
42 | 
43 |         if (!response.ok) {
44 |           throw new Error('카드를 찾을 수 없습니다.');
45 |         }
46 | 
47 |         const data = await response.json();
48 |         setCard(data);
49 |       } catch (err) {
50 |         setError(err instanceof Error ? err.message : '카드 로딩 중 오류가 발생했습니다.');
51 |       } finally {
52 |         setLoading(false);
53 |       }
54 |     };
55 | 
56 |     if (cardId) {
57 |       fetchCard();
58 |     }
59 |   }, [cardId]);
60 | 
61 |   // 카드 업데이트 콜백
62 |   const handleCardUpdated = (updatedCard?: CardData) => {
63 |     if (onCardUpdated && updatedCard) {
64 |       onCardUpdated(updatedCard);
65 |     }
66 |     onClose();
67 |   };
68 | 
69 |   // 클릭 이벤트 전파 방지
70 |   const handleModalClick = (e: React.MouseEvent) => {
71 |     e.stopPropagation();
72 |   };
73 | 
74 |   return (
75 |     <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40" onClick={onClose}>
76 |       <div className="relative bg-card rounded-lg shadow-lg max-w-[700px] w-full mx-4" onClick={handleModalClick}>
77 |         <div className="absolute top-2 right-2">
78 |           <Button variant="ghost" size="icon" onClick={onClose}>
79 |             <X className="h-4 w-4" />
80 |           </Button>
81 |         </div>
82 |         <div className="p-4">
83 |           {loading ? (
84 |             <div className="flex justify-center items-center py-12">
[TRUNCATED]
```

src/components/cards/SearchBar.test.tsx
```
1 | import { render, screen, fireEvent } from '@testing-library/react';
2 | import { describe, it, expect, beforeEach, vi } from 'vitest';
3 | 
4 | import { SearchBar } from './SearchBar';
5 | import '@testing-library/jest-dom';
6 | 
7 | // 기본 모킹 설정
8 | const push = vi.fn();
9 | const useRouterMock = vi.fn().mockReturnValue({ push });
10 | const useSearchParamsMock = vi.fn().mockReturnValue({
11 |   get: vi.fn().mockReturnValue(null)
12 | });
13 | 
14 | vi.mock('next/navigation', () => ({
15 |   useRouter: () => useRouterMock(),
16 |   useSearchParams: () => useSearchParamsMock()
17 | }));
18 | 
19 | // 실제 SearchBar 컴포넌트를 사용합니다.
20 | describe('SearchBar', () => {
21 |   beforeEach(() => {
22 |     vi.clearAllMocks();
23 |     useRouterMock.mockReturnValue({ push });
24 |     useSearchParamsMock.mockReturnValue({
25 |       get: vi.fn().mockReturnValue(null)
26 |     });
27 |   });
28 | 
29 |   it('올바르게 렌더링 되어야 함', () => {
30 |     render(<SearchBar />);
31 |     
32 |     // 기본 요소들이 렌더링 되었는지 확인
33 |     expect(screen.getByPlaceholderText('검색어 입력 또는 #태그 입력')).toBeInTheDocument();
34 |     expect(screen.getByText('검색')).toBeInTheDocument();
35 |   });
36 |   
37 |   it('URL에서 검색어를 가져와 입력 필드에 표시해야 함', () => {
38 |     // URL 파라미터 모킹 설정
39 |     useSearchParamsMock.mockReturnValue({
40 |       get: (param: string) => param === 'q' ? '테스트쿼리' : null
41 |     });
42 |     
43 |     render(<SearchBar />);
44 |     
45 |     // useEffect에서 URL 파라미터를 가져와 입력 필드에 설정
46 |     const inputElement = screen.getByPlaceholderText('검색어 입력 또는 #태그 입력');
47 |     expect(inputElement).toHaveValue('테스트쿼리');
48 |   });
49 |   
50 |   it('검색 버튼 클릭 시 일반 검색어로 올바른 URL로 이동해야 함', () => {
51 |     render(<SearchBar />);
52 |     
53 |     // 입력 필드에 검색어 입력
54 |     const inputElement = screen.getByPlaceholderText('검색어 입력 또는 #태그 입력');
55 |     fireEvent.change(inputElement, { target: { value: '일반검색어' } });
56 |     
57 |     // 검색 버튼 클릭
58 |     const searchButton = screen.getByText('검색');
59 |     fireEvent.click(searchButton);
60 |     
61 |     // 올바른 URL로 이동했는지 확인
62 |     expect(push).toHaveBeenCalledWith('/cards?q=%EC%9D%BC%EB%B0%98%EA%B2%80%EC%83%89%EC%96%B4');
63 |   });
64 |   
65 |   it('태그 검색어(#으로 시작)로 검색 시 올바른 URL로 이동해야 함', () => {
66 |     render(<SearchBar />);
67 |     
68 |     // 입력 필드에 태그 검색어 입력
69 |     const inputElement = screen.getByPlaceholderText('검색어 입력 또는 #태그 입력');
70 |     fireEvent.change(inputElement, { target: { value: '#태그검색' } });
71 |     
72 |     // 검색 버튼 클릭
73 |     const searchButton = screen.getByText('검색');
74 |     fireEvent.click(searchButton);
75 |     
76 |     // 올바른 URL로 이동했는지 확인
[TRUNCATED]
```

src/components/cards/SearchBar.tsx
```
1 | /**
2 |  * 파일명: SearchBar.tsx
3 |  * 목적: 카드 검색 기능 제공
4 |  * 역할: 카드 검색 및 태그 검색 인터페이스 제공
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-03-30
7 |  */
8 | 
9 | 'use client';
10 | 
11 | import { useState, useEffect, useCallback, useRef } from 'react';
12 | 
13 | import { useRouter, useSearchParams } from 'next/navigation';
14 | 
15 | import { Search, X, Hash, AlertCircle } from 'lucide-react';
16 | 
17 | import { Badge } from '@/components/ui/badge';
18 | import { Button } from '@/components/ui/button';
19 | import { Input } from '@/components/ui/input';
20 | import {
21 |   Tooltip,
22 |   TooltipContent,
23 |   TooltipProvider,
24 |   TooltipTrigger,
25 | } from "@/components/ui/tooltip";
26 | import { cn } from '@/lib/utils';
27 | 
28 | interface SearchBarProps {
29 |   className?: string;
30 |   placeholder?: string;
31 | }
32 | 
33 | export const SearchBar = ({ 
34 |   className, 
35 |   placeholder = "검색어 입력 또는 #태그 입력" 
36 | }: SearchBarProps) => {
37 |   const router = useRouter();
38 |   const searchParams = useSearchParams();
39 |   const [searchTerm, setSearchTerm] = useState('');
40 |   const [recentSearches, setRecentSearches] = useState<string[]>([]);
41 |   const [isTagMode, setIsTagMode] = useState(false);
42 |   const inputRef = useRef<HTMLInputElement>(null);
43 |   
44 |   // 로컬 스토리지에서 최근 검색어 불러오기
45 |   useEffect(() => {
46 |     const savedSearches = localStorage.getItem('recentSearches');
47 |     if (savedSearches) {
48 |       try {
49 |         const parsed = JSON.parse(savedSearches);
50 |         if (Array.isArray(parsed)) {
51 |           setRecentSearches(parsed.slice(0, 5)); // 최대 5개까지만 표시
52 |         }
53 |       } catch {
54 |         // 파싱 오류 시 무시
55 |       }
56 |     }
57 |   }, []);
58 |   
59 |   // URL에서 검색어 가져오기
60 |   useEffect(() => {
61 |     const q = searchParams.get('q') || '';
62 |     const tag = searchParams.get('tag');
63 |     
64 |     if (tag) {
65 |       setSearchTerm(`#${tag}`);
66 |       setIsTagMode(true);
67 |     } else {
68 |       setSearchTerm(q);
69 |       setIsTagMode(q.startsWith('#'));
70 |     }
71 |   }, [searchParams]);
72 |   
73 |   // 최근 검색어 저장
74 |   const saveRecentSearch = useCallback((term: string) => {
75 |     if (!term || term.length < 2) return; // 너무 짧은 검색어는 저장하지 않음
76 |     
77 |     const newSearches = [
78 |       term, 
79 |       ...recentSearches.filter(s => s !== term)
80 |     ].slice(0, 5);
81 |     
82 |     setRecentSearches(newSearches);
83 |     localStorage.setItem('recentSearches', JSON.stringify(newSearches));
84 |   }, [recentSearches]);
85 |   
86 |   // 검색 실행
87 |   const handleSearch = useCallback(() => {
88 |     // 태그 검색과 일반 검색 분리
89 |     // #으로 시작하는 검색어는 태그 검색으로 처리
90 |     if (searchTerm.startsWith('#')) {
[TRUNCATED]
```

src/components/cards/TagFilter.tsx
```
1 | /**
2 |  * 파일명: TagFilter.tsx
3 |  * 목적: 카드 목록에서 태그 기반 필터링 제공
4 |  * 역할: 선택 가능한 태그 목록을 표시하고 태그 필터링 기능 제공
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | 'use client';
9 | 
10 | import { useState, useEffect } from 'react';
11 | 
12 | import { useRouter, useSearchParams } from 'next/navigation';
13 | 
14 | import { Loader2, Tags, ChevronDown, ChevronUp } from 'lucide-react';
15 | import { toast } from 'sonner';
16 | 
17 | import { Badge } from '@/components/ui/badge';
18 | import { Button } from '@/components/ui/button';
19 | import { ScrollArea } from '@/components/ui/scroll-area';
20 | import { cn } from '@/lib/utils';
21 | 
22 | interface Tag {
23 |   id: string;
24 |   name: string;
25 |   count: number;
26 | }
27 | 
28 | export function TagFilter() {
29 |   const router = useRouter();
30 |   const searchParams = useSearchParams();
31 |   const [tags, setTags] = useState<Tag[]>([]);
32 |   const [loading, setLoading] = useState(true);
33 |   const [expanded, setExpanded] = useState(true);
34 |   const [selectedTag, setSelectedTag] = useState<string | null>(null);
35 | 
36 |   // URL에서 현재 선택된 태그 가져오기
37 |   useEffect(() => {
38 |     const tagParam = searchParams.get('tag');
39 |     setSelectedTag(tagParam);
40 |   }, [searchParams]);
41 | 
42 |   // 태그 목록 가져오기
43 |   useEffect(() => {
44 |     async function fetchTags() {
45 |       setLoading(true);
46 |       try {
47 |         const response = await fetch('/api/tags?includeCount=true');
48 |         if (!response.ok) {
49 |           throw new Error('태그 목록을 불러오는데 실패했습니다');
50 |         }
51 |         
52 |         const data = await response.json();
53 |         setTags(data.sort((a: Tag, b: Tag) => b.count - a.count)); // 사용 빈도순 정렬
54 |       } catch (error) {
55 |         console.error('태그 로딩 오류:', error);
56 |         toast.error('태그 목록을 불러오는데 실패했습니다');
57 |       } finally {
58 |         setLoading(false);
59 |       }
60 |     }
61 |     
62 |     fetchTags();
63 |   }, []);
64 | 
65 |   // 태그 클릭 핸들러
66 |   const handleTagClick = (tagName: string) => {
67 |     if (selectedTag === tagName) {
68 |       // 이미 선택된 태그를 다시 클릭하면 필터 해제
69 |       router.push('/cards');
70 |       setSelectedTag(null);
71 |     } else {
72 |       // 새 태그 선택
73 |       router.push(`/cards?tag=${encodeURIComponent(tagName)}`);
74 |       setSelectedTag(tagName);
75 |     }
76 |   };
77 | 
78 |   return (
79 |     <div className="mb-4 border rounded-md">
80 |       <div 
81 |         className="p-3 flex justify-between items-center cursor-pointer bg-muted/30"
82 |         onClick={() => setExpanded(!expanded)}
83 |       >
84 |         <h3 className="font-medium flex items-center">
[TRUNCATED]
```

src/components/debug/DevTools.tsx
```
1 | import { useState } from 'react';
2 | 
3 | import { Panel } from '@xyflow/react';
4 | 
5 | import { ChangeLogger, useChangeLogger, type ChangeLoggerHandlers } from './ChangeLogger';
6 | import { NodeInspector } from './NodeInspector';
7 | import { ViewportLogger } from './ViewportLogger';
8 | 
9 | /**
10 |  * React Flow 디버깅을 위한 DevTools 컴포넌트
11 |  * 뷰포트 로거, 노드 인스펙터, 변경 로거를 포함합니다.
12 |  */
13 | export default function DevTools() {
14 |   const [showViewport, setShowViewport] = useState(false);
15 |   const [showNodeInspector, setShowNodeInspector] = useState(false);
16 |   const [showChangeLogger, setShowChangeLogger] = useState(false);
17 | 
18 |   return (
19 |     <Panel 
20 |       position="top-left" 
21 |       className="bg-card shadow p-3 rounded-md z-50"
22 |     >
23 |       <div className="flex flex-col gap-2">
24 |         <div className="flex gap-2 justify-center items-center">
25 |           <button
26 |             onClick={() => setShowViewport(!showViewport)}
27 |             className={`px-2 py-1 text-xs rounded ${
28 |               showViewport ? 'bg-blue-500 text-white' : 'bg-gray-200'
29 |             }`}
30 |           >
31 |             뷰포트 로거 {showViewport ? '숨기기' : '보기'}
32 |           </button>
33 |           <button
34 |             onClick={() => setShowNodeInspector(!showNodeInspector)}
35 |             className={`px-2 py-1 text-xs rounded ${
36 |               showNodeInspector ? 'bg-blue-500 text-white' : 'bg-gray-200'
37 |             }`}
38 |           >
39 |             노드 인스펙터 {showNodeInspector ? '숨기기' : '보기'}
40 |           </button>
41 |           <button
42 |             onClick={() => setShowChangeLogger(!showChangeLogger)}
43 |             className={`px-2 py-1 text-xs rounded ${
44 |               showChangeLogger ? 'bg-blue-500 text-white' : 'bg-gray-200'
45 |             }`}
46 |           >
47 |             변경 로거 {showChangeLogger ? '숨기기' : '보기'}
48 |           </button>
49 |         </div>
50 |         
51 |         {showViewport && <ViewportLogger />}
52 |         {showNodeInspector && <NodeInspector />}
53 |         {showChangeLogger && <ChangeLogger />}
54 |       </div>
55 |     </Panel>
56 |   );
57 | }
58 | 
59 | // 노드와 엣지 변경 감지를 위한 훅 익스포트
60 | export const useChangeLoggerHooks = (): ChangeLoggerHandlers => {
61 |   const [, , handlers] = useChangeLogger();
62 |   return handlers;
63 | } 
```

src/components/debug/InitDatabase.tsx
```
1 | /**
2 |  * 파일명: InitDatabase.tsx
3 |  * 목적: 개발 환경에서 데이터베이스 초기화
4 |  * 역할: 개발 환경에서만 데이터베이스를 초기화하는 컴포넌트
5 |  * 작성일: 2025-03-30
6 |  */
7 | 
8 | 'use client';
9 | 
10 | import { useEffect } from 'react';
11 | 
12 | /**
13 |  * InitDatabase: 개발 환경에서만 데이터베이스를 초기화하는 컴포넌트
14 |  * @returns null - UI를 렌더링하지 않음
15 |  */
16 | export default function InitDatabase() {
17 |   useEffect(() => {
18 |     const initDatabase = async () => {
19 |       if (process.env.NEXT_PUBLIC_ENABLE_DB_INIT !== 'true') {
20 |         return;
21 |       }
22 | 
23 |       try {
24 |         const response = await fetch('/api/db-init');
25 |         if (!response.ok) {
26 |           throw new Error('Failed to initialize database');
27 |         }
28 |         console.log('Database initialized successfully');
29 |       } catch (error) {
30 |         console.error('Error initializing database:', error);
31 |       }
32 |     };
33 | 
34 |     initDatabase();
35 |   }, []);
36 | 
37 |   return null;
38 | } 
```

src/components/debug/ViewportLogger.tsx
```
1 | import { useStore } from '@xyflow/react';
2 | import { shallow } from 'zustand/shallow';
3 | 
4 | /**
5 |  * ViewportLogger 컴포넌트는 현재 React Flow 뷰포트의 상태를 표시합니다.
6 |  * x, y 위치와 줌 레벨을 실시간으로 보여줍니다.
7 |  */
8 | const selector = (state: { transform?: [number, number, number] }) => ({
9 |   x: state.transform?.[0] || 0,
10 |   y: state.transform?.[1] || 0,
11 |   zoom: state.transform?.[2] || 1,
12 | });
13 | 
14 | export function ViewportLogger() {
15 |   const { x, y, zoom } = useStore(selector, shallow);
16 | 
17 |   return (
18 |     <div className="bg-muted p-2 rounded border text-xs mt-2">
19 |       <h3 className="font-bold mb-1 border-b pb-1">뷰포트 로거</h3>
20 |       <div>
21 |         <span>x: {x.toFixed(2)}</span>, <span>y: {y.toFixed(2)}</span>, <span>zoom: {zoom.toFixed(2)}</span>
22 |       </div>
23 |     </div>
24 |   );
25 | } 
```

src/components/editor/DocumentViewer.tsx
```
1 | 'use client';
2 | 
3 | import React, { useMemo, useEffect } from 'react';
4 | 
5 | import { Badge } from '@/components/ui/badge';
6 | import { Skeleton } from '@/components/ui/skeleton';
7 | 
8 | import TiptapViewer from './TiptapViewer';
9 | 
10 | // 카드 타입 정의
11 | interface CardData {
12 |   id: string;
13 |   title: string;
14 |   content: string;
15 |   createdAt?: string;
16 |   cardTags?: Array<{ id: string; tag: { id: string; name: string } }>;
17 | }
18 | 
19 | // 컴포넌트 props 인터페이스 단순화
20 | interface DocumentViewerProps {
21 |   cards: CardData[];
22 |   isMultiSelection: boolean;
23 |   loading: boolean;
24 | }
25 | 
26 | export default function DocumentViewer({
27 |   cards,
28 |   isMultiSelection,
29 |   loading
30 | }: DocumentViewerProps) {
31 |   // 디버깅용 로그 추가
32 |   useEffect(() => {
33 |     // 카드 내용이 변경되면 로그 출력
34 |     if (cards && cards.length > 0) {
35 |       console.log('DocumentViewer 카드 업데이트됨:', {
36 |         카드수: cards.length,
37 |         첫번째카드: cards[0]?.id,
38 |         내용길이: cards[0]?.content?.length || 0,
39 |         다중선택: isMultiSelection
40 |       });
41 |     }
42 |   }, [cards, isMultiSelection]);
43 | 
44 |   // 데이터 가공 로직을 컴포넌트 내부로 이동
45 |   const { content, tags } = useMemo(() => {
46 |     if (!cards || cards.length === 0) {
47 |       return { title: '', content: '', date: null, tags: [] };
48 |     }
49 | 
50 |     // 단일 카드 선택 모드
51 |     if (!isMultiSelection || cards.length === 1) {
52 |       const card = cards[0];
53 |       return {
54 |         title: card.title || '',
55 |         content: card.content || '',
56 |         date: card.createdAt || null,
57 |         tags: card.cardTags ? card.cardTags.map(ct => ct.tag.name) : []
58 |       };
59 |     }
60 | 
61 |     // 다중 카드 선택 모드 - 여기서 병합 로직 처리
62 |     const multiTitle = cards.map(card => card.title).join(', ');
63 |     // 카드 내용을 HTML로 병합
64 |     const multiContent = cards.map(card => {
65 |       return card.content;
66 |     }).join('');
67 | 
68 |     return {
69 |       title: multiTitle,
70 |       content: multiContent,
71 |       date: null,
72 |       tags: []
73 |     };
74 |   }, [cards, isMultiSelection]);
75 | 
76 |   if (loading) {
77 |     return (
78 |       <div className="p-6 space-y-4">
79 |         <Skeleton className="h-8 w-3/4" />
80 |         <Skeleton className="h-4 w-1/4" />
81 |         <div className="space-y-2 mt-6">
82 |           <Skeleton className="h-24 w-full" />
83 |           <Skeleton className="h-24 w-full" />
84 |           <Skeleton className="h-24 w-full" />
85 |         </div>
86 |       </div>
87 |     );
88 |   }
[TRUNCATED]
```

src/components/editor/TiptapEditor.tsx
```
1 | "use client";
2 | 
3 | import React, { useCallback, useEffect } from 'react'
4 | 
5 | import Heading from '@tiptap/extension-heading'
6 | import Image from '@tiptap/extension-image'
7 | import Link from '@tiptap/extension-link'
8 | import Placeholder from '@tiptap/extension-placeholder'
9 | import { useEditor, EditorContent, BubbleMenu, FloatingMenu } from '@tiptap/react'
10 | import StarterKit from '@tiptap/starter-kit'
11 | import { 
12 |   Bold as BoldIcon,
13 |   Italic as ItalicIcon,
14 |   Link as LinkIcon,
15 |   Heading1 as H1Icon,
16 |   Heading2 as H2Icon,
17 |   List as ListIcon,
18 |   ListOrdered as OrderedListIcon,
19 |   Image as ImageIcon
20 | } from 'lucide-react'
21 | 
22 | import { Button } from '@/components/ui/button'
23 | 
24 | 
25 | interface TiptapEditorProps {
26 |   content: string
27 |   onChange: (content: string) => void
28 |   placeholder?: string
29 |   showToolbar?: boolean
30 |   id?: string
31 | }
32 | 
33 | export default function TiptapEditor({ 
34 |   content, 
35 |   onChange, 
36 |   placeholder = '내용을 입력하세요...', 
37 |   showToolbar = true,
38 |   id = 'tiptap-editor'
39 | }: TiptapEditorProps) {
40 |   const editor = useEditor({
41 |     extensions: [
42 |       StarterKit.configure({
43 |         bulletList: {
44 |           keepMarks: true,
45 |           keepAttributes: false,
46 |         },
47 |         orderedList: {
48 |           keepMarks: true,
49 |           keepAttributes: false,
50 |         },
51 |         heading: false,
52 |       }),
53 |       Link.configure({
54 |         openOnClick: false,
55 |       }),
56 |       Heading.configure({
57 |         levels: [1, 2, 3],
58 |       }),
59 |       Image,
60 |       Placeholder.configure({
61 |         placeholder: placeholder || '내용을 입력하세요...',
62 |       }),
63 |     ],
64 |     content: content,
65 |     immediatelyRender: false,
66 |     onUpdate: ({ editor }) => {
67 |       onChange(editor.getHTML());
68 |     },
69 |     editorProps: {
70 |       attributes: {
71 |         class: 'min-h-[150px] prose dark:prose-invert focus:outline-none max-w-none p-4 border rounded-md',
72 |       },
73 |     },
74 |   });
75 | 
76 |   useEffect(() => {
77 |     if (editor && content !== editor.getHTML()) {
78 |       editor.commands.setContent(content);
79 |     }
80 |   }, [content, editor]);
81 | 
82 |   const setLink = useCallback(() => {
83 |     if (!editor) return;
84 |     
85 |     const previousUrl = editor.getAttributes('link').href;
86 |     const url = window.prompt('URL 입력', previousUrl);
87 | 
88 |     if (url === null) {
89 |       return;
90 |     }
91 | 
92 |     if (url === '') {
93 |       editor.chain().focus().extendMarkRange('link').unsetLink().run();
94 |       return;
95 |     }
96 | 
97 |     editor.chain().focus().extendMarkRange('link').setLink({ href: url }).run();
98 |   }, [editor]);
99 | 
100 |   const addImage = useCallback(() => {
[TRUNCATED]
```

src/components/editor/TiptapViewer.tsx
```
1 | "use client";
2 | 
3 | import React from 'react';
4 | 
5 | import Heading from '@tiptap/extension-heading';
6 | import Image from '@tiptap/extension-image';
7 | import Link from '@tiptap/extension-link';
8 | import { useEditor, EditorContent } from '@tiptap/react';
9 | import StarterKit from '@tiptap/starter-kit';
10 | 
11 | interface TiptapViewerProps {
12 |   content: string;
13 | }
14 | 
15 | export default function TiptapViewer({ content }: TiptapViewerProps) {
16 |   const editor = useEditor({
17 |     extensions: [
18 |       StarterKit.configure({
19 |         heading: false,
20 |       }),
21 |       Link.configure({
22 |         openOnClick: true,
23 |       }),
24 |       Heading.configure({
25 |         levels: [1, 2],
26 |       }),
27 |       Image,
28 |     ],
29 |     content,
30 |     editable: false,
31 |     immediatelyRender: false,
32 |     editorProps: {
33 |       attributes: {
34 |         class: 'prose dark:prose-invert max-w-none',
35 |       },
36 |     },
37 |   });
38 | 
39 |   return <EditorContent editor={editor} />;
40 | } 
```

src/components/ideamap/DagreNodePositioning.test.tsx
```
1 | import React from 'react';
2 | 
3 | import { render } from '@testing-library/react';
4 | import { ReactFlowProvider } from '@xyflow/react';
5 | import { Edge } from '@xyflow/react';
6 | import { vi } from 'vitest';
7 | 
8 | import DagreNodePositioning from './DagreNodePositioning';
9 | 
10 | 
11 | // 단순 렌더링 테스트
12 | describe('DagreNodePositioning', () => {
13 |   it('컴포넌트가 오류 없이 렌더링되어야 합니다', () => {
14 |     const dummyOptions = { rankdir: 'TB' as const };
15 |     const dummySetNodes = vi.fn();
16 |     const dummySetEdges = vi.fn();
17 |     const dummySetViewIsFit = vi.fn();
18 |     const dummyEdges: Edge[] = [];
19 |     
20 |     render(
21 |       <ReactFlowProvider>
22 |         <DagreNodePositioning
23 |           Options={dummyOptions}
24 |           Edges={dummyEdges}
25 |           SetEdges={dummySetEdges}
26 |           SetNodes={dummySetNodes}
27 |           SetViewIsFit={dummySetViewIsFit}
28 |         />
29 |       </ReactFlowProvider>
30 |     );
31 |   });
32 | }); 
```

src/components/ideamap/DagreNodePositioning.tsx
```
1 | /**
2 |  * 파일명: src/components/ideamap/DagreNodePositioning.tsx
3 |  * 목적: Dagre 레이아웃 알고리즘을 사용하여 노드 위치를 자동으로 계산
4 |  * 역할: Idea Map의 노드 자동 배치 및 레이아웃 적용 컴포넌트
5 |  * 작성일: 2023-04-10
6 |  * 수정일: 2024-05-30 : prefer-const 린트 규칙 적용
7 |  * 수정일: 2025-05-07 : 미사용 변수 제거 (nodesPositioned)
8 |  */
9 | 
10 | import React, { useEffect } from 'react';
11 | 
12 | import { useReactFlow, Node, Edge, Position } from '@xyflow/react';
13 | import dagre from 'dagre';
14 | 
15 | import defaultConfig from '../../config/uiOptions.json';
16 | 
17 | interface DagreNodePositioningProps {
18 |   Options: { rankdir: 'TB' | 'LR' | 'BT' | 'RL' };
19 |   Edges: Edge[];
20 |   SetEdges: (edges: Edge[]) => void;
21 |   SetNodes: (nodes: Node[]) => void;
22 |   SetViewIsFit: (value: boolean) => void;
23 | }
24 | 
25 | // 기본 CardNode의 크기 - 설정 파일에서 일관되게 가져오기
26 | const nodeWidth = defaultConfig.layout.nodeSize?.width || 130;
27 | const nodeHeight = defaultConfig.layout.nodeSize?.height || 48;
28 | 
29 | const DagreNodePositioning: React.FC<DagreNodePositioningProps> = ({ Options, Edges, SetEdges, SetNodes, SetViewIsFit }) => {
30 |   const { fitView, getNodes } = useReactFlow();
31 | 
32 |   // React Flow 인스턴스에서 노드 직접 가져오기
33 |   const flattenedNodes = getNodes();
34 | 
35 |   useEffect(() => {
36 |     // 노드가 존재하는지 확인
37 |     if (flattenedNodes.length > 0) {
38 |       const dagreGraph = new dagre.graphlib.Graph();
39 |       dagreGraph.setDefaultEdgeLabel(() => ({}));
40 |       dagreGraph.setGraph(Options);
41 | 
42 |       // 모든 노드를 dagre 그래프에 등록 (기본값 사용)
43 |       flattenedNodes.forEach((node) => {
44 |         // 실제 측정된 크기가 없으므로 기본값 사용
45 |         dagreGraph.setNode(node.id, { width: nodeWidth, height: nodeHeight });
46 |       });
47 | 
48 |       // 엣지 등록
49 |       Edges.forEach((edge) => {
50 |         dagreGraph.setEdge(edge.source, edge.target);
51 |       });
52 | 
53 |       // 레이아웃 계산
54 |       dagre.layout(dagreGraph);
55 | 
56 |       // 각 노드의 위치를 업데이트
57 |       const layoutedNodes = flattenedNodes.map((node) => {
58 |         const nodeWithPosition = dagreGraph.node(node.id);
59 |         if (!nodeWithPosition) {
60 |           return node;
61 |         }
62 | 
63 |         const updatedNode = {
64 |           ...node,
65 |           position: {
66 |             x: nodeWithPosition.x - nodeWidth / 2,
67 |             y: nodeWithPosition.y - nodeHeight / 2
68 |           },
69 |           data: { ...node.data }
70 |         } as Node;
71 | 
72 |         // 레이아웃 방향에 따라 핸들 위치 지정
73 |         if (Options.rankdir === 'TB' || Options.rankdir === 'BT') {
74 |           updatedNode.targetPosition = Position.Top;
75 |           updatedNode.sourcePosition = Position.Bottom;
76 |         } else if (Options.rankdir === 'LR' || Options.rankdir === 'RL') {
77 |           updatedNode.targetPosition = Position.Left;
[TRUNCATED]
```

src/components/ideamap/DebugPanel.tsx
```
1 | import React, { useState, useEffect } from 'react';
2 | 
3 | import { useReactFlow, NodeChange, EdgeChange } from '@xyflow/react';
4 | 
5 | interface DebugPanelProps {
6 |   nodeChanges?: NodeChange[];
7 |   edgeChanges?: EdgeChange[];
8 | }
9 | 
10 | const DebugPanel: React.FC<DebugPanelProps> = ({ nodeChanges, edgeChanges }) => {
11 |   const [isOpen, setIsOpen] = useState(false);
12 |   const { getViewport, getNodes } = useReactFlow();
13 |   const [viewport, setViewport] = useState({ x: 0, y: 0, zoom: 1 });
14 |   const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
15 |   const [logs, setLogs] = useState<Array<{ time: string; message: string }>>([]);
16 | 
17 |   // 뷰포트 업데이트
18 |   useEffect(() => {
19 |     const interval = setInterval(() => {
20 |       const currentViewport = getViewport();
21 |       setViewport(currentViewport);
22 |     }, 100);
23 | 
24 |     return () => clearInterval(interval);
25 |   }, [getViewport]);
26 | 
27 |   // 로그 추가 함수
28 |   const addLog = (message: string) => {
29 |     const time = new Date().toLocaleTimeString();
30 |     setLogs(prev => [...prev.slice(-9), { time, message }]);
31 |   };
32 | 
33 |   // 노드 변경 시 로그 추가
34 |   useEffect(() => {
35 |     if (nodeChanges && nodeChanges.length > 0) {
36 |       const message = `노드 변경: ${nodeChanges.map(c => `${c.type} ${c.id}`).join(', ')}`;
37 |       addLog(message);
38 |     }
39 |   }, [nodeChanges]);
40 | 
41 |   // 엣지 변경 시 로그 추가
42 |   useEffect(() => {
43 |     if (edgeChanges && edgeChanges.length > 0) {
44 |       const message = `엣지 변경: ${edgeChanges.map(c => `${c.type} ${c.id}`).join(', ')}`;
45 |       addLog(message);
46 |     }
47 |   }, [edgeChanges]);
48 | 
49 |   // 선택된 노드 정보
50 |   const selectedNode = selectedNodeId 
51 |     ? getNodes().find(node => node.id === selectedNodeId) 
52 |     : null;
53 | 
54 |   return (
55 |     <div className="fixed left-2 top-16 z-50">
56 |       <button 
57 |         onClick={() => setIsOpen(!isOpen)}
58 |         className="mb-2 px-3 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
59 |       >
60 |         {isOpen ? '디버그 패널 닫기' : '디버그 패널 열기'}
61 |       </button>
62 |       
63 |       {isOpen && (
64 |         <div className="bg-white p-3 rounded shadow-lg border border-gray-200 w-64 max-h-[80vh] overflow-y-auto">
65 |           <div className="mb-3">
66 |             <h3 className="text-sm font-bold border-b pb-1 mb-2">뷰포트 정보</h3>
67 |             <div className="text-xs">
68 |               <div>X: {viewport.x.toFixed(2)}</div>
69 |               <div>Y: {viewport.y.toFixed(2)}</div>
[TRUNCATED]
```

src/components/ideamap/LayoutControls.tsx
```
1 | /**
2 |  * 파일명: src/components/ideamap/LayoutControls.tsx
3 |  * 목적: 아이디어맵 레이아웃 제어 컴포넌트
4 |  * 역할: 레이아웃 방향 변경, 자동 배치, 레이아웃 저장 기능 제공
5 |  * 작성일: 2024-05-07
6 |  * 수정일: 2024-05-07 : 미사용 import(toast) 제거
7 |  */
8 | 
9 | import React from 'react';
10 | 
11 | import { Layout, LayoutGrid, AlignHorizontalJustifyCenter, AlignVerticalJustifyCenter } from 'lucide-react';
12 | 
13 | import { Button } from '@/components/ui/button';
14 | import {
15 |   DropdownMenu,
16 |   DropdownMenuContent,
17 |   DropdownMenuItem,
18 |   DropdownMenuLabel,
19 |   DropdownMenuSeparator,
20 |   DropdownMenuTrigger,
21 | } from '@/components/ui/dropdown-menu';
22 | 
23 | interface LayoutControlsProps {
24 |   onLayoutChange: (direction: 'horizontal' | 'vertical') => void;
25 |   onAutoLayout: () => void;
26 |   onSaveLayout: () => void;
27 | }
28 | 
29 | export default function LayoutControls({
30 |   onLayoutChange,
31 |   onAutoLayout,
32 |   onSaveLayout
33 | }: LayoutControlsProps) {
34 |   return (
35 |     <DropdownMenu>
36 |       <DropdownMenuTrigger asChild>
37 |         <Button variant="outline" size="icon">
38 |           <Layout className="h-4 w-4" />
39 |         </Button>
40 |       </DropdownMenuTrigger>
41 |       <DropdownMenuContent align="end" className="w-56">
42 |         <DropdownMenuLabel>레이아웃 옵션</DropdownMenuLabel>
43 |         <DropdownMenuSeparator />
44 |         <DropdownMenuItem
45 |           onClick={() => onLayoutChange('horizontal')}
46 |           className="flex items-center cursor-pointer"
47 |         >
48 |           <AlignHorizontalJustifyCenter className="mr-2 h-4 w-4" />
49 |           <span>수평 레이아웃</span>
50 |         </DropdownMenuItem>
51 |         <DropdownMenuItem
52 |           onClick={() => onLayoutChange('vertical')}
53 |           className="flex items-center cursor-pointer"
54 |         >
55 |           <AlignVerticalJustifyCenter className="mr-2 h-4 w-4" />
56 |           <span>수직 레이아웃</span>
57 |         </DropdownMenuItem>
58 |         <DropdownMenuSeparator />
59 |         <DropdownMenuItem
60 |           onClick={onAutoLayout}
61 |           className="flex items-center cursor-pointer"
62 |         >
63 |           <LayoutGrid className="mr-2 h-4 w-4" />
64 |           <span>자동 배치</span>
65 |         </DropdownMenuItem>
66 |         <DropdownMenuItem
67 |           onClick={onSaveLayout}
68 |           className="flex items-center cursor-pointer"
69 |         >
70 |           <svg className="mr-2 h-4 w-4" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
71 |             <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
72 |             <polyline points="17 21 17 13 7 13 7 21" />
73 |             <polyline points="7 3 7 8 15 8" />
74 |           </svg>
75 |           <span>레이아웃 저장</span>
76 |         </DropdownMenuItem>
77 |       </DropdownMenuContent>
[TRUNCATED]
```

src/components/layout/ClientLayout.tsx
```
1 | /**
2 |  * 파일명: ClientLayout.tsx
3 |  * 목적: 클라이언트 측 레이아웃과 전역 상태 관리 컴포넌트
4 |  * 역할: 인증 상태, 토스트 메시지 등 클라이언트 컴포넌트 래핑
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-09
7 |  */
8 | 
9 | 'use client';
10 | 
11 | import { ReactNode, useEffect } from 'react';
12 | 
13 | import { Toaster } from "sonner";
14 | 
15 | import InitDatabase from "@/components/debug/InitDatabase";
16 | import { AuthProvider } from "@/contexts/AuthContext";
17 | import { ThemeProvider } from "@/contexts/ThemeContext";
18 | import createLogger from '@/lib/logger';
19 | 
20 | // Supabase 클라이언트 초기화 (클라이언트에서만 실행)
21 | import { createClient } from "@/lib/supabase/client";
22 | 
23 | // 모듈별 로거 생성
24 | const logger = createLogger('ClientLayout');
25 | 
26 | /**
27 |  * ClientLayout: 클라이언트 전용 레이아웃 컴포넌트
28 |  * @param children - 자식 컴포넌트
29 |  * @returns 클라이언트 레이아웃 컴포넌트
30 |  */
31 | export function ClientLayout({ children }: { children: ReactNode }) {
32 |   useEffect(() => {
33 |     logger.info('클라이언트 레이아웃 마운트');
34 | 
35 |     // 브라우저 환경 확인 로깅
36 |     if (typeof window !== 'undefined') {
37 |       logger.info('브라우저 환경 확인');
38 |       // localStorage 접근 여부 체크 (프라이빗 브라우징에서 예외 발생 가능)
39 |       try {
40 |         localStorage.setItem('client_layout_test', 'test');
41 |         localStorage.removeItem('client_layout_test');
42 |         logger.info('localStorage 접근 가능');
43 | 
44 |         // 저장된 사용자 ID 확인 (디버깅용)
45 |         const userId = localStorage.getItem('user_id');
46 |         if (userId) {
47 |           console.log('=== 로컬 스토리지에 저장된 사용자 ID ===');
48 |           console.log('user_id:', userId);
49 |           console.log('==================');
50 |         } else {
51 |           console.log('로컬 스토리지에 user_id가 없습니다.');
52 |         }
53 |       } catch (error) {
54 |         logger.warn('localStorage 접근 불가', error);
55 |       }
56 |     }
57 | 
58 |     return () => {
59 |       logger.info('클라이언트 레이아웃 언마운트');
60 |     };
61 |   }, []);
62 | 
63 |   return (
64 |     <AuthProvider>
65 |       <ThemeProvider>
66 |         <main>
67 |           {children}
68 | 
69 |           {/* DB 초기화 스크립트 */}
70 |           <InitDatabase />
71 |         </main>
72 |         <Toaster position="top-center" />
73 |       </ThemeProvider>
74 |     </AuthProvider>
75 |   );
76 | } 
```

src/components/layout/DashboardLayout.tsx
```
1 | 'use client';
2 | 
3 | import { useEffect } from 'react';
4 | 
5 | import { ReactFlowProvider } from '@xyflow/react';
6 | 
7 | import { useAppStore } from '@/store/useAppStore';
8 | 
9 | import { MainCanvas } from './MainCanvas';
10 | import { MainToolbar } from './MainToolbar';
11 | import { ProjectToolbar } from './ProjectToolbar';
12 | import { ShortcutToolbar } from './ShortcutToolbar';
13 | import { Sidebar } from './Sidebar';
14 | // React Flow 스타일은 MainCanvas에서 import 합니다
15 | 
16 | export function DashboardLayout() {
17 |   const { isSidebarOpen } = useAppStore();
18 | 
19 |   // 클라이언트 측에서만 실행되는 코드
20 |   useEffect(() => {
21 |     // 여기에 필요한 초기화 코드 추가
22 |     console.log('DashboardLayout 마운트됨');
23 |     
24 |     return () => {
25 |       console.log('DashboardLayout 언마운트됨');
26 |     };
27 |   }, []);
28 | 
29 |   return (
30 |     <div className="flex h-screen overflow-hidden bg-background">
31 |       {/* 프로젝트 툴바 (좌측 상단) */}
32 |       <ProjectToolbar />
33 |       
34 |       {/* 단축키 툴바 (우측 상단) */}
35 |       <ShortcutToolbar />
36 |       
37 |       {/* 메인 콘텐츠 영역 */}
38 |       <div className="flex flex-1 relative">
39 |         {/* 메인 캔버스 */}
40 |         <div className={`flex-1 h-full transition-all duration-300 ${isSidebarOpen ? 'mr-80' : ''}`}>
41 |           <ReactFlowProvider>
42 |             <MainCanvas />
43 |           </ReactFlowProvider>
44 |         </div>
45 |         
46 |         {/* 사이드바 */}
47 |         <Sidebar />
48 |       </div>
49 |       
50 |       {/* 메인 툴바 (하단 센터) */}
51 |       <MainToolbar />
52 |     </div>
53 |   );
54 | } 
```

src/components/layout/MainCanvas.test.tsx
```
1 | /**
2 |  * 파일명: MainCanvas.test.tsx
3 |  * 목적: MainCanvas 컴포넌트 테스트
4 |  * 역할: MainCanvas가 적절하게 렌더링되고 IdeaMap 컴포넌트에 올바른 props를 전달하는지 테스트
5 |  * 작성일: 2025-03-28
6 |  */
7 | 
8 | import { render, screen } from '@testing-library/react';
9 | import { vi } from 'vitest';
10 | 
11 | import { MainCanvas } from './MainCanvas';
12 | 
13 | // 종속성 모킹
14 | vi.mock('@/store/useAppStore', () => ({
15 |   useAppStore: () => ({
16 |     selectCard: vi.fn(),
17 |   }),
18 | }));
19 | 
20 | vi.mock('@xyflow/react', () => ({
21 |   ReactFlowProvider: ({ children }: { children: React.ReactNode }) => (
22 |     <div data-testid="react-flow-provider">{children}</div>
23 |   ),
24 | }));
25 | 
26 | vi.mock('@/components/ideamap/components/IdeaMap', () => ({
27 |   default: ({ onSelectCard, className, showControls }: any) => (
28 |     <div
29 |       data-testid="ideamap-component"
30 |       data-selectcard={!!onSelectCard}
31 |       data-classname={className}
32 |       data-showcontrols={showControls}
33 |     >
34 |       IdeaMap Component
35 |     </div>
36 |   ),
37 | }));
38 | 
39 | describe('MainCanvas', () => {
40 |   it('renders ReactFlowProvider and IdeaMap component with correct props', () => {
41 |     render(<MainCanvas />);
42 | 
43 |     // ReactFlowProvider가 렌더링되었는지 확인
44 |     expect(screen.getByTestId('react-flow-provider')).toBeInTheDocument();
45 | 
46 |     // IdeaMap 컴포넌트가 렌더링되었는지 확인
47 |     const ideaMapComponent = screen.getByTestId('ideamap-component');
48 |     expect(ideaMapComponent).toBeInTheDocument();
49 | 
50 |     // IdeaMap 컴포넌트에 올바른 props가 전달되었는지 확인
51 |     expect(ideaMapComponent.getAttribute('data-selectcard')).toBe('true');
52 |     expect(ideaMapComponent.getAttribute('data-classname')).toBe('bg-background');
53 |     expect(ideaMapComponent.getAttribute('data-showcontrols')).toBe('true');
54 |   });
55 | }); 
```

src/components/layout/MainCanvas.tsx
```
1 | 'use client';
2 | 
3 | import { ReactFlowProvider } from '@xyflow/react';
4 | import { Loader2 } from 'lucide-react';
5 | 
6 | import Board from '@/components/ideamap/components/IdeaMap';
7 | import { useAppStore } from '@/store/useAppStore';
8 | 
9 | // 외부 내보내기 컴포넌트
10 | export function MainCanvas() {
11 |   const { selectCard } = useAppStore();
12 | 
13 |   return (
14 |     <ReactFlowProvider>
15 |       <div className="w-full h-full pt-14">
16 |         <Board
17 |           onSelectCard={selectCard}
18 |           className="bg-background"
19 |           showControls={true}
20 |         />
21 |       </div>
22 |     </ReactFlowProvider>
23 |   );
24 | } 
```

src/components/layout/MainToolbar.test.tsx
```
1 | /**
2 |  * 파일명: MainToolbar.test.tsx
3 |  * 목적: MainToolbar 컴포넌트 테스트
4 |  * 역할: 레이아웃 컨트롤러 컴포넌트 유닛 테스트
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2025-04-08
7 |  * 수정일: 2025-04-10 : Zustand store 모킹 방식 리팩토링에 맞게 수정
8 |  */
9 | 
10 | import React from 'react';
11 | 
12 | import { render, screen, fireEvent } from '@testing-library/react';
13 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
14 | 
15 | import { MainToolbar } from './MainToolbar';
16 | 
17 | 
18 | // 모킹된 함수 참조를 테스트 내에서 가져오기 위한 변수
19 | const mockApplyLayout = vi.fn();
20 | const mockSaveBoardLayout = vi.fn();
21 | 
22 | // useAppStore 모킹
23 | vi.mock('@/store/useAppStore', () => ({
24 |     useAppStore: (selector?: (state: any) => any) => {
25 |         const mockStoreValues = {
26 |             applyLayout: mockApplyLayout,
27 |             saveBoardLayout: mockSaveBoardLayout,
28 |             layoutDirection: 'auto'
29 |         };
30 | 
31 |         return selector ? selector(mockStoreValues) : mockStoreValues;
32 |     }
33 | }));
34 | 
35 | // CreateCardModal 모킹
36 | vi.mock('@/components/cards/CreateCardModal', () => ({
37 |     default: ({ customTrigger }: { customTrigger: React.ReactNode }) => (
38 |         <div data-testid="mock-create-card-modal">
39 |             {customTrigger}
40 |         </div>
41 |     )
42 | }));
43 | 
44 | // window.location.reload 모킹
45 | const mockReload = vi.fn();
46 | Object.defineProperty(window, 'location', {
47 |     value: { reload: mockReload },
48 |     writable: true
49 | });
50 | 
51 | describe('MainToolbar', () => {
52 |     beforeEach(() => {
53 |         // 각 테스트 전 모킹 초기화
54 |         vi.clearAllMocks();
55 |         vi.useFakeTimers();
56 |     });
57 | 
58 |     afterEach(() => {
59 |         vi.useRealTimers();
60 |     });
61 | 
62 |     it('수평 정렬 버튼 클릭 시 applyLayout을 "horizontal" 인자와 함께 호출해야 함', () => {
63 |         // 컴포넌트 렌더링
64 |         render(<MainToolbar />);
65 | 
66 |         // 수평 정렬 버튼 찾기
67 |         const horizontalButton = screen.getByTitle('수평 정렬');
68 | 
69 |         // 버튼 클릭 (fireEvent 사용)
70 |         fireEvent.click(horizontalButton);
71 | 
72 |         // applyLayout이 'horizontal' 인자와 함께 호출되었는지 확인
73 |         expect(mockApplyLayout).toHaveBeenCalledWith('horizontal');
74 |     });
75 | 
76 |     it('수직 정렬 버튼 클릭 시 applyLayout을 "vertical" 인자와 함께 호출해야 함', () => {
77 |         // 컴포넌트 렌더링
78 |         render(<MainToolbar />);
79 | 
80 |         // 수직 정렬 버튼 찾기
81 |         const verticalButton = screen.getByTitle('수직 정렬');
82 | 
83 |         // 버튼 클릭 (fireEvent 사용)
84 |         fireEvent.click(verticalButton);
85 | 
86 |         // applyLayout이 'vertical' 인자와 함께 호출되었는지 확인
87 |         expect(mockApplyLayout).toHaveBeenCalledWith('vertical');
88 |     });
89 | 
90 |     it('자동 배치 버튼 클릭 시 applyLayout을 "auto" 인자와 함께 호출해야 함', () => {
[TRUNCATED]
```

src/components/layout/MainToolbar.tsx
```
1 | 'use client';
2 | 
3 | import {
4 |   AlignHorizontalJustifyCenter,
5 |   AlignVerticalJustifyCenter,
6 |   PlusCircle,
7 |   Save
8 | } from 'lucide-react';
9 | 
10 | import CreateCardModal from '@/components/cards/CreateCardModal';
11 | import { Button } from '@/components/ui/button';
12 | import { useAppStore } from '@/store/useAppStore';
13 | 
14 | export function MainToolbar() {
15 |   const {
16 |     applyLayout,
17 |     saveBoardLayout: saveIdeaMapLayout,
18 |     layoutDirection
19 |   } = useAppStore();
20 | 
21 |   return (
22 |     <div className="fixed bottom-3 left-1/2 transform -translate-x-1/2 flex items-center bg-background/80 backdrop-blur-sm rounded-lg shadow-md border p-1 px-2 z-10">
23 |       <CreateCardModal
24 |         customTrigger={
25 |           <Button
26 |             variant="ghost"
27 |             size="icon"
28 |             title="새 카드 추가"
29 |             className="rounded-full h-[60px] w-[60px]"
30 |           >
31 |             <PlusCircle className="h-8 w-8" />
32 |             <span className="sr-only">새 카드 추가</span>
33 |           </Button>
34 |         }
35 |       />
36 | 
37 |       <Button
38 |         variant="ghost"
39 |         size="icon"
40 |         title="수평 정렬"
41 |         className="rounded-full h-[60px] w-[60px]"
42 |         onClick={() => applyLayout('horizontal')}
43 |       >
44 |         <AlignHorizontalJustifyCenter className="h-8 w-8" />
45 |         <span className="sr-only">수평 정렬</span>
46 |       </Button>
47 | 
48 |       <Button
49 |         variant="ghost"
50 |         size="icon"
51 |         title="수직 정렬"
52 |         className="rounded-full h-[60px] w-[60px]"
53 |         onClick={() => applyLayout('vertical')}
54 |       >
55 |         <AlignVerticalJustifyCenter className="h-8 w-8" />
56 |         <span className="sr-only">수직 정렬</span>
57 |       </Button>
58 | 
59 |       <Button
60 |         variant="ghost"
61 |         size="icon"
62 |         title="자동 배치"
63 |         className="rounded-full h-[60px] w-[60px]"
64 |         onClick={() => applyLayout('auto')}
65 |       >
66 |         <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
67 |           <path d="M21 9L17 9M21 15H11M7 15H3M3 9L13 9M17 15L21 15M7 9H3" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
68 |           <path d="M17 21V17M17 7V3M7 3V7M7 21V17" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
69 |           <circle cx="17" cy="9" r="2" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
70 |           <circle cx="7" cy="15" r="2" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
71 |         </svg>
72 |         <span className="sr-only">자동 배치</span>
73 |       </Button>
74 | 
[TRUNCATED]
```

src/components/layout/ProjectToolbar.test.tsx
```
1 | /**
2 |  * 파일명: ProjectToolbar.test.tsx
3 |  * 목적: ProjectToolbar 컴포넌트 테스트
4 |  * 역할: 프로젝트 설정 및 컨트롤 기능을 검증하는 테스트
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2025-04-10 : global-env-mocking.mdc 룰 적용하여 console 모킹 방식 개선
7 |  * 수정일: 2025-04-12 : Zustand 액션 기반 리팩토링에 맞게 테스트 수정
8 |  * 수정일: 2025-04-15 : React Flow 모킹 추가 및 테스트 안정성 개선
9 |  * 수정일: 2025-04-15 : navigator.clipboard 모킹 및 타임아웃 설정 추가
10 |  * 수정일: 2025-04-17 : import 순서 정렬 (린트 오류 수정)
11 |  */
12 | 
13 | // 먼저 React 및 핵심 라이브러리
14 | import React from 'react';
15 | 
16 | import { render, screen, cleanup } from '@testing-library/react';
17 | import { ConnectionLineType, MarkerType } from '@xyflow/react';
18 | import { describe, it, expect, beforeEach, afterEach, beforeAll, afterAll, vi } from 'vitest';
19 | 
20 | import '@testing-library/jest-dom';
21 | 
22 | // 내부 모듈 및 Utilities
23 | import { useAppStore } from '@/store/useAppStore';
24 | import { server } from '@/tests/msw/server';
25 | import { mockReactFlow } from '@/tests/utils/react-flow-mock';
26 | 
27 | // ProjectToolbar 컴포넌트 임포트
28 | import { ProjectToolbar } from './ProjectToolbar';
29 | 
30 | // React Flow 모킹 먼저 호출
31 | mockReactFlow();
32 | 
33 | // console.log 모킹 (vi.stubGlobal 사용)
34 | // 원래의 console 객체 저장하지 않아도 됨 (vi.unstubAllGlobals로 자동 복원)
35 | // vi.stubGlobal을 통해 환경 자체를 모킹하는 방식으로 변경
36 | const mockConsole = {
37 |     log: vi.fn(),
38 |     error: vi.fn(),
39 |     warn: vi.fn(),
40 |     info: vi.fn(),
41 |     debug: vi.fn()
42 | };
43 | // 모든 console 메서드 유지하면서 log와 error만 모킹
44 | vi.stubGlobal('console', {
45 |     ...console as Console,
46 |     log: mockConsole.log,
47 |     error: mockConsole.error
48 | });
49 | 
50 | // 브라우저 환경 모킹 (window 객체)
51 | vi.stubGlobal('window', {
52 |     ...window,
53 |     localStorage: {
54 |         getItem: vi.fn(),
55 |         setItem: vi.fn(),
56 |         removeItem: vi.fn()
57 |     }
58 | });
59 | 
60 | // navigator.clipboard 모킹
61 | vi.stubGlobal('navigator', {
62 |     clipboard: {
63 |         writeText: vi.fn().mockResolvedValue(undefined),
64 |         readText: vi.fn().mockResolvedValue('')
65 |     }
66 | });
67 | 
68 | // 모든 모킹은 import 문 전에
69 | vi.mock('@/lib/ideamap-constants', () => ({
70 |     SNAP_GRID_OPTIONS: [
71 |         { value: '0', label: 'Off' },
72 |         { value: '15', label: '15px' }
73 |     ],
74 |     CONNECTION_TYPE_OPTIONS: [
75 |         { value: 'bezier', label: 'Bezier' },
76 |         { value: 'straight', label: 'Straight' }
77 |     ],
78 |     MARKER_TYPE_OPTIONS: [
79 |         { value: 'arrow', label: 'Arrow' },
[TRUNCATED]
```

src/components/layout/ProjectToolbar.tsx
```
1 | 'use client';
2 | 
3 | import React, { useCallback, useEffect } from 'react';
4 | 
5 | import { ConnectionLineType, MarkerType } from '@xyflow/react';
6 | import {
7 |   Menu,
8 |   // ChevronRight,
9 |   // Palette,
10 |   Grid3X3,
11 |   // ChevronsUpDown,
12 |   // AlignHorizontalJustifyCenter,
13 |   // AlignVerticalJustifyCenter,
14 |   // LayoutGrid,
15 |   Save,
16 |   Settings,
17 |   ArrowRightIcon,
18 |   Circle,
19 |   SeparatorHorizontal,
20 |   Paintbrush,
21 |   // Layout,
22 |   LogOut,
23 |   FileText,
24 |   FolderOpen
25 | } from 'lucide-react';
26 | import { toast } from 'sonner';
27 | 
28 | import { Button } from '@/components/ui/button';
29 | import {
30 |   DropdownMenu,
31 |   DropdownMenuContent,
32 |   DropdownMenuItem,
33 |   DropdownMenuTrigger,
34 |   DropdownMenuSub,
35 |   DropdownMenuSubTrigger,
36 |   DropdownMenuSubContent,
37 |   DropdownMenuPortal,
38 |   DropdownMenuSeparator,
39 |   DropdownMenuRadioGroup,
40 |   DropdownMenuRadioItem,
41 |   DropdownMenuCheckboxItem,
42 |   DropdownMenuLabel
43 | } from '@/components/ui/dropdown-menu';
44 | import {
45 |   SNAP_GRID_OPTIONS,
46 |   CONNECTION_TYPE_OPTIONS,
47 |   MARKER_TYPE_OPTIONS,
48 |   STROKE_WIDTH_OPTIONS,
49 |   MARKER_SIZE_OPTIONS,
50 |   EDGE_COLOR_OPTIONS,
51 |   EDGE_ANIMATION_OPTIONS
52 | } from '@/lib/ideamap-constants';
53 | // import {
54 | //   IDEAMAP_LAYOUT_STORAGE_KEY,
55 | //   IDEAMAP_EDGES_STORAGE_KEY,
56 | //   IDEAMAP_TRANSFORM_STORAGE_KEY
57 | // } from '@/lib/ideamap-constants';
58 | // import { IdeaMapSettings } from '@/lib/ideamap-utils';
59 | import createLogger from '@/lib/logger';
60 | import { useAppStore, selectActiveProject, Project } from '@/store/useAppStore';
61 | 
62 | // 모듈별 로거 생성
63 | const logger = createLogger('ProjectToolbar');
64 | 
65 | export function ProjectToolbar() {
66 |   // useAppStore에서 프로젝트 정보와 액션을 가져옴
67 |   const {
68 |     // layoutDirection,
69 |     // setLayoutDirection,
70 |     // rename board -> ideaMap
71 |     ideaMapSettings,
72 |     updateIdeaMapSettings,
73 |     saveIdeaMapLayout,
74 |     logoutAction,
75 |     projects,
76 |     // activeProjectId,
77 |     fetchProjects,
78 |     createProject,
79 |     // setActiveProject
80 |   } = useAppStore();
81 | 
82 |   // 활성 프로젝트 정보 가져오기
83 |   const activeProject = useAppStore(selectActiveProject);
84 | 
85 |   // 프로젝트 이름과 작성자 정보 표시
86 |   const displayProjectName = activeProject
87 |     ? (activeProject.ownerNickname
88 |       ? `${activeProject.name} - ${activeProject.ownerNickname}`
89 |       : activeProject.name)
90 |     : '프로젝트를 선택하세요';
91 | 
92 |   // 저장 핸들러
93 |   const handleSaveLayout = useCallback(() => {
94 |     // saveIdeaMapLayout 액션을 호출하여 레이아웃 저장 처리
95 |     saveIdeaMapLayout();
96 |   }, [saveIdeaMapLayout]);
97 | 
98 |   // 프로젝트 정보 표시 핸들러
99 |   const handleShowProjectInfo = useCallback(() => {
100 |     if (activeProject) {
101 |       toast.info(`프로젝트 정보: ${activeProject.name} (ID: ${activeProject.id})`);
102 |     } else {
103 |       toast.info('선택된 프로젝트가 없습니다.');
104 |     }
105 |     // TODO: 프로젝트 정보 모달 표시
[TRUNCATED]
```

src/components/layout/ProtectedLayout.tsx
```
1 | /**
2 |  * 파일명: src/components/layout/ProtectedLayout.tsx
3 |  * 목적: 인증된 사용자만 접근할 수 있는 레이아웃 제공
4 |  * 역할: 인증 상태 확인 및 비인증 사용자 리디렉션 처리
5 |  * 작성일: 2024-05-08
6 |  * 수정일: 2024-05-08 : 하이드레이션 오류 해결을 위한 수정
7 |  */
8 | 
9 | 'use client';
10 | 
11 | import { useEffect, useState } from 'react';
12 | 
13 | import { useRouter } from 'next/navigation';
14 | 
15 | import { useAuth } from '@/contexts/AuthContext';
16 | import createLogger from '@/lib/logger';
17 | 
18 | // 로거 생성
19 | const logger = createLogger('ProtectedLayout');
20 | 
21 | /**
22 |  * ProtectedLayout: 인증된 사용자만 접근할 수 있는 레이아웃 컴포넌트
23 |  * @param children - 자식 컴포넌트
24 |  * @returns 보호된 레이아웃 컴포넌트
25 |  */
26 | export function ProtectedLayout({ children }: { children: React.ReactNode }) {
27 |     const { user, isLoading } = useAuth();
28 |     const router = useRouter();
29 |     // 클라이언트 측 상태를 추가하여 하이드레이션 이후에만 UI 변경
30 |     const [isMounted, setIsMounted] = useState(false);
31 | 
32 |     useEffect(() => {
33 |         // 클라이언트 측에서 마운트된 후에만 상태 변경
34 |         setIsMounted(true);
35 | 
36 |         logger.info('보호된 레이아웃 상태', { isLoading, isAuthenticated: !!user });
37 | 
38 |         // 인증 상태 로딩이 완료되고, 사용자가 없으면 로그인 페이지로 리디렉션
39 |         if (!isLoading && !user) {
40 |             logger.info('인증되지 않은 사용자, 로그인 페이지로 리디렉션');
41 |             router.push('/login');
42 |         }
43 |     }, [user, isLoading, router]);
44 | 
45 |     // 처음 서버 렌더링 시에는 항상 children을 렌더링하여 하이드레이션 오류 방지
46 |     if (!isMounted) {
47 |         return <>{children}</>;
48 |     }
49 | 
50 |     // 클라이언트에서 마운트된 후에만 로딩 UI 또는 리디렉션 UI 표시
51 |     if (isLoading) {
52 |         return (
53 |             <div className="flex justify-center items-center min-h-screen">
54 |                 <div className="flex flex-col items-center">
55 |                     <div className="mb-4">
56 |                         <div className="animate-spin h-8 w-8 border-4 border-blue-500 rounded-full border-t-transparent"></div>
57 |                     </div>
58 |                     <p className="text-gray-600">인증 상태 확인 중...</p>
59 |                 </div>
60 |             </div>
61 |         );
62 |     }
63 | 
64 |     // 사용자가 인증되었을 때만 자식 컴포넌트 렌더링
65 |     if (user) {
66 |         return <>{children}</>;
67 |     }
68 | 
69 |     // 리디렉션이 발생하기 전 빈 UI 표시 (깜빡임 방지)
70 |     return (
71 |         <div className="flex justify-center items-center min-h-screen">
72 |             <div className="flex flex-col items-center">
73 |                 <div className="mb-4">
[TRUNCATED]
```

src/components/layout/PublicOnlyLayout.tsx
```
1 | /**
2 |  * 파일명: src/components/layout/PublicOnlyLayout.tsx
3 |  * 목적: 로그인, 회원가입 등 공개 페이지 전용 레이아웃 제공
4 |  * 역할: 이미 인증된 사용자를 홈으로 리디렉션
5 |  * 작성일: 2024-05-08
6 |  * 수정일: 2024-05-08 : 하이드레이션 오류 해결을 위한 수정
7 |  */
8 | 
9 | 'use client';
10 | 
11 | import { useEffect, useState } from 'react';
12 | 
13 | import { useRouter } from 'next/navigation';
14 | 
15 | import { useAuth } from '@/contexts/AuthContext';
16 | import createLogger from '@/lib/logger';
17 | 
18 | // 로거 생성
19 | const logger = createLogger('PublicOnlyLayout');
20 | 
21 | /**
22 |  * PublicOnlyLayout: 인증되지 않은 사용자만 접근할 수 있는 레이아웃 컴포넌트
23 |  * @param children - 자식 컴포넌트
24 |  * @returns 공개 전용 레이아웃 컴포넌트
25 |  */
26 | export function PublicOnlyLayout({ children }: { children: React.ReactNode }) {
27 |     const { user, isLoading } = useAuth();
28 |     const router = useRouter();
29 |     // 클라이언트 측 상태를 추가하여 하이드레이션 이후에만 UI 변경
30 |     const [isMounted, setIsMounted] = useState(false);
31 | 
32 |     useEffect(() => {
33 |         // 클라이언트 측에서 마운트된 후에만 상태 변경
34 |         setIsMounted(true);
35 | 
36 |         logger.info('공개 전용 레이아웃 상태', { isLoading, isAuthenticated: !!user });
37 | 
38 |         // 인증 상태 로딩이 완료되고, 사용자가 있으면 홈으로 리디렉션
39 |         if (!isLoading && user) {
40 |             logger.info('이미 인증된 사용자, 홈으로 리디렉션');
41 |             router.push('/');
42 |         }
43 |     }, [user, isLoading, router]);
44 | 
45 |     // 처음 서버 렌더링 시에는 항상 children을 렌더링하여 하이드레이션 오류 방지
46 |     if (!isMounted) {
47 |         return <>{children}</>;
48 |     }
49 | 
50 |     // 클라이언트에서 마운트된 후에만 로딩 UI 또는 리디렉션 UI 표시
51 |     if (isLoading) {
52 |         return (
53 |             <div className="flex justify-center items-center min-h-screen">
54 |                 <div className="flex flex-col items-center">
55 |                     <div className="mb-4">
56 |                         <div className="animate-spin h-8 w-8 border-4 border-blue-500 rounded-full border-t-transparent"></div>
57 |                     </div>
58 |                     <p className="text-gray-600">인증 상태 확인 중...</p>
59 |                 </div>
60 |             </div>
61 |         );
62 |     }
63 | 
64 |     // 사용자가 인증되지 않았을 때만 자식 컴포넌트 렌더링
65 |     if (!user) {
66 |         return <>{children}</>;
67 |     }
68 | 
69 |     // 리디렉션이 발생하기 전 빈 UI 표시 (깜빡임 방지)
70 |     return (
71 |         <div className="flex justify-center items-center min-h-screen">
72 |             <div className="flex flex-col items-center">
73 |                 <div className="mb-4">
[TRUNCATED]
```

src/components/layout/ShortcutToolbar.test.tsx
```
1 | /**
2 |  * 파일명: ShortcutToolbar.test.tsx
3 |  * 목적: ShortcutToolbar 컴포넌트의 기능 테스트
4 |  * 역할: 단축 기능 툴바의 모든 기능이 정상적으로 동작하는지 검증
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2025-04-03
7 |  */
8 | 
9 | import { render, screen, fireEvent } from '@testing-library/react';
10 | import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
11 | 
12 | import { ShortcutToolbarMock } from './ShortcutToolbarMock';
13 | import { setupShortcutToolbarTests, teardownShortcutToolbarTests, mockActions } from './test-utils';
14 | import '@testing-library/jest-dom';
15 | 
16 | // 성공 케이스와 실패 케이스 시나리오를 위한 함수 생성
17 | const createSuccessSignOutMock = () => {
18 |     return vi.fn().mockResolvedValue(undefined);
19 | };
20 | 
21 | const createFailureSignOutMock = () => {
22 |     return vi.fn().mockRejectedValue(new Error('로그아웃 실패'));
23 | };
24 | 
25 | describe('ShortcutToolbar', () => {
26 |     beforeEach(() => {
27 |         setupShortcutToolbarTests();
28 |         vi.clearAllMocks();
29 |     });
30 | 
31 |     afterEach(() => {
32 |         teardownShortcutToolbarTests();
33 |     });
34 | 
35 |     describe('@testcase.mdc ShortcutToolbar 기본 기능', () => {
36 |         it('rule: 모든 기본 버튼이 렌더링되어야 함', () => {
37 |             render(<ShortcutToolbarMock />);
38 | 
39 |             expect(screen.getByTitle('사이드바 접기')).toBeInTheDocument();
40 |             expect(screen.getByTitle('로그아웃')).toBeInTheDocument();
41 |         });
42 | 
43 |         it('rule: 사이드바 접기 버튼 클릭 시 toggleSidebar 액션이 호출되어야 함', () => {
44 |             render(<ShortcutToolbarMock />);
45 | 
46 |             fireEvent.click(screen.getByTitle('사이드바 접기'));
47 |             expect(mockActions.toggleSidebar).toHaveBeenCalled();
48 |         });
49 |     });
50 | 
51 |     describe('@testcase.mdc 로그아웃 기능', () => {
52 |         it('rule: 로그아웃 버튼 클릭 시 signOut 함수가 호출되어야 함', () => {
53 |             // 성공 케이스 설정
54 |             mockActions.signOut = createSuccessSignOutMock();
55 | 
56 |             render(<ShortcutToolbarMock />);
57 |             fireEvent.click(screen.getByTitle('로그아웃'));
58 | 
59 |             expect(mockActions.signOut).toHaveBeenCalled();
60 |             expect(mockActions.toast.success).not.toHaveBeenCalled(); // 비동기 호출 전에는 호출되지 않아야 함
61 |         });
62 | 
63 |         it('rule: 로그아웃 성공 시 성공 메시지가 표시되어야 함', async () => {
64 |             // 성공 케이스 설정
65 |             mockActions.signOut = createSuccessSignOutMock();
66 | 
67 |             // 컴포넌트 렌더링 및 클릭 대신 signOut 함수 직접 호출하고 결과 확인
68 |             await mockActions.signOut()
69 |                 .then(() => {
70 |                     mockActions.toast.success('로그아웃되었습니다.');
71 |                     expect(mockActions.toast.success).toHaveBeenCalledWith('로그아웃되었습니다.');
72 |                 })
73 |                 .catch(() => {
74 |                     // 여기에 도달하지 않아야 함
75 |                     expect(true).toBe(false);
76 |                 });
77 |         });
78 | 
79 |         it('rule: 로그아웃 실패 시 에러 메시지가 표시되어야 함', async () => {
80 |             // 실패 케이스 설정
81 |             mockActions.signOut = createFailureSignOutMock();
82 | 
83 |             // 실패하는 함수 핸들러 직접 호출 및 결과 확인
84 |             try {
[TRUNCATED]
```

src/components/layout/ShortcutToolbar.tsx
```
1 | 'use client';
2 | 
3 | import { LogOut, PanelRight } from 'lucide-react';
4 | 
5 | import { Button } from '@/components/ui/button';
6 | import { useAppStore } from '@/store/useAppStore';
7 | 
8 | export function ShortcutToolbar() {
9 |   const { toggleSidebar } = useAppStore();
10 | 
11 |   return (
12 |     <div className="fixed top-3 right-3 flex items-center gap-1 bg-background/80 backdrop-blur-sm rounded-lg shadow-md border p-1 px-2 z-10">
13 |       {/* 사이드바 접기 */}
14 |       <Button
15 |         variant="ghost"
16 |         size="icon"
17 |         className="rounded-full"
18 |         onClick={toggleSidebar}
19 |         title="사이드바 접기"
20 |       >
21 |         <PanelRight className="h-5 w-5" />
22 |         <span className="sr-only">사이드바 접기</span>
23 |       </Button>
24 | 
25 |       {/* 로그아웃 버튼 */}
26 |       <Button
27 |         variant="ghost"
28 |         size="icon"
29 |         className="rounded-full"
30 |         title="로그아웃"
31 |       >
32 |         <LogOut className="h-5 w-5" />
33 |         <span className="sr-only">로그아웃</span>
34 |       </Button>
35 |     </div>
36 |   );
37 | } 
```

src/components/layout/ShortcutToolbarMock.tsx
```
1 | /**
2 |  * 파일명: ShortcutToolbarMock.tsx
3 |  * 목적: ShortcutToolbar 테스트를 위한 모킹 컴포넌트
4 |  * 역할: 실제 컴포넌트의 동작을 시뮬레이션
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2025-04-03
7 |  */
8 | 
9 | import React from 'react';
10 | 
11 | import { mockActions } from './test-utils';
12 | 
13 | export const ShortcutToolbarMock: React.FC = () => {
14 |     const handleLogout = () => {
15 |         // Promise 체인 사용하여 분명한 흐름 제공
16 |         mockActions.signOut()
17 |             .then(() => {
18 |                 mockActions.toast.success('로그아웃되었습니다.');
19 |             })
20 |             .catch(() => {
21 |                 mockActions.toast.error('로그아웃 중 문제가 발생했습니다.');
22 |             });
23 |     };
24 | 
25 |     return (
26 |         <div>
27 |             <button title="사이드바 접기" onClick={() => mockActions.toggleSidebar()}>
28 |                 사이드바 접기
29 |             </button>
30 |             <button title="로그아웃" onClick={handleLogout}>
31 |                 로그아웃
32 |             </button>
33 |         </div>
34 |     );
35 | }; 
```

src/components/layout/Sidebar.tsx
```
1 | 'use client';
2 | 
3 | import { useEffect, useState, useRef, useMemo } from 'react';
4 | 
5 | import { useRouter } from 'next/navigation';
6 | 
7 | import { motion, AnimatePresence } from 'framer-motion';
8 | import { ChevronRight, Trash2, GripVertical, Pencil } from 'lucide-react';
9 | import { toast } from 'sonner';
10 | 
11 | // import CardList from '@/components/cards/CardList';
12 | import { EditCardModal } from '@/components/cards/EditCardModal';
13 | import DocumentViewer from '@/components/editor/DocumentViewer';
14 | import TiptapViewer from '@/components/editor/TiptapViewer';
15 | // import { Badge } from '@/components/ui/badge';
16 | import { Button } from '@/components/ui/button';
17 | import {
18 |   Dialog,
19 |   DialogContent,
20 |   DialogHeader,
21 |   DialogTitle,
22 |   DialogDescription,
23 |   DialogFooter,
24 |   // DialogTrigger,
25 |   DialogClose,
26 | } from '@/components/ui/dialog';
27 | import { Portal } from '@/components/ui/portal';
28 | import { useAuth } from '@/contexts/AuthContext';
29 | import { useResizable } from '@/hooks/useResizable';
30 | import { cn } from '@/lib/utils';
31 | import { formatDate } from '@/lib/utils';
32 | import { useAppStore } from '@/store/useAppStore';
33 | import { useIdeaMapStore } from '@/store/useIdeaMapStore';
34 | import type { Card } from '@/types/card';
35 | 
36 | 
37 | // 카드 인터페이스 정의
38 | interface Tag {
39 |   id: string;
40 |   name: string;
41 | }
42 | 
43 | interface CardTag {
44 |   id: string;
45 |   tag: Tag;
46 | }
47 | 
48 | interface CardItem extends Card {
49 |   cardTags?: CardTag[];
50 |   // 엣지 정보를 통해 계층 구조 파악을 위한 필드
51 |   parents?: string[];
52 |   children?: string[];
53 |   depth?: number;
54 | }
55 | 
56 | interface SidebarProps {
57 |   className?: string;
58 | }
59 | 
60 | export function Sidebar({ className }: SidebarProps) {
61 |   // const router = useRouter();
62 |   const {
63 |     isSidebarOpen,
64 |     setSidebarOpen,
65 |     selectedCardId,
66 |     selectedCardIds,
67 |     selectCard,
68 |     sidebarWidth,
69 |     setSidebarWidth,
70 |     reactFlowInstance,
71 |     cards
72 |   } = useAppStore();
73 | 
74 |   const auth = useAuth();
75 | 
76 |   // useIdeaMapStore에서 노드 데이터 가져오기
77 |   // const ideaMapNodes = useIdeaMapStore(state => state.nodes);
78 | 
79 |   // 전역 상태의 cards를 CardItem 타입으로 캐스팅하여 사용
80 |   // const cardsWithType = cards as CardItem[];
81 | 
82 |   const [selectedCard, setSelectedCard] = useState<CardItem | null>(null);
83 |   const [selectedCards, setSelectedCards] = useState<CardItem[]>([]);
84 |   const [loading, setLoading] = useState(false);
85 |   const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
86 |   const [deletingCardId, setDeletingCardId] = useState<string | null>(null);
87 |   const [isDeleting, setIsDeleting] = useState(false);
88 |   // 카드 정보 로드 상태 - Hook 순서 문제 해결을 위해 여기로 이동
[TRUNCATED]
```

src/components/layout/test-utils.ts
```
1 | /**
2 |  * 파일명: test-utils.ts
3 |  * 목적: 레이아웃 컴포넌트 테스트를 위한 유틸리티 함수 및 모킹 객체 제공
4 |  * 역할: 테스트 설정, 정리, 모킹된 액션 제공
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2025-04-03
7 |  */
8 | 
9 | import { toast } from 'sonner';
10 | import { vi } from 'vitest';
11 | 
12 | // 모킹된 액션들
13 | export const mockActions = {
14 |   // MainToolbar 액션
15 |   applyLayout: vi.fn(),
16 |   createCard: vi.fn(() => Promise.resolve({ id: 'new-card-id' })),
17 |   updateBoardSettings: vi.fn(() => Promise.resolve()),
18 | 
19 |   // ShortcutToolbar 액션
20 |   toggleSidebar: vi.fn(),
21 |   // Promise를 명시적으로 반환하는 모킹 함수
22 |   signOut: vi.fn().mockImplementation(() => Promise.resolve()),
23 |   toast: {
24 |     success: vi.fn(),
25 |     error: vi.fn(),
26 |   },
27 | };
28 | 
29 | /**
30 |  * setupMainToolbarTests: MainToolbar 테스트를 위한 환경을 설정
31 |  */
32 | export const setupMainToolbarTests = () => {
33 |   // 모든 모킹된 함수 초기화
34 |   vi.clearAllMocks();
35 | 
36 |   // Sonner 토스트 모킹
37 |   vi.mock('sonner', () => ({
38 |     toast: {
39 |       success: vi.fn(),
40 |       error: vi.fn(),
41 |     },
42 |   }));
43 | };
44 | 
45 | /**
46 |  * setupShortcutToolbarTests: ShortcutToolbar 테스트를 위한 환경을 설정
47 |  */
48 | export const setupShortcutToolbarTests = () => {
49 |   // 모든 모킹된 함수 초기화
50 |   vi.clearAllMocks();
51 | 
52 |   // Sonner 토스트 모킹
53 |   vi.mock('sonner', () => ({
54 |     toast: {
55 |       success: vi.fn(),
56 |       error: vi.fn(),
57 |     },
58 |   }));
59 | };
60 | 
61 | /**
62 |  * teardownMainToolbarTests: 테스트 후 정리 작업 수행
63 |  */
64 | export const teardownMainToolbarTests = () => {
65 |   vi.clearAllMocks();
66 |   vi.resetModules();
67 | };
68 | 
69 | /**
70 |  * teardownShortcutToolbarTests: 테스트 후 정리 작업 수행
71 |  */
72 | export const teardownShortcutToolbarTests = () => {
73 |   vi.clearAllMocks();
74 |   vi.resetModules();
75 | }; 
```

src/components/login/loginForm.tsx
```
1 | /**
2 |  * 파일명: src/components/login/loginForm.tsx
3 |  * 목적: 사용자 로그인 UI 컴포넌트 제공
4 |  * 역할: 이메일/비밀번호 로그인 및 Google 소셜 로그인 폼 제공
5 |  * 작성일: 2024-06-28
6 |  * 수정일: 2024-05-30 : 서버 액션 및 상태 관리 연동 추가
7 |  */
8 | 
9 | "use client"
10 | 
11 | import React, { useState, useEffect } from 'react'
12 | 
13 | import Link from "next/link"
14 | import { useSearchParams } from 'next/navigation' // 에러/메시지 표시 위해 추가
15 | 
16 | import { ArrowRight, Mail, Lock } from "lucide-react"
17 | 
18 | import { login, signInWithGoogle } from '@/app/login/actions' // 서버 액션 import
19 | import { Button } from "@/components/ui/button"
20 | import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
21 | import { Input } from "@/components/ui/input"
22 | import { Label } from "@/components/ui/label"
23 | import { Separator } from "@/components/ui/separator"
24 | 
25 | export default function LoginForm() {
26 |     const [email, setEmail] = useState('');
27 |     const [password, setPassword] = useState('');
28 |     const [isEmailPending, setIsEmailPending] = useState(false); // 이메일 로그인 로딩
29 |     const [isGooglePending, setIsGooglePending] = useState(false); // Google 로그인 로딩
30 |     const searchParams = useSearchParams();
31 |     const [error, setError] = useState<string | null>(null);
32 |     const [message, setMessage] = useState<string | null>(null);
33 | 
34 |     useEffect(() => {
35 |         const errorParam = searchParams.get('error');
36 |         const messageParam = searchParams.get('message');
37 |         if (errorParam) setError(decodeURIComponent(errorParam));
38 |         if (messageParam) setMessage(decodeURIComponent(messageParam));
39 |     }, [searchParams]);
40 | 
41 |     const handleEmailLogin = async (event: React.FormEvent<HTMLFormElement> | React.MouseEvent<HTMLButtonElement>) => {
42 |         event.preventDefault();
43 |         setError(null);
44 |         setMessage(null);
45 |         setIsEmailPending(true);
46 |         const formData = new FormData();
47 |         formData.append('email', email);
48 |         formData.append('password', password);
49 |         try {
50 |             await login(formData);
51 |         } catch (err) {
52 |             console.error("Login action failed:", err);
53 |             setError("로그인 처리 중 오류가 발생했습니다.");
54 |         } finally {
55 |             setIsEmailPending(false);
56 |         }
57 |     };
58 | 
59 |     const handleGoogleLogin = async () => {
60 |         setError(null);
61 |         setMessage(null);
62 |         setIsGooglePending(true);
63 |         try {
64 |             await signInWithGoogle();
65 |         } catch (err) {
66 |             console.error("Google Sign in action failed:", err);
67 |             setError("Google 로그인 처리 중 오류가 발생했습니다.");
68 |         }
69 |     };
70 | 
71 |     return (
72 |         <div className="w-full max-w-md p-6 md:p-12">
73 |             <div className="mb-4 text-center">
74 |                 <h1 className="text-3xl font-bold">Backyard</h1>
[TRUNCATED]
```

src/components/settings/NodeSizeSettings.test.tsx
```
1 | /**
2 |  * 파일명: NodeSizeSettings.test.tsx
3 |  * 목적: NodeSizeSettings 컴포넌트 테스트
4 |  * 역할: 노드 크기 설정 컴포넌트 검증
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | import React from 'react';
9 | 
10 | import { render, screen, fireEvent } from '@testing-library/react';
11 | import { describe, test, expect, vi, beforeEach } from 'vitest';
12 | import '@testing-library/jest-dom/vitest';
13 | 
14 | // ResizeObserver 모킹
15 | global.ResizeObserver = vi.fn().mockImplementation(() => ({
16 |   observe: vi.fn(),
17 |   unobserve: vi.fn(),
18 |   disconnect: vi.fn(),
19 | }));
20 | 
21 | // updateNodeSize 모킹 함수
22 | const updateNodeSizeMock = vi.fn();
23 | const updateNodeInternalsMock = vi.fn();
24 | 
25 | // ReactFlow 모킹
26 | vi.mock('@xyflow/react', () => {
27 |   return {
28 |     useReactFlow: () => ({
29 |       getNodes: () => [{ id: 'node-1' }, { id: 'node-2' }],
30 |     }),
31 |     useUpdateNodeInternals: () => updateNodeInternalsMock,
32 |     ReactFlowProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
33 |   };
34 | });
35 | 
36 | // ThemeContext 모킹
37 | vi.mock('../../contexts/ThemeContext', () => {
38 |   return {
39 |     ThemeProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
40 |     useTheme: () => ({
41 |       theme: {
42 |         node: {
43 |           width: 220,
44 |           height: 48,
45 |           maxHeight: 180,
46 |           backgroundColor: '#ffffff',
47 |           borderColor: '#C1C1C1',
48 |           borderWidth: 1,
49 |           borderRadius: 8,
50 |           selectedBorderColor: '#0071e3',
51 |           font: {
52 |             family: 'Pretendard, sans-serif',
53 |             titleSize: 14,
54 |             contentSize: 12,
55 |             tagsSize: 10,
56 |           }
57 |         },
58 |         edge: {
59 |           color: '#C1C1C1',
60 |           width: 1,
61 |           selectedColor: '#0071e3',
62 |           animated: false,
63 |         },
64 |         handle: {
65 |           size: 8,
66 |           backgroundColor: '#ffffff',
67 |           borderColor: '#555555',
68 |           borderWidth: 1,
69 |         },
70 |         layout: {
71 |           spacing: {
72 |             horizontal: 30,
73 |             vertical: 30,
74 |           },
75 |           padding: 20,
76 |         },
77 |       },
78 |       updateTheme: vi.fn(),
79 |       updateNodeSize: updateNodeSizeMock,
80 |     }),
81 |   };
82 | });
83 | 
84 | // UI 컴포넌트 모킹
85 | vi.mock('../../components/ui/slider', () => ({
86 |   Slider: ({ id, defaultValue, onValueChange }: any) => (
87 |     <input
88 |       type="range"
89 |       min="0"
90 |       max="500"
91 |       data-testid={`slider-${id}`}
92 |       defaultValue={defaultValue}
93 |       onChange={(e) => onValueChange([parseInt(e.target.value)])}
94 |     />
95 |   ),
96 | }));
97 | 
98 | vi.mock('../../components/ui/input', () => ({
99 |   Input: (props: any) => <input data-testid={props.id || 'input'} {...props} />,
100 | }));
101 | 
[TRUNCATED]
```

src/components/settings/NodeSizeSettings.tsx
```
1 | /**
2 |  * 파일명: NodeSizeSettings.tsx
3 |  * 목적: 노드 크기 설정 컴포넌트 제공
4 |  * 역할: 사용자가 노드 크기를 조정할 수 있는 UI 제공
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | 'use client';
9 | 
10 | import { useState, useEffect } from 'react';
11 | 
12 | import { useReactFlow, useUpdateNodeInternals } from '@xyflow/react';
13 | 
14 | import { Button } from "@/components/ui/button";
15 | import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
16 | import { Input } from "@/components/ui/input";
17 | import { Label } from "@/components/ui/label";
18 | import { Slider } from "@/components/ui/slider";
19 | import { useTheme } from '@/contexts/ThemeContext';
20 | 
21 | 
22 | /**
23 |  * NodeSizeSettings: 노드 크기 조정 컴포넌트
24 |  * @returns 노드 크기 설정 UI 컴포넌트
25 |  */
26 | export function NodeSizeSettings() {
27 |   const { theme, updateNodeSize } = useTheme();
28 |   const { getNodes } = useReactFlow();
29 |   const updateNodeInternals = useUpdateNodeInternals();
30 |   
31 |   const [width, setWidth] = useState(theme.node.width);
32 |   const [height, setHeight] = useState(theme.node.height);
33 |   const [maxHeight, setMaxHeight] = useState(theme.node.maxHeight);
34 |   
35 |   // 입력값이 변경될 때 로컬 상태 업데이트
36 |   const handleWidthChange = (value: number | string) => {
37 |     const numValue = typeof value === 'string' ? parseInt(value, 10) : value;
38 |     if (!isNaN(numValue) && numValue > 0) {
39 |       setWidth(numValue);
40 |     }
41 |   };
42 |   
43 |   const handleHeightChange = (value: number | string) => {
44 |     const numValue = typeof value === 'string' ? parseInt(value, 10) : value;
45 |     if (!isNaN(numValue) && numValue > 0) {
46 |       setHeight(numValue);
47 |     }
48 |   };
49 |   
50 |   const handleMaxHeightChange = (value: number | string) => {
51 |     const numValue = typeof value === 'string' ? parseInt(value, 10) : value;
52 |     if (!isNaN(numValue) && numValue > 0) {
53 |       setMaxHeight(numValue);
54 |     }
55 |   };
56 |   
57 |   // 테마에 변경사항 적용
58 |   const applyChanges = () => {
59 |     // 테마 업데이트
60 |     updateNodeSize(width, height, maxHeight);
61 |     
62 |     // 모든 노드 업데이트 (내부 상태 갱신)
63 |     setTimeout(() => {
64 |       console.log('모든 노드 내부 상태 업데이트');
65 |       getNodes().forEach(node => {
66 |         updateNodeInternals(node.id);
67 |       });
68 |     }, 100);
69 |   };
70 |   
71 |   // 설정 초기화
72 |   const resetToDefaults = () => {
73 |     // 기본값으로 되돌리기
74 |     const defaultWidth = 130;
75 |     const defaultHeight = 48;
76 |     const defaultMaxHeight = 180;
77 |     
78 |     setWidth(defaultWidth);
79 |     setHeight(defaultHeight);
80 |     setMaxHeight(defaultMaxHeight);
81 |     
82 |     // 테마 업데이트
83 |     updateNodeSize(defaultWidth, defaultHeight, defaultMaxHeight);
84 |     
[TRUNCATED]
```

src/components/tags/TagForm.test.tsx
```
1 | /**
2 |  * 파일명: TagForm.test.tsx
3 |  * 목적: TagForm 컴포넌트의 기능 테스트
4 |  * 역할: 태그 생성 폼의 모든 기능이 정상적으로 동작하는지 검증
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-04-03
7 |  */
8 | 
9 | import { render } from '@testing-library/react';
10 | import userEvent from '@testing-library/user-event';
11 | import { act } from 'react-dom/test-utils';
12 | import { vi, describe, test, expect, beforeEach, afterEach } from 'vitest';
13 | 
14 | import { TagFormMock } from './TagFormMock';
15 | import { mockActions, waitForDomChanges, setupTagFormTests, teardownTagFormTests } from './test-utils';
16 | 
17 | const setup = () => {
18 |   const user = userEvent.setup({ delay: null });
19 |   return {
20 |     ...render(<TagFormMock />),
21 |     user,
22 |   };
23 | };
24 | 
25 | describe('TagForm', () => {
26 |   beforeEach(() => {
27 |     vi.useFakeTimers({ shouldAdvanceTime: true });
28 |     setupTagFormTests();
29 |   });
30 | 
31 |   afterEach(() => {
32 |     vi.useRealTimers();
33 |     teardownTagFormTests();
34 |   });
35 | 
36 |   describe('태그 입력 기능', () => {
37 |     test('rule: 태그 이름을 입력할 수 있어야 함', async () => {
38 |       const { findByRole } = setup();
39 |       const input = await findByRole('textbox');
40 | 
41 |       await act(async () => {
42 |         await userEvent.type(input, '새로운 태그');
43 |         vi.runAllTimers();
44 |       });
45 | 
46 |       await waitForDomChanges();
47 |       expect(input).toHaveValue('새로운 태그');
48 |     });
49 | 
50 |     test('rule: IME 입력이 올바르게 처리되어야 함', async () => {
51 |       const { findByRole } = setup();
52 |       const input = (await findByRole('textbox')) as HTMLInputElement;
53 | 
54 |       await act(async () => {
55 |         input.focus();
56 |         input.dispatchEvent(new CompositionEvent('compositionstart'));
57 |         input.value = '한글';
58 |         input.dispatchEvent(new CompositionEvent('compositionend'));
59 |         input.dispatchEvent(new Event('input', { bubbles: true }));
60 |         vi.runAllTimers();
61 |       });
62 | 
63 |       await waitForDomChanges();
64 |       expect(input).toHaveValue('한글');
65 |     });
66 |   });
67 | 
68 |   describe('태그 생성 기능', () => {
69 |     test('rule: 빈 태그 이름으로 제출하면 오류가 표시되어야 함', async () => {
70 |       const { findByRole } = setup();
71 |       const submitButton = await findByRole('button');
72 | 
73 |       await act(async () => {
74 |         await userEvent.click(submitButton);
75 |         vi.runAllTimers();
76 |       });
77 | 
78 |       await waitForDomChanges();
79 |       expect(mockActions.toast.error).toHaveBeenCalledWith('태그 이름을 입력해주세요.');
80 |     });
81 | 
82 |     test('rule: 태그가 성공적으로 생성되어야 함', async () => {
83 |       const { findByRole } = setup();
84 |       const submitButton = await findByRole('button');
85 |       const input = await findByRole('textbox');
86 | 
87 |       await act(async () => {
[TRUNCATED]
```

src/components/tags/TagForm.tsx
```
1 | "use client";
2 | 
3 | import { useState } from "react";
4 | 
5 | import { toast } from "sonner";
6 | 
7 | import { Button } from "@/components/ui/button";
8 | import { Input } from "@/components/ui/input";
9 | import { Label } from "@/components/ui/label";
10 | 
11 | export default function TagForm() {
12 |   const [tagName, setTagName] = useState("");
13 |   const [isSubmitting, setIsSubmitting] = useState(false);
14 | 
15 |   const handleSubmit = async (e: React.FormEvent) => {
16 |     e.preventDefault();
17 | 
18 |     if (!tagName.trim()) {
19 |       toast.error("태그 이름을 입력해주세요.");
20 |       return;
21 |     }
22 | 
23 |     try {
24 |       setIsSubmitting(true);
25 | 
26 |       const response = await fetch("/api/tags", {
27 |         method: "POST",
28 |         headers: {
29 |           "Content-Type": "application/json",
30 |         },
31 |         body: JSON.stringify({ name: tagName.trim() }),
32 |       });
33 | 
34 |       if (!response.ok) {
35 |         const errorData = await response.json();
36 |         throw new Error(errorData.error || "태그 생성에 실패했습니다.");
37 |       }
38 | 
39 |       const data = await response.json();
40 |       console.log("태그가 생성되었습니다: ", data);
41 |       setTagName("");
42 | 
43 |       // 페이지 새로고침을 통해 목록 업데이트
44 |       window.location.reload();
45 |     } catch (error) {
46 |       console.error("태그 생성 오류:", error);
47 |       toast.error(error instanceof Error ? error.message : "태그 생성에 실패했습니다.");
48 |     } finally {
49 |       setIsSubmitting(false);
50 |     }
51 |   };
52 | 
53 |   return (
54 |     <form onSubmit={handleSubmit} className="space-y-4">
55 |       <div className="space-y-2">
56 |         <Label htmlFor="tagName">태그 이름</Label>
57 |         <Input
58 |           id="tagName"
59 |           type="text"
60 |           value={tagName}
61 |           onChange={(e) => setTagName(e.target.value)}
62 |           placeholder="새 태그 이름을 입력하세요"
63 |           disabled={isSubmitting}
64 |           maxLength={50}
65 |         />
66 |       </div>
67 | 
68 |       <Button type="submit" disabled={isSubmitting} className="w-full">
69 |         {isSubmitting ? "생성 중..." : "태그 생성"}
70 |       </Button>
71 |     </form>
72 |   );
73 | } 
```

src/components/tags/TagFormMock.tsx
```
1 | /**
2 |  * 파일명: TagFormMock.tsx
3 |  * 목적: TagForm 테스트를 위한 모킹 컴포넌트
4 |  * 역할: 실제 컴포넌트의 동작을 시뮬레이션
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2025-04-03
7 |  */
8 | 
9 | import React, { useState } from 'react';
10 | 
11 | import { mockActions } from './test-utils';
12 | 
13 | const formStyles = {
14 |     display: 'flex',
15 |     flexDirection: 'column' as const,
16 |     gap: '1rem',
17 |     padding: '1rem',
18 | };
19 | 
20 | const labelStyles = {
21 |     display: 'block',
22 |     marginBottom: '0.5rem',
23 |     fontWeight: 'bold',
24 | };
25 | 
26 | const inputStyles = {
27 |     padding: '0.5rem',
28 |     border: '1px solid #ccc',
29 |     borderRadius: '4px',
30 |     fontSize: '1rem',
31 | };
32 | 
33 | const buttonStyles = {
34 |     padding: '0.5rem 1rem',
35 |     backgroundColor: '#0070f3',
36 |     color: 'white',
37 |     border: 'none',
38 |     borderRadius: '4px',
39 |     cursor: 'pointer',
40 |     fontSize: '1rem',
41 |     ':disabled': {
42 |         backgroundColor: '#ccc',
43 |         cursor: 'not-allowed',
44 |     },
45 | };
46 | 
47 | export const TagFormMock: React.FC = () => {
48 |     const [tagName, setTagName] = useState('');
49 |     const [isSubmitting, setIsSubmitting] = useState(false);
50 | 
51 |     const handleSubmit = async (e: React.FormEvent) => {
52 |         e.preventDefault();
53 | 
54 |         if (!tagName.trim()) {
55 |             mockActions.toast.error('태그 이름을 입력해주세요.');
56 |             return;
57 |         }
58 | 
59 |         setIsSubmitting(true);
60 | 
61 |         try {
62 |             const response = await mockActions.createTag(tagName);
63 |             if (!response.ok) {
64 |                 const data = await response.json();
65 |                 throw new Error(data.message || '태그 생성에 실패했습니다.');
66 |             }
67 |             mockActions.toast.success('태그가 생성되었습니다.');
68 |             mockActions.reload();
69 |             setTagName('');
70 |         } catch (error) {
71 |             if (error instanceof Error) {
72 |                 mockActions.toast.error(error.message);
73 |             } else {
74 |                 mockActions.toast.error('태그 생성에 실패했습니다.');
75 |             }
76 |         } finally {
77 |             setIsSubmitting(false);
78 |         }
79 |     };
80 | 
81 |     return (
82 |         <form onSubmit={handleSubmit} style={formStyles} role="form" aria-label="태그 생성 폼">
83 |             <div>
84 |                 <label htmlFor="tagName" style={labelStyles}>
85 |                     태그 이름
86 |                 </label>
87 |                 <input
88 |                     id="tagName"
89 |                     type="text"
90 |                     value={tagName}
91 |                     onChange={(e) => setTagName(e.target.value)}
92 |                     onCompositionStart={() => { }}
93 |                     onCompositionEnd={() => { }}
94 |                     aria-label="태그 이름"
95 |                     aria-required="true"
96 |                     style={inputStyles}
97 |                     disabled={isSubmitting}
98 |                     placeholder="새로운 태그 이름을 입력하세요"
99 |                 />
100 |             </div>
[TRUNCATED]
```

src/components/tags/TagList.test.tsx
```
1 | /**
2 |  * 파일명: src/components/tags/TagList.test.tsx
3 |  * 목적: TagList 컴포넌트의 기능 테스트
4 |  * 역할: 태그 목록의 모든 기능이 정상적으로 동작하는지 검증
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-04-03
7 |  * 수정일: 2024-05-28 : import 순서 수정, 따옴표 escape 처리, 미사용 변수 제거
8 |  */
9 | 
10 | // 모킹은 테스트 파일 최상단에 위치해야 함
11 | import React from 'react';
12 | 
13 | import { render, screen, cleanup, fireEvent } from '@testing-library/react';
14 | import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
15 | 
16 | import { TagListMock } from './TagListMock';
17 | import { mockActions } from './test-utils';
18 | import '@testing-library/jest-dom';
19 | 
20 | // Sonner 토스트 모킹
21 | vi.mock('sonner', () => ({
22 |   toast: {
23 |     success: vi.fn(),
24 |     error: vi.fn(),
25 |   },
26 | }));
27 | 
28 | // 테스트용 태그 데이터
29 | const mockTags = [
30 |   { id: '1', name: '자바스크립트', count: 5, createdAt: '2023년 1월 1일' },
31 |   { id: '2', name: '리액트', count: 3, createdAt: '2023년 2월 1일' },
32 |   { id: '3', name: '타입스크립트', count: 0, createdAt: '2023년 3월 1일' }
33 | ];
34 | 
35 | // 실제 TagListMock 컴포넌트를 래핑하는 테스트용 컴포넌트
36 | function TestTagListWithDialog({
37 |   tagId = '1',
38 |   tagName = '자바스크립트',
39 |   tagCount = 5,
40 |   showCountWarning = true
41 | }) {
42 |   // 강제로 다이얼로그가 표시된 상태를 렌더링
43 |   return (
44 |     <div>
45 |       <div>
46 |         {mockTags.map(tag => (
47 |           <div key={tag.id} data-testid={`tag-row-${tag.id}`}>
48 |             <span>{tag.name}</span>
49 |             <span>{tag.count > 0 ? `${tag.count}개 카드` : '0개'}</span>
50 |             <span>{tag.createdAt}</span>
51 |             <button
52 |               data-testid={`delete-tag-button-${tag.id}`}
53 |               aria-label={`${tag.name} 태그 삭제`}
54 |             ></button>
55 |           </div>
56 |         ))}
57 |       </div>
58 | 
59 |       {/* 다이얼로그를 직접 렌더링 */}
60 |       <div role="dialog" aria-modal="true" data-testid="delete-confirmation-dialog">
61 |         <h2>태그 삭제 확인</h2>
62 |         <p>태그 &quot;{tagName}&quot;을(를) 삭제하시겠습니까?</p>
63 |         {showCountWarning && tagCount > 0 && (
64 |           <p>이 태그가 지정된 {tagCount}개의 카드에서 태그가 제거됩니다.</p>
65 |         )}
66 |         <button
67 |           data-testid="delete-confirm-button"
68 |           onClick={() => mockActions.deleteTag(tagId)}
69 |         >
70 |           삭제
71 |         </button>
72 |         <button data-testid="delete-cancel-button">취소</button>
73 |       </div>
74 |     </div>
75 |   );
76 | }
77 | 
[TRUNCATED]
```

src/components/tags/TagList.tsx
```
1 | "use client";
2 | 
3 | import { useState } from "react";
4 | 
5 | import Link from "next/link";
6 | 
7 | import { Trash2 } from "lucide-react";
8 | import { toast } from "sonner";
9 | 
10 | import {
11 |   AlertDialog,
12 |   AlertDialogAction,
13 |   AlertDialogCancel,
14 |   AlertDialogContent,
15 |   AlertDialogDescription,
16 |   AlertDialogFooter,
17 |   AlertDialogHeader,
18 |   AlertDialogTitle,
19 |   AlertDialogTrigger,
20 | } from "@/components/ui/alert-dialog";
21 | import { Badge } from "@/components/ui/badge";
22 | import { Button } from "@/components/ui/button";
23 | import {
24 |   Table,
25 |   TableBody,
26 |   TableCell,
27 |   TableHead,
28 |   TableHeader,
29 |   TableRow,
30 | } from "@/components/ui/table";
31 | 
32 | 
33 | interface TagItem {
34 |   id: string;
35 |   name: string;
36 |   count: number;
37 |   createdAt: string;
38 | }
39 | 
40 | interface TagListProps {
41 |   initialTags: TagItem[];
42 | }
43 | 
44 | export default function TagList({ initialTags }: TagListProps) {
45 |   const [tags, setTags] = useState<TagItem[]>(initialTags);
46 |   const [tagToDelete, setTagToDelete] = useState<string | null>(null);
47 |   const [isDeleting, setIsDeleting] = useState(false);
48 | 
49 |   const handleDeleteTag = async () => {
50 |     if (!tagToDelete) return;
51 | 
52 |     try {
53 |       setIsDeleting(true);
54 | 
55 |       const response = await fetch(`/api/tags/${tagToDelete}`, {
56 |         method: "DELETE",
57 |       });
58 | 
59 |       if (!response.ok) {
60 |         const errorData = await response.json();
61 |         throw new Error(errorData.error || "태그 삭제에 실패했습니다.");
62 |       }
63 | 
64 |       // 태그 목록에서 삭제된 태그 제거
65 |       setTags(tags.filter(tag => tag.id !== tagToDelete));
66 |       toast.success("태그가 삭제되었습니다.");
67 |     } catch (error) {
68 |       console.error("태그 삭제 오류:", error);
69 |       toast.error(error instanceof Error ? error.message : "태그 삭제에 실패했습니다.");
70 |     } finally {
71 |       setIsDeleting(false);
72 |       setTagToDelete(null);
73 |     }
74 |   };
75 | 
76 |   return (
77 |     <div>
78 |       {tags.length === 0 ? (
79 |         <div className="text-center py-6">
80 |           <p className="text-muted-foreground">등록된 태그가 없습니다.</p>
81 |         </div>
82 |       ) : (
83 |         <Table>
84 |           <TableHeader>
85 |             <TableRow>
86 |               <TableHead>태그 이름</TableHead>
87 |               <TableHead className="text-center">카드 수</TableHead>
88 |               <TableHead>생성일</TableHead>
89 |               <TableHead className="text-right">관리</TableHead>
90 |             </TableRow>
91 |           </TableHeader>
92 |           <TableBody>
93 |             {tags.map((tag) => (
94 |               <TableRow key={tag.id}>
95 |                 <TableCell>
96 |                   <Badge variant="outline" className="font-normal">
97 |                     {tag.name}
98 |                   </Badge>
[TRUNCATED]
```

src/components/tags/TagListMock.tsx
```
1 | /**
2 |  * 파일명: TagListMock.tsx
3 |  * 목적: TagList 컴포넌트의 테스트를 위한 모킹 컴포넌트
4 |  * 역할: 실제 컴포넌트의 동작을 시뮬레이션
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2025-04-03
7 |  */
8 | 
9 | import React, { useState } from 'react';
10 | 
11 | import { mockActions } from './test-utils';
12 | 
13 | interface Tag {
14 |     id: string;
15 |     name: string;
16 |     count: number;
17 |     createdAt: string;
18 | }
19 | 
20 | interface TagListMockProps {
21 |     initialTags: Tag[];
22 | }
23 | 
24 | // API 응답 타입 정의 추가
25 | interface ApiResponse {
26 |     message?: string;
27 |     error?: string;
28 |     status?: string;
29 |     [key: string]: unknown;
30 | }
31 | 
32 | export const TagListMock: React.FC<TagListMockProps> = ({ initialTags }) => {
33 |     const [tags, setTags] = useState(initialTags);
34 |     const [tagToDelete, setTagToDelete] = useState<string | null>(null);
35 |     const [isDeleting, setIsDeleting] = useState(false);
36 | 
37 |     const handleDeleteClick = (tagId: string) => {
38 |         const tag = tags.find(t => t.id === tagId);
39 |         if (tag) {
40 |             setTagToDelete(tagId);
41 |         }
42 |     };
43 | 
44 |     const handleDeleteConfirm = async () => {
45 |         if (!tagToDelete) return;
46 | 
47 |         setIsDeleting(true);
48 |         try {
49 |             const response = await mockActions.deleteTag(tagToDelete);
50 |             if (!response.ok) {
51 |                 const data = await response.json() as ApiResponse;
52 |                 throw new Error(data.error || '태그 삭제에 실패했습니다.');
53 |             }
54 |             mockActions.toast.success('태그가 삭제되었습니다.');
55 |             setTags(tags.filter(tag => tag.id !== tagToDelete));
56 |         } catch (error) {
57 |             if (error instanceof Error) {
58 |                 mockActions.toast.error(error.message);
59 |             } else {
60 |                 mockActions.toast.error('태그 삭제에 실패했습니다.');
61 |             }
62 |         } finally {
63 |             setIsDeleting(false);
64 |             setTagToDelete(null);
65 |         }
66 |     };
67 | 
68 |     const handleDeleteCancel = () => {
69 |         setTagToDelete(null);
70 |     };
71 | 
72 |     if (tags.length === 0) {
73 |         return <div>등록된 태그가 없습니다.</div>;
74 |     }
75 | 
76 |     const getTagById = (id: string) => tags.find(t => t.id === id);
77 | 
78 |     return (
79 |         <div>
80 |             {tags.map(tag => (
81 |                 <div key={tag.id} data-testid={`tag-row-${tag.id}`}>
82 |                     <span>{tag.name}</span>
83 |                     <span>{tag.count > 0 ? `${tag.count}개 카드` : '0개'}</span>
84 |                     <span>{tag.createdAt}</span>
85 |                     <button
86 |                         onClick={() => handleDeleteClick(tag.id)}
87 |                         data-testid={`delete-tag-button-${tag.id}`}
[TRUNCATED]
```

src/components/tags/test-utils.ts
```
1 | /**
2 |  * 파일명: test-utils.ts
3 |  * 목적: 태그 관련 컴포넌트의 테스트 유틸리티
4 |  * 역할: 테스트에 필요한 모킹과 헬퍼 함수 제공
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2025-04-03
7 |  */
8 | 
9 | import { vi } from 'vitest';
10 | 
11 | // 모킹된 액션 객체
12 | export const mockActions = {
13 |   createTag: vi.fn(),
14 |   deleteTag: vi.fn(),
15 |   reload: vi.fn(),
16 |   toast: {
17 |     success: vi.fn(),
18 |     error: vi.fn(),
19 |   },
20 | };
21 | 
22 | // Sonner 토스트 모킹
23 | vi.mock('sonner', () => ({
24 |   default: {
25 |     success: (...args: any[]) => mockActions.toast.success(...args),
26 |     error: (...args: any[]) => mockActions.toast.error(...args),
27 |   },
28 |   toast: {
29 |     success: (...args: any[]) => mockActions.toast.success(...args),
30 |     error: (...args: any[]) => mockActions.toast.error(...args),
31 |   },
32 | }));
33 | 
34 | // 태그 폼 테스트 설정
35 | export const setupTagFormTests = () => {
36 |   // 모킹된 액션 초기화
37 |   mockActions.createTag.mockReset();
38 |   mockActions.deleteTag.mockReset();
39 |   mockActions.reload.mockReset();
40 |   mockActions.toast.success.mockReset();
41 |   mockActions.toast.error.mockReset();
42 | 
43 |   // 기본 성공 응답으로 모킹
44 |   mockActions.createTag.mockResolvedValue(new Response(JSON.stringify({}), {
45 |     status: 200,
46 |     headers: { 'Content-Type': 'application/json' },
47 |   }));
48 | };
49 | 
50 | // 태그 폼 테스트 정리
51 | export const teardownTagFormTests = () => {
52 |   vi.resetModules();
53 |   vi.clearAllMocks();
54 | };
55 | 
56 | // 태그 리스트 테스트 설정
57 | export const setupTagListTests = () => {
58 |   // 모킹된 액션 초기화
59 |   mockActions.createTag.mockReset();
60 |   mockActions.deleteTag.mockReset();
61 |   mockActions.reload.mockReset();
62 |   mockActions.toast.success.mockReset();
63 |   mockActions.toast.error.mockReset();
64 | 
65 |   // 기본 성공 응답으로 모킹
66 |   mockActions.deleteTag.mockResolvedValue(new Response(JSON.stringify({}), {
67 |     status: 200,
68 |     headers: { 'Content-Type': 'application/json' },
69 |   }));
70 | };
71 | 
72 | // 태그 리스트 테스트 정리
73 | export const teardownTagListTests = () => {
74 |   vi.resetModules();
75 |   vi.clearAllMocks();
76 | };
77 | 
78 | /**
79 |  * waitForDomChanges: 비동기 작업의 안전한 완료를 위한 도우미 함수
80 |  * @returns {Promise<void>} DOM 변경이 완료될 때까지 기다리는 Promise
81 |  */
82 | export const waitForDomChanges = () => new Promise(resolve => setTimeout(resolve, 0)); 
```

src/lib/supabase/client.ts
```
1 | /**
2 |  * 파일명: src/lib/supabase/client.ts
3 |  * 목적: 클라이언트 환경에서 Supabase 클라이언트 제공
4 |  * 역할: 클라이언트 컴포넌트에서 Supabase에 접근할 때 사용
5 |  * 작성일: 2025-04-09
6 |  * 수정일: 2024-05-08 : auth 옵션 블럭 제거하여 @supabase/ssr 표준 준수
7 |  */
8 | 
9 | import { createBrowserClient } from '@supabase/ssr'
10 | 
11 | import { Database } from '@/types/supabase'
12 | 
13 | import createLogger from '../logger'
14 | 
15 | // 로거 생성
16 | const logger = createLogger('SupabaseClient')
17 | 
18 | /**
19 |  * createClient: 클라이언트 환경에서 Supabase 클라이언트 생성
20 |  * @returns Supabase 클라이언트 인스턴스
21 |  */
22 | export function createClient() {
23 |   try {
24 |     const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
25 |     const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
26 |   
27 |     if (!supabaseUrl || !supabaseKey) {
28 |       logger.error('Supabase 환경 변수가 설정되지 않았습니다')
29 |       throw new Error('Supabase 환경 변수가 설정되지 않았습니다')
30 |     }
31 |   
32 |     // auth 옵션 없이 호출하여 미들웨어 기반 세션 관리 사용
33 |     return createBrowserClient<Database>(
34 |       supabaseUrl,
35 |       supabaseKey
36 |     )
37 |   } catch (error) {
38 |     logger.error('클라이언트 Supabase 클라이언트 생성 실패', error)
39 |     throw error
40 |   }
41 | } 
```

src/lib/supabase/middleware.ts
```
1 | /**
2 |  * 파일명: src/lib/supabase/middleware.ts
3 |  * 목적: Supabase 인증 토큰 새로고침 처리
4 |  * 역할: 토큰 만료 시 자동으로 새로고침하고 쿠키에 저장
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-14 : 파일 경로 변경 (utils/supabase → lib/supabase)
7 |  */
8 | 
9 | import { NextResponse, type NextRequest } from 'next/server'
10 | 
11 | import { createServerClient, type CookieOptions } from '@supabase/ssr'
12 | 
13 | import { Database } from '@/types/supabase'
14 | 
15 | import createLogger from '../logger'
16 | 
17 | // 로거 생성
18 | const logger = createLogger('SupabaseMiddleware')
19 | 
20 | /**
21 |  * updateSession: Supabase 인증 토큰 갱신 및 쿠키 업데이트
22 |  * @param request NextRequest 객체
23 |  * @returns NextResponse 객체
24 |  */
25 | export async function updateSession(request: NextRequest) {
26 |   try {
27 |     // 응답 객체 생성
28 |     const response = NextResponse.next({
29 |       request: {
30 |         headers: request.headers,
31 |       },
32 |     })
33 | 
34 |     // Supabase 클라이언트 생성
35 |     const supabase = createServerClient<Database>(
36 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
37 |       process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
38 |       {
39 |         cookies: {
40 |           get(name: string) {
41 |             return request.cookies.get(name)?.value
42 |           },
43 |           set(name: string, value: string, options: CookieOptions) {
44 |             // PKCE 인증 흐름을 위한 code_verifier 쿠키 처리
45 |             if (name.includes('code_verifier')) {
46 |               logger.debug('코드 검증기 쿠키 설정:', name.substring(0, 10) + '...')
47 |               // 쿠키 수명을 10분으로 설정
48 |               options.maxAge = 60 * 10
49 |             }
50 |             
51 |             // 요청 및 응답에 쿠키 설정
52 |             request.cookies.set({
53 |               name,
54 |               value,
55 |               ...options,
56 |             })
57 |             
58 |             response.cookies.set({
59 |               name,
60 |               value,
61 |               ...options,
62 |             })
63 |           },
64 |           remove(name: string, options: CookieOptions) {
65 |             // 요청 및 응답에서 쿠키 삭제
66 |             request.cookies.delete(name)
67 |             
68 |             response.cookies.set({
69 |               name,
70 |               value: '',
71 |               ...options,
72 |               maxAge: 0,
73 |             })
74 |           },
75 |         },
76 |       }
77 |     )
78 | 
79 |     // 인증된 사용자 정보 가져오기 (세션 새로고침)
80 |     const { data } = await supabase.auth.getUser()
81 |     
82 |     // 디버깅용 로깅 (개인정보 보호를 위해 일부만 표시)
83 |     if (data?.user) {
84 |       logger.info('미들웨어에서 세션 새로고침 성공', {
85 |         userId: data.user.id.substring(0, 8) + '...',
86 |         email: data.user.email ? (data.user.email.substring(0, 3) + '...') : '없음',
87 |       })
88 |     }
89 |     
90 |     return response
91 |   } catch (error) {
[TRUNCATED]
```

src/lib/supabase/server.ts
```
1 | /**
2 |  * 파일명: src/lib/supabase/server.ts
3 |  * 목적: 서버 환경에서 Supabase 클라이언트 제공
4 |  * 역할: 서버 컴포넌트, 서버 액션, 라우트 핸들러에서 Supabase에 접근할 때 사용
5 |  * 작성일: 2025-04-09
6 |  */
7 | 
8 | import { cookies } from 'next/headers'
9 | 
10 | import { createServerClient, type CookieOptions } from '@supabase/ssr'
11 | 
12 | import { Database } from '@/types/supabase'
13 | 
14 | import createLogger from '../logger'
15 | 
16 | // 로거 생성
17 | const logger = createLogger('SupabaseServer')
18 | 
19 | /**
20 |  * createClient: 서버 환경에서 Supabase 클라이언트 생성
21 |  * @returns Supabase 클라이언트 인스턴스
22 |  */
23 | export async function createClient() {
24 |   try {
25 |     const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
26 |     const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
27 |   
28 |     if (!supabaseUrl || !supabaseKey) {
29 |       logger.error('Supabase 환경 변수가 설정되지 않았습니다')
30 |       throw new Error('Supabase 환경 변수가 설정되지 않았습니다')
31 |     }
32 |   
33 |     return createServerClient<Database>(
34 |       supabaseUrl,
35 |       supabaseKey,
36 |       {
37 |         cookies: {
38 |           async get(name: string) {
39 |             const cookieStore = await cookies()
40 |             return cookieStore.get(name)?.value
41 |           },
42 |           async set(name: string, value: string, options: CookieOptions) {
43 |             try {
44 |               const cookieStore = await cookies()
45 |               // PKCE 인증 흐름을 위한 code_verifier 쿠키 처리
46 |               if (name.includes('code_verifier')) {
47 |                 logger.debug('서버: 코드 검증기 쿠키 설정:', name.substring(0, 12) + '...')
48 |                 // 쿠키 수명을 10분으로 설정
49 |                 options.maxAge = 60 * 10
50 |               }
51 |               
52 |               cookieStore.set(name, value, options)
53 |             } catch (error) {
54 |               logger.error('서버: 쿠키 설정 중 오류:', error)
55 |             }
56 |           },
57 |           async remove(name: string, options: CookieOptions) {
58 |             try {
59 |               const cookieStore = await cookies()
60 |               cookieStore.delete({ name, ...options })
61 |             } catch (error) {
62 |               logger.error('서버: 쿠키 삭제 중 오류:', error)
63 |             }
64 |           },
65 |         },
66 |       }
67 |     )
68 |   } catch (error) {
69 |     logger.error('서버 Supabase 클라이언트 생성 실패', error)
70 |     throw error
71 |   }
72 | } 
```

src/components/ui/alert-dialog.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"
6 | 
7 | import { buttonVariants } from "@/components/ui/button"
8 | import { cn } from "@/lib/utils"
9 | 
10 | function AlertDialog({
11 |   ...props
12 | }: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
13 |   return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
14 | }
15 | 
16 | function AlertDialogTrigger({
17 |   ...props
18 | }: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
19 |   return (
20 |     <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
21 |   )
22 | }
23 | 
24 | function AlertDialogPortal({
25 |   ...props
26 | }: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
27 |   return (
28 |     <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
29 |   )
30 | }
31 | 
32 | function AlertDialogOverlay({
33 |   className,
34 |   ...props
35 | }: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
36 |   return (
37 |     <AlertDialogPrimitive.Overlay
38 |       data-slot="alert-dialog-overlay"
39 |       className={cn(
40 |         "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
41 |         className
42 |       )}
43 |       {...props}
44 |     />
45 |   )
46 | }
47 | 
48 | function AlertDialogContent({
49 |   className,
50 |   ...props
51 | }: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
52 |   return (
53 |     <AlertDialogPortal>
54 |       <AlertDialogOverlay />
55 |       <AlertDialogPrimitive.Content
56 |         data-slot="alert-dialog-content"
57 |         className={cn(
58 |           "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
59 |           className
60 |         )}
61 |         {...props}
62 |       />
63 |     </AlertDialogPortal>
64 |   )
65 | }
66 | 
67 | function AlertDialogHeader({
68 |   className,
69 |   ...props
70 | }: React.ComponentProps<"div">) {
71 |   return (
72 |     <div
73 |       data-slot="alert-dialog-header"
74 |       className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
75 |       {...props}
76 |     />
77 |   )
78 | }
79 | 
80 | function AlertDialogFooter({
81 |   className,
82 |   ...props
83 | }: React.ComponentProps<"div">) {
84 |   return (
85 |     <div
86 |       data-slot="alert-dialog-footer"
87 |       className={cn(
[TRUNCATED]
```

src/components/ui/badge.tsx
```
1 | import * as React from "react"
2 | 
3 | import { cva, type VariantProps } from "class-variance-authority"
4 | 
5 | import { cn } from "@/lib/utils"
6 | 
7 | const badgeVariants = cva(
8 |   "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
9 |   {
10 |     variants: {
11 |       variant: {
12 |         default:
13 |           "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
14 |         secondary:
15 |           "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
16 |         destructive:
17 |           "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
18 |         outline: "text-foreground",
19 |       },
20 |     },
21 |     defaultVariants: {
22 |       variant: "default",
23 |     },
24 |   }
25 | )
26 | 
27 | export interface BadgeProps
28 |   extends React.HTMLAttributes<HTMLDivElement>,
29 |     VariantProps<typeof badgeVariants> {}
30 | 
31 | function Badge({ className, variant, ...props }: BadgeProps) {
32 |   return (
33 |     <div className={cn(badgeVariants({ variant }), className)} {...props} />
34 |   )
35 | }
36 | 
37 | export { Badge, badgeVariants } 
```

src/components/ui/button.tsx
```
1 | import * as React from "react"
2 | 
3 | import { Slot } from "@radix-ui/react-slot"
4 | import { cva, type VariantProps } from "class-variance-authority"
5 | 
6 | import { cn } from "@/lib/utils"
7 | 
8 | const buttonVariants = cva(
9 |   "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-[color,box-shadow] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
10 |   {
11 |     variants: {
12 |       variant: {
13 |         default:
14 |           "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
15 |         destructive:
16 |           "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
17 |         outline:
18 |           "border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground",
19 |         secondary:
20 |           "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
21 |         ghost: "hover:bg-accent hover:text-accent-foreground",
22 |         link: "text-primary underline-offset-4 hover:underline",
23 |       },
24 |       size: {
25 |         default: "h-9 px-4 py-2 has-[>svg]:px-3",
26 |         sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
27 |         lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
28 |         icon: "size-9",
29 |       },
30 |     },
31 |     defaultVariants: {
32 |       variant: "default",
33 |       size: "default",
34 |     },
35 |   }
36 | )
37 | 
38 | function Button({
39 |   className,
40 |   variant,
41 |   size,
42 |   asChild = false,
43 |   ...props
44 | }: React.ComponentProps<"button"> &
45 |   VariantProps<typeof buttonVariants> & {
46 |     asChild?: boolean
47 |   }) {
48 |   const Comp = asChild ? Slot : "button"
49 | 
50 |   return (
51 |     <Comp
52 |       data-slot="button"
53 |       className={cn(buttonVariants({ variant, size, className }))}
54 |       {...props}
55 |     />
56 |   )
57 | }
58 | 
59 | export { Button, buttonVariants }
```

src/components/ui/card.tsx
```
1 | import * as React from "react"
2 | 
3 | import { cn } from "@/lib/utils"
4 | 
5 | function Card({ className, ...props }: React.ComponentProps<"div">) {
6 |   return (
7 |     <div
8 |       data-slot="card"
9 |       className={cn(
10 |         "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
11 |         className
12 |       )}
13 |       {...props}
14 |     />
15 |   )
16 | }
17 | 
18 | function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
19 |   return (
20 |     <div
21 |       data-slot="card-header"
22 |       className={cn(
23 |         "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
24 |         className
25 |       )}
26 |       {...props}
27 |     />
28 |   )
29 | }
30 | 
31 | function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
32 |   return (
33 |     <div
34 |       data-slot="card-title"
35 |       className={cn("leading-none font-semibold", className)}
36 |       {...props}
37 |     />
38 |   )
39 | }
40 | 
41 | function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
42 |   return (
43 |     <div
44 |       data-slot="card-description"
45 |       className={cn("text-muted-foreground text-sm", className)}
46 |       {...props}
47 |     />
48 |   )
49 | }
50 | 
51 | function CardAction({ className, ...props }: React.ComponentProps<"div">) {
52 |   return (
53 |     <div
54 |       data-slot="card-action"
55 |       className={cn(
56 |         "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
57 |         className
58 |       )}
59 |       {...props}
60 |     />
61 |   )
62 | }
63 | 
64 | function CardContent({ className, ...props }: React.ComponentProps<"div">) {
65 |   return (
66 |     <div
67 |       data-slot="card-content"
68 |       className={cn("px-6", className)}
69 |       {...props}
70 |     />
71 |   )
72 | }
73 | 
74 | function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
75 |   return (
76 |     <div
77 |       data-slot="card-footer"
78 |       className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
79 |       {...props}
80 |     />
81 |   )
82 | }
83 | 
84 | export {
85 |   Card,
86 |   CardHeader,
87 |   CardFooter,
88 |   CardTitle,
89 |   CardAction,
90 |   CardDescription,
91 |   CardContent,
92 | }
```

src/components/ui/checkbox.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
6 | import { CheckIcon } from "lucide-react"
7 | 
8 | import { cn } from "@/lib/utils"
9 | 
10 | function Checkbox({
11 |   className,
12 |   ...props
13 | }: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
14 |   return (
15 |     <CheckboxPrimitive.Root
16 |       data-slot="checkbox"
17 |       className={cn(
18 |         "peer border-input data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
19 |         className
20 |       )}
21 |       {...props}
22 |     >
23 |       <CheckboxPrimitive.Indicator
24 |         data-slot="checkbox-indicator"
25 |         className="flex items-center justify-center text-current transition-none"
26 |       >
27 |         <CheckIcon className="size-3.5" />
28 |       </CheckboxPrimitive.Indicator>
29 |     </CheckboxPrimitive.Root>
30 |   )
31 | }
32 | 
33 | export { Checkbox }
```

src/components/ui/command.tsx
```
1 | /**
2 |  * 파일명: src/components/ui/command.tsx
3 |  * 목적: Command 컴포넌트 구현
4 |  * 역할: 프로젝트 선택 및 명령 실행을 위한 UI 컴포넌트 제공
5 |  * 작성일: 2024-07-12
6 |  */
7 | 
8 | "use client"
9 | 
10 | import * as React from "react"
11 | 
12 | import { type DialogProps } from "@radix-ui/react-dialog"
13 | import { Command as CommandPrimitive } from "cmdk"
14 | import { Search } from "lucide-react"
15 | 
16 | import { Dialog, DialogContent } from "@/components/ui/dialog"
17 | import { cn } from "@/lib/utils"
18 | 
19 | const Command = React.forwardRef<
20 |     React.ElementRef<typeof CommandPrimitive>,
21 |     React.ComponentPropsWithoutRef<typeof CommandPrimitive>
22 | >(({ className, ...props }, ref) => (
23 |     <CommandPrimitive
24 |         ref={ref}
25 |         className={cn(
26 |             "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
27 |             className
28 |         )}
29 |         {...props}
30 |     />
31 | ))
32 | Command.displayName = CommandPrimitive.displayName
33 | 
34 | const CommandDialog = ({ children, ...props }: DialogProps) => {
35 |     return (
36 |         <Dialog {...props}>
37 |             <DialogContent className="overflow-hidden p-0 shadow-lg">
38 |                 <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
39 |                     {children}
40 |                 </Command>
41 |             </DialogContent>
42 |         </Dialog>
43 |     )
44 | }
45 | 
46 | const CommandInput = React.forwardRef<
47 |     React.ElementRef<typeof CommandPrimitive.Input>,
48 |     React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
49 | >(({ className, ...props }, ref) => (
50 |     <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
51 |         <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
52 |         <CommandPrimitive.Input
53 |             ref={ref}
54 |             className={cn(
55 |                 "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
56 |                 className
57 |             )}
58 |             {...props}
59 |         />
60 |     </div>
61 | ))
62 | 
63 | CommandInput.displayName = CommandPrimitive.Input.displayName
64 | 
65 | const CommandList = React.forwardRef<
66 |     React.ElementRef<typeof CommandPrimitive.List>,
67 |     React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
68 | >(({ className, ...props }, ref) => (
69 |     <CommandPrimitive.List
70 |         ref={ref}
[TRUNCATED]
```

src/components/ui/dialog.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as DialogPrimitive from "@radix-ui/react-dialog"
6 | import { XIcon } from "lucide-react"
7 | 
8 | import { cn } from "@/lib/utils"
9 | 
10 | function Dialog({
11 |   ...props
12 | }: React.ComponentProps<typeof DialogPrimitive.Root>) {
13 |   return <DialogPrimitive.Root data-slot="dialog" {...props} />
14 | }
15 | 
16 | function DialogTrigger({
17 |   ...props
18 | }: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
19 |   return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
20 | }
21 | 
22 | function DialogPortal({
23 |   ...props
24 | }: React.ComponentProps<typeof DialogPrimitive.Portal>) {
25 |   return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
26 | }
27 | 
28 | function DialogClose({
29 |   ...props
30 | }: React.ComponentProps<typeof DialogPrimitive.Close>) {
31 |   return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
32 | }
33 | 
34 | function DialogOverlay({
35 |   className,
36 |   ...props
37 | }: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
38 |   return (
39 |     <DialogPrimitive.Overlay
40 |       data-slot="dialog-overlay"
41 |       className={cn(
42 |         "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
43 |         className
44 |       )}
45 |       {...props}
46 |     />
47 |   )
48 | }
49 | 
50 | function DialogContent({
51 |   className,
52 |   children,
53 |   ...props
54 | }: React.ComponentProps<typeof DialogPrimitive.Content>) {
55 |   return (
56 |     <DialogPortal data-slot="dialog-portal">
57 |       <DialogOverlay />
58 |       <DialogPrimitive.Content
59 |         data-slot="dialog-content"
60 |         className={cn(
61 |           "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
62 |           className
63 |         )}
64 |         {...props}
65 |       >
66 |         {children}
67 |         <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
68 |           <XIcon />
69 |           <span className="sr-only">Close</span>
70 |         </DialogPrimitive.Close>
71 |       </DialogPrimitive.Content>
72 |     </DialogPortal>
[TRUNCATED]
```

src/components/ui/dropdown-menu.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
6 | import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"
7 | 
8 | import { cn } from "@/lib/utils"
9 | 
10 | function DropdownMenu({
11 |   ...props
12 | }: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
13 |   return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
14 | }
15 | 
16 | function DropdownMenuPortal({
17 |   ...props
18 | }: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
19 |   return (
20 |     <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
21 |   )
22 | }
23 | 
24 | function DropdownMenuTrigger({
25 |   ...props
26 | }: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
27 |   return (
28 |     <DropdownMenuPrimitive.Trigger
29 |       data-slot="dropdown-menu-trigger"
30 |       {...props}
31 |     />
32 |   )
33 | }
34 | 
35 | function DropdownMenuContent({
36 |   className,
37 |   sideOffset = 4,
38 |   ...props
39 | }: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
40 |   return (
41 |     <DropdownMenuPrimitive.Portal>
42 |       <DropdownMenuPrimitive.Content
43 |         data-slot="dropdown-menu-content"
44 |         sideOffset={sideOffset}
45 |         className={cn(
46 |           "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
47 |           className
48 |         )}
49 |         {...props}
50 |       />
51 |     </DropdownMenuPrimitive.Portal>
52 |   )
53 | }
54 | 
55 | function DropdownMenuGroup({
56 |   ...props
57 | }: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
58 |   return (
59 |     <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
60 |   )
61 | }
62 | 
63 | function DropdownMenuItem({
64 |   className,
65 |   inset,
66 |   variant = "default",
67 |   ...props
68 | }: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
69 |   inset?: boolean
70 |   variant?: "default" | "destructive"
71 | }) {
72 |   return (
73 |     <DropdownMenuPrimitive.Item
74 |       data-slot="dropdown-menu-item"
75 |       data-inset={inset}
76 |       data-variant={variant}
77 |       className={cn(
[TRUNCATED]
```

src/components/ui/form.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as LabelPrimitive from "@radix-ui/react-label"
6 | import { Slot } from "@radix-ui/react-slot"
7 | import {
8 |   Controller,
9 |   ControllerProps,
10 |   FieldPath,
11 |   FieldValues,
12 |   FormProvider,
13 |   useFormContext,
14 |   useFormState,
15 | } from "react-hook-form"
16 | 
17 | import { Label } from "@/components/ui/label"
18 | import { cn } from "@/lib/utils"
19 | 
20 | const Form = FormProvider
21 | 
22 | type FormFieldContextValue<
23 |   TFieldValues extends FieldValues = FieldValues,
24 |   TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
25 | > = {
26 |   name: TName
27 | }
28 | 
29 | const FormFieldContext = React.createContext<FormFieldContextValue>(
30 |   {} as FormFieldContextValue
31 | )
32 | 
33 | const FormField = <
34 |   TFieldValues extends FieldValues = FieldValues,
35 |   TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
36 | >({
37 |   ...props
38 | }: ControllerProps<TFieldValues, TName>) => {
39 |   return (
40 |     <FormFieldContext.Provider value={{ name: props.name }}>
41 |       <Controller {...props} />
42 |     </FormFieldContext.Provider>
43 |   )
44 | }
45 | 
46 | const useFormField = () => {
47 |   const fieldContext = React.useContext(FormFieldContext)
48 |   const itemContext = React.useContext(FormItemContext)
49 |   const { getFieldState } = useFormContext()
50 |   const formState = useFormState({ name: fieldContext.name })
51 |   const fieldState = getFieldState(fieldContext.name, formState)
52 | 
53 |   if (!fieldContext) {
54 |     throw new Error("useFormField should be used within <FormField>")
55 |   }
56 | 
57 |   const { id } = itemContext
58 | 
59 |   return {
60 |     id,
61 |     name: fieldContext.name,
62 |     formItemId: `${id}-form-item`,
63 |     formDescriptionId: `${id}-form-item-description`,
64 |     formMessageId: `${id}-form-item-message`,
65 |     ...fieldState,
66 |   }
67 | }
68 | 
69 | type FormItemContextValue = {
70 |   id: string
71 | }
72 | 
73 | const FormItemContext = React.createContext<FormItemContextValue>(
74 |   {} as FormItemContextValue
75 | )
76 | 
77 | function FormItem({ className, ...props }: React.ComponentProps<"div">) {
78 |   const id = React.useId()
79 | 
80 |   return (
81 |     <FormItemContext.Provider value={{ id }}>
82 |       <div
83 |         data-slot="form-item"
84 |         className={cn("grid gap-2", className)}
85 |         {...props}
86 |       />
87 |     </FormItemContext.Provider>
88 |   )
89 | }
90 | 
91 | function FormLabel({
92 |   className,
93 |   ...props
94 | }: React.ComponentProps<typeof LabelPrimitive.Root>) {
95 |   const { error, formItemId } = useFormField()
96 | 
97 |   return (
98 |     <Label
99 |       data-slot="form-label"
100 |       data-error={!!error}
[TRUNCATED]
```

src/components/ui/input.tsx
```
1 | import * as React from "react"
2 | 
3 | import { cn } from "@/lib/utils"
4 | 
5 | function Input({ className, type, ...props }: React.ComponentProps<"input">) {
6 |   return (
7 |     <input
8 |       type={type}
9 |       data-slot="input"
10 |       className={cn(
11 |         "border-input file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
12 |         "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
13 |         "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
14 |         className
15 |       )}
16 |       {...props}
17 |     />
18 |   )
19 | }
20 | 
21 | export { Input }
```

src/components/ui/label.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as LabelPrimitive from "@radix-ui/react-label"
6 | 
7 | import { cn } from "@/lib/utils"
8 | 
9 | function Label({
10 |   className,
11 |   ...props
12 | }: React.ComponentProps<typeof LabelPrimitive.Root>) {
13 |   return (
14 |     <LabelPrimitive.Root
15 |       data-slot="label"
16 |       className={cn(
17 |         "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
18 |         className
19 |       )}
20 |       {...props}
21 |     />
22 |   )
23 | }
24 | 
25 | export { Label }
```

src/components/ui/modal.tsx
```
1 | /**
2 |  * 파일명: modal.tsx
3 |  * 목적: 모달 다이얼로그 컴포넌트
4 |  * 역할: 모달 UI를 제공하는 컴포넌트
5 |  * 작성일: 2025-03-28
6 |  */
7 | 
8 | "use client"
9 | 
10 | // import * as React from "react"
11 | 
12 | import {
13 |   Dialog,
14 |   DialogClose,
15 |   DialogContent,
16 |   DialogDescription,
17 |   DialogFooter,
18 |   DialogTitle,
19 |   DialogTrigger,
20 | } from "@/components/ui/dialog"
21 | 
22 | const Modal = {
23 |   Root: Dialog,
24 |   Trigger: DialogTrigger,
25 |   Content: DialogContent,
26 |   Title: DialogTitle,
27 |   Description: DialogDescription,
28 |   Footer: DialogFooter,
29 |   Close: DialogClose,
30 | }
31 | 
32 | export { Modal } 
```

src/components/ui/portal.tsx
```
1 | "use client";
2 | 
3 | import { useEffect, useState } from 'react'
4 | 
5 | import { createPortal } from 'react-dom'
6 | 
7 | interface PortalProps {
8 |   children: React.ReactNode
9 | }
10 | 
11 | export function Portal({ children }: PortalProps) {
12 |   const [mounted, setMounted] = useState(false)
13 | 
14 |   useEffect(() => {
15 |     setMounted(true)
16 |     return () => setMounted(false)
17 |   }, [])
18 | 
19 |   return mounted
20 |     ? createPortal(children, document.body)
21 |     : null
22 | } 
```

src/components/ui/radio-group.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
6 | import { CircleIcon } from "lucide-react"
7 | 
8 | import { cn } from "@/lib/utils"
9 | 
10 | function RadioGroup({
11 |   className,
12 |   ...props
13 | }: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
14 |   return (
15 |     <RadioGroupPrimitive.Root
16 |       data-slot="radio-group"
17 |       className={cn("grid gap-3", className)}
18 |       {...props}
19 |     />
20 |   )
21 | }
22 | 
23 | function RadioGroupItem({
24 |   className,
25 |   ...props
26 | }: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
27 |   return (
28 |     <RadioGroupPrimitive.Item
29 |       data-slot="radio-group-item"
30 |       className={cn(
31 |         "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
32 |         className
33 |       )}
34 |       {...props}
35 |     >
36 |       <RadioGroupPrimitive.Indicator
37 |         data-slot="radio-group-indicator"
38 |         className="relative flex items-center justify-center"
39 |       >
40 |         <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
41 |       </RadioGroupPrimitive.Indicator>
42 |     </RadioGroupPrimitive.Item>
43 |   )
44 | }
45 | 
46 | export { RadioGroup, RadioGroupItem }
```

src/components/ui/scroll-area.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"
6 | 
7 | import { cn } from "@/lib/utils"
8 | 
9 | function ScrollArea({
10 |   className,
11 |   children,
12 |   ...props
13 | }: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
14 |   return (
15 |     <ScrollAreaPrimitive.Root
16 |       data-slot="scroll-area"
17 |       className={cn("relative", className)}
18 |       {...props}
19 |     >
20 |       <ScrollAreaPrimitive.Viewport
21 |         data-slot="scroll-area-viewport"
22 |         className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
23 |       >
24 |         {children}
25 |       </ScrollAreaPrimitive.Viewport>
26 |       <ScrollBar />
27 |       <ScrollAreaPrimitive.Corner />
28 |     </ScrollAreaPrimitive.Root>
29 |   )
30 | }
31 | 
32 | function ScrollBar({
33 |   className,
34 |   orientation = "vertical",
35 |   ...props
36 | }: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
37 |   return (
38 |     <ScrollAreaPrimitive.ScrollAreaScrollbar
39 |       data-slot="scroll-area-scrollbar"
40 |       orientation={orientation}
41 |       className={cn(
42 |         "flex touch-none p-px transition-colors select-none",
43 |         orientation === "vertical" &&
44 |           "h-full w-2.5 border-l border-l-transparent",
45 |         orientation === "horizontal" &&
46 |           "h-2.5 flex-col border-t border-t-transparent",
47 |         className
48 |       )}
49 |       {...props}
50 |     >
51 |       <ScrollAreaPrimitive.ScrollAreaThumb
52 |         data-slot="scroll-area-thumb"
53 |         className="bg-border relative flex-1 rounded-full"
54 |       />
55 |     </ScrollAreaPrimitive.ScrollAreaScrollbar>
56 |   )
57 | }
58 | 
59 | export { ScrollArea, ScrollBar }
```

src/components/ui/separator.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as SeparatorPrimitive from "@radix-ui/react-separator"
6 | 
7 | import { cn } from "@/lib/utils"
8 | 
9 | function Separator({
10 |   className,
11 |   orientation = "horizontal",
12 |   decorative = true,
13 |   ...props
14 | }: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
15 |   return (
16 |     <SeparatorPrimitive.Root
17 |       data-slot="separator-root"
18 |       decorative={decorative}
19 |       orientation={orientation}
20 |       className={cn(
21 |         "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
22 |         className
23 |       )}
24 |       {...props}
25 |     />
26 |   )
27 | }
28 | 
29 | export { Separator }
```

src/components/ui/skeleton.tsx
```
1 | import { cn } from "@/lib/utils"
2 | 
3 | function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
4 |   return (
5 |     <div
6 |       data-slot="skeleton"
7 |       className={cn("bg-primary/10 animate-pulse rounded-md", className)}
8 |       {...props}
9 |     />
10 |   )
11 | }
12 | 
13 | export { Skeleton }
```

src/components/ui/slider.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as SliderPrimitive from "@radix-ui/react-slider"
6 | 
7 | import { cn } from "@/lib/utils"
8 | 
9 | function Slider({
10 |   className,
11 |   defaultValue,
12 |   value,
13 |   min = 0,
14 |   max = 100,
15 |   ...props
16 | }: React.ComponentProps<typeof SliderPrimitive.Root>) {
17 |   const _values = React.useMemo(
18 |     () =>
19 |       Array.isArray(value)
20 |         ? value
21 |         : Array.isArray(defaultValue)
22 |           ? defaultValue
23 |           : [min, max],
24 |     [value, defaultValue, min, max]
25 |   )
26 | 
27 |   return (
28 |     <SliderPrimitive.Root
29 |       data-slot="slider"
30 |       defaultValue={defaultValue}
31 |       value={value}
32 |       min={min}
33 |       max={max}
34 |       className={cn(
35 |         "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
36 |         className
37 |       )}
38 |       {...props}
39 |     >
40 |       <SliderPrimitive.Track
41 |         data-slot="slider-track"
42 |         className={cn(
43 |           "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
44 |         )}
45 |       >
46 |         <SliderPrimitive.Range
47 |           data-slot="slider-range"
48 |           className={cn(
49 |             "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
50 |           )}
51 |         />
52 |       </SliderPrimitive.Track>
53 |       {Array.from({ length: _values.length }, (_, index) => (
54 |         <SliderPrimitive.Thumb
55 |           data-slot="slider-thumb"
56 |           key={index}
57 |           className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
58 |         />
59 |       ))}
60 |     </SliderPrimitive.Root>
61 |   )
62 | }
63 | 
64 | export { Slider }
```

src/components/ui/sonner.tsx
```
1 | "use client"
2 | 
3 | import { useTheme } from "next-themes"
4 | import { Toaster as Sonner, ToasterProps } from "sonner"
5 | 
6 | const Toaster = ({ ...props }: ToasterProps) => {
7 |   const { theme = "system" } = useTheme()
8 | 
9 |   return (
10 |     <Sonner
11 |       theme={theme as ToasterProps["theme"]}
12 |       className="toaster group"
13 |       toastOptions={{
14 |         classNames: {
15 |           toast:
16 |             "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
17 |           description: "group-[.toast]:text-muted-foreground",
18 |           actionButton:
19 |             "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground font-medium",
20 |           cancelButton:
21 |             "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground font-medium",
22 |         },
23 |       }}
24 |       {...props}
25 |     />
26 |   )
27 | }
28 | 
29 | export { Toaster }
```

src/components/ui/spinner.tsx
```
1 | /**
2 |  * 파일명: src/components/ui/spinner.tsx
3 |  * 목적: 로딩 상태를 표시하는 스피너 컴포넌트 제공
4 |  * 역할: 비동기 작업 중에 사용자에게 로딩 상태를 표시
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | import { cn } from '@/lib/utils';
9 | 
10 | interface SpinnerProps {
11 |   size?: 'sm' | 'md' | 'lg';
12 |   className?: string;
13 | }
14 | 
15 | /**
16 |  * Spinner: 로딩 상태를 표시하는 스피너 컴포넌트
17 |  * @param size 스피너 크기 (sm, md, lg)
18 |  * @param className 추가 CSS 클래스
19 |  * @returns {JSX.Element} 스피너 컴포넌트
20 |  */
21 | export function Spinner({ size = 'md', className }: SpinnerProps) {
22 |   const sizeClasses = {
23 |     sm: 'h-4 w-4 border-2',
24 |     md: 'h-8 w-8 border-2',
25 |     lg: 'h-12 w-12 border-3',
26 |   };
27 | 
28 |   return (
29 |     <div
30 |       className={cn(
31 |         'animate-spin rounded-full border-solid border-primary border-t-transparent',
32 |         sizeClasses[size],
33 |         className
34 |       )}
35 |       aria-label="로딩 중"
36 |       role="status"
37 |     />
38 |   );
39 | } 
```

src/components/ui/table.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import { cn } from "@/lib/utils"
6 | 
7 | function Table({ className, ...props }: React.ComponentProps<"table">) {
8 |   return (
9 |     <div
10 |       data-slot="table-container"
11 |       className="relative w-full overflow-x-auto"
12 |     >
13 |       <table
14 |         data-slot="table"
15 |         className={cn("w-full caption-bottom text-sm", className)}
16 |         {...props}
17 |       />
18 |     </div>
19 |   )
20 | }
21 | 
22 | function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
23 |   return (
24 |     <thead
25 |       data-slot="table-header"
26 |       className={cn("[&_tr]:border-b", className)}
27 |       {...props}
28 |     />
29 |   )
30 | }
31 | 
32 | function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
33 |   return (
34 |     <tbody
35 |       data-slot="table-body"
36 |       className={cn("[&_tr:last-child]:border-0", className)}
37 |       {...props}
38 |     />
39 |   )
40 | }
41 | 
42 | function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
43 |   return (
44 |     <tfoot
45 |       data-slot="table-footer"
46 |       className={cn(
47 |         "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
48 |         className
49 |       )}
50 |       {...props}
51 |     />
52 |   )
53 | }
54 | 
55 | function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
56 |   return (
57 |     <tr
58 |       data-slot="table-row"
59 |       className={cn(
60 |         "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
61 |         className
62 |       )}
63 |       {...props}
64 |     />
65 |   )
66 | }
67 | 
68 | function TableHead({ className, ...props }: React.ComponentProps<"th">) {
69 |   return (
70 |     <th
71 |       data-slot="table-head"
72 |       className={cn(
73 |         "text-muted-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
74 |         className
75 |       )}
76 |       {...props}
77 |     />
78 |   )
79 | }
80 | 
81 | function TableCell({ className, ...props }: React.ComponentProps<"td">) {
82 |   return (
83 |     <td
84 |       data-slot="table-cell"
85 |       className={cn(
86 |         "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
87 |         className
88 |       )}
89 |       {...props}
90 |     />
91 |   )
92 | }
93 | 
94 | function TableCaption({
95 |   className,
96 |   ...props
97 | }: React.ComponentProps<"caption">) {
98 |   return (
99 |     <caption
100 |       data-slot="table-caption"
[TRUNCATED]
```

src/components/ui/tabs.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as TabsPrimitive from "@radix-ui/react-tabs"
6 | 
7 | import { cn } from "@/lib/utils"
8 | 
9 | function Tabs({
10 |   className,
11 |   ...props
12 | }: React.ComponentProps<typeof TabsPrimitive.Root>) {
13 |   return (
14 |     <TabsPrimitive.Root
15 |       data-slot="tabs"
16 |       className={cn("flex flex-col gap-2", className)}
17 |       {...props}
18 |     />
19 |   )
20 | }
21 | 
22 | function TabsList({
23 |   className,
24 |   ...props
25 | }: React.ComponentProps<typeof TabsPrimitive.List>) {
26 |   return (
27 |     <TabsPrimitive.List
28 |       data-slot="tabs-list"
29 |       className={cn(
30 |         "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
31 |         className
32 |       )}
33 |       {...props}
34 |     />
35 |   )
36 | }
37 | 
38 | function TabsTrigger({
39 |   className,
40 |   ...props
41 | }: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
42 |   return (
43 |     <TabsPrimitive.Trigger
44 |       data-slot="tabs-trigger"
45 |       className={cn(
46 |         "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
47 |         className
48 |       )}
49 |       {...props}
50 |     />
51 |   )
52 | }
53 | 
54 | function TabsContent({
55 |   className,
56 |   ...props
57 | }: React.ComponentProps<typeof TabsPrimitive.Content>) {
58 |   return (
59 |     <TabsPrimitive.Content
60 |       data-slot="tabs-content"
61 |       className={cn("flex-1 outline-none", className)}
62 |       {...props}
63 |     />
64 |   )
65 | }
66 | 
67 | export { Tabs, TabsList, TabsTrigger, TabsContent }
```

src/components/ui/textarea.tsx
```
1 | import * as React from "react"
2 | 
3 | import { cn } from "@/lib/utils"
4 | 
5 | function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
6 |   return (
7 |     <textarea
8 |       data-slot="textarea"
9 |       className={cn(
10 |         "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
11 |         className
12 |       )}
13 |       {...props}
14 |     />
15 |   )
16 | }
17 | 
18 | export { Textarea }
```

src/components/ui/tooltip.tsx
```
1 | "use client"
2 | 
3 | import * as React from "react"
4 | 
5 | import * as TooltipPrimitive from "@radix-ui/react-tooltip"
6 | 
7 | import { cn } from "@/lib/utils"
8 | 
9 | function TooltipProvider({
10 |   delayDuration = 0,
11 |   ...props
12 | }: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
13 |   return (
14 |     <TooltipPrimitive.Provider
15 |       data-slot="tooltip-provider"
16 |       delayDuration={delayDuration}
17 |       {...props}
18 |     />
19 |   )
20 | }
21 | 
22 | function Tooltip({
23 |   ...props
24 | }: React.ComponentProps<typeof TooltipPrimitive.Root>) {
25 |   return (
26 |     <TooltipProvider>
27 |       <TooltipPrimitive.Root data-slot="tooltip" {...props} />
28 |     </TooltipProvider>
29 |   )
30 | }
31 | 
32 | function TooltipTrigger({
33 |   ...props
34 | }: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
35 |   return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
36 | }
37 | 
38 | function TooltipContent({
39 |   className,
40 |   sideOffset = 0,
41 |   children,
42 |   ...props
43 | }: React.ComponentProps<typeof TooltipPrimitive.Content>) {
44 |   return (
45 |     <TooltipPrimitive.Portal>
46 |       <TooltipPrimitive.Content
47 |         data-slot="tooltip-content"
48 |         sideOffset={sideOffset}
49 |         className={cn(
50 |           "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
51 |           className
52 |         )}
53 |         {...props}
54 |       >
55 |         {children}
56 |         <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
57 |       </TooltipPrimitive.Content>
58 |     </TooltipPrimitive.Portal>
59 |   )
60 | }
61 | 
62 | export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
```

src/tests/integration/auth-flow.test.tsx
```
1 | /**
2 |  * 파일명: src/tests/integration/auth-flow.test.tsx
3 |  * 목적: Supabase 인증 흐름 통합 테스트
4 |  * 역할: OAuth 로그인, 콜백 처리, 로그아웃 과정 검증
5 |  * 작성일: 2024-05-01
6 |  * 수정일: 2024-05-01 : AuthContext 모킹 방식 수정 및 signInWithGoogle 반환 타입 조정
7 |  */
8 | 
9 | import { useRouter, usePathname } from 'next/navigation'
10 | 
11 | import { render, screen, waitFor } from '@testing-library/react'
12 | import userEvent from '@testing-library/user-event'
13 | import { describe, it, expect, vi, beforeEach } from 'vitest'
14 | 
15 | // 실제 모듈 모킹
16 | vi.mock('next/navigation', () => ({
17 |     useRouter: vi.fn(),
18 |     usePathname: vi.fn()
19 | }))
20 | 
21 | // Auth 모듈 모킹
22 | const mockSignInWithGoogle = vi.fn()
23 | const mockSignOut = vi.fn()
24 | 
25 | vi.mock('@/lib/auth', () => ({
26 |     signInWithGoogle: () => mockSignInWithGoogle(),
27 |     signOut: () => mockSignOut()
28 | }))
29 | 
30 | // AuthContext 모킹
31 | vi.mock('@/context/AuthContext', () => ({
32 |     useAuth: vi.fn(),
33 |     AuthProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>
34 | }))
35 | 
36 | // 테스트 컴포넌트 생성
37 | import { useAuth } from '@/context/AuthContext'
38 | 
39 | const LoginPage = () => {
40 |     const { user } = useAuth() || { user: null }
41 |     const router = useRouter()
42 | 
43 |     const handleLogin = async () => {
44 |         const result = await mockSignInWithGoogle()
45 |         if (result.success) router.push('/dashboard')
46 |     }
47 | 
48 |     const handleLogout = async () => {
49 |         await mockSignOut()
50 |         router.push('/login')
51 |     }
52 | 
53 |     return (
54 |         <div>
55 |             {!user ? (
56 |                 <button onClick={handleLogin}>Google 로그인</button>
57 |             ) : (
58 |                 <div>
59 |                     <div data-testid="user-info">{user.email}</div>
60 |                     <button onClick={handleLogout}>로그아웃</button>
61 |                 </div>
62 |             )}
63 |         </div>
64 |     )
65 | }
66 | 
67 | const ProtectedPage = () => {
68 |     const { user } = useAuth() || { user: null }
69 |     const router = useRouter()
70 | 
71 |     if (!user) {
72 |         router.push('/login')
73 |         return null
74 |     }
75 | 
76 |     return <div>비밀 콘텐츠</div>
77 | }
78 | 
79 | describe('인증 흐름 통합 테스트', () => {
80 |     beforeEach(() => {
81 |         vi.clearAllMocks()
82 | 
83 |         // useRouter 모킹
84 |         const mockRouter = { push: vi.fn() }
85 |         vi.mocked(useRouter).mockReturnValue(mockRouter)
86 | 
87 |         // usePathname 모킹
88 |         vi.mocked(usePathname).mockReturnValue('/login')
89 | 
90 |         // useAuth 모킹 - 처음에는 로그아웃 상태
[TRUNCATED]
```

src/tests/mocks/additional-mocks.ts
```
1 | /**
2 |  * 파일명: additional-mocks.ts
3 |  * 목적: 테스트에 필요한 추가 모킹 함수 제공
4 |  * 역할: 기존 모킹에 포함되지 않았거나 락된 모듈을 모킹
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-05 : 린터 오류 수정 - Function 타입을 구체적인 함수 시그니처로 변경 및 사용되지 않는 변수 제거
7 |  */
8 | 
9 | import { vi } from 'vitest';
10 | 
11 | /**
12 |  * mockEnvironment: 환경 감지 관련 함수 모킹
13 |  * @returns 모킹된 환경 감지 유틸리티
14 |  */
15 | export const mockEnvironment = () => {
16 |   const mock = {
17 |     isClient: vi.fn().mockReturnValue(true),
18 |     isServer: vi.fn().mockReturnValue(false),
19 |     executeOnClient: vi.fn((fn: () => void) => fn?.()),
20 |     executeOnServer: vi.fn(),
21 |     toggleEnvironment: (isClientEnvironment: boolean) => {
22 |       mock.isClient.mockReturnValue(isClientEnvironment);
23 |       mock.isServer.mockReturnValue(!isClientEnvironment);
24 |       
25 |       if (isClientEnvironment) {
26 |         mock.executeOnClient.mockImplementation((fn: () => void) => fn?.());
27 |         mock.executeOnServer.mockImplementation(() => {});
28 |       } else {
29 |         mock.executeOnClient.mockImplementation(() => {});
30 |         mock.executeOnServer.mockImplementation((fn: () => void) => fn?.());
31 |       }
32 |     }
33 |   };
34 |   
35 |   return mock;
36 | };
37 | 
38 | /**
39 |  * mockAuth: 인증 관련 함수 모킹
40 |  * @returns 모킹된 인증 유틸리티
41 |  */
42 | export const mockAuth = () => {
43 |   return {
44 |     generateCodeVerifier: vi.fn().mockReturnValue('test-code-verifier'),
45 |     generateCodeChallenge: vi.fn().mockResolvedValue('test-code-challenge'),
46 |     googleLogin: vi.fn().mockImplementation(() => {
47 |       // URL 업데이트 모킹
48 |       window.location.href = 'https://accounts.google.com/o/oauth2/v2/auth?code_challenge=test-code-challenge&code_challenge_method=S256';
49 |       return Promise.resolve();
50 |     }),
51 |     exchangeCodeForSession: vi.fn().mockResolvedValue({
52 |       access_token: 'test-access-token',
53 |       refresh_token: 'test-refresh-token',
54 |       expires_in: 3600
55 |     })
56 |   };
57 | };
58 | 
59 | /**
60 |  * mockBase64: Base64 인코딩 유틸리티 모킹
61 |  * @returns 모킹된 Base64 유틸리티
62 |  */
63 | export const mockBase64 = () => {
64 |   return {
65 |     base64UrlEncode: vi.fn().mockReturnValue('test-base64url-encoded-string')
66 |   };
67 | };
68 | 
69 | /**
70 |  * mockMiddleware: Next.js 미들웨어 모킹
71 |  * @returns 모킹된 미들웨어 함수
72 |  */
73 | export const mockMiddleware = () => {
74 |   return {
75 |     middleware: vi.fn().mockImplementation(async () => {
76 |       // 기본 응답은 "next" (접근 허용)
77 |       return { type: 'next' };
78 |     })
79 |   };
80 | };
81 | 
82 | /**
83 |  * mockNextResponse: Next.js Response 객체 모킹
84 |  * @returns 모킹된 NextResponse 객체
85 |  */
86 | export const mockNextResponse = () => {
87 |   return {
88 |     NextResponse: {
[TRUNCATED]
```

src/tests/mocks/auth-mock.ts
```
1 | /**
2 |  * 파일명: auth-mock.ts
3 |  * 목적: 인증 테스트를 위한 모킹 함수 제공
4 |  * 역할: 테스트에 필요한 인증 관련 모킹 데이터 및 유틸리티 제공
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | /**
9 |  * generateMockCodeVerifier: PKCE 코드 검증기를 모방하는 문자열 생성
10 |  * @returns {string} 모의 코드 검증기 문자열
11 |  */
12 | export function generateMockCodeVerifier(): string {
13 |   const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
14 |   let result = '';
15 |   
16 |   // 96자 길이의 무작위 문자열 생성
17 |   for (let i = 0; i < 96; i++) {
18 |     result += chars.charAt(Math.floor(Math.random() * chars.length));
19 |   }
20 |   
21 |   return result;
22 | }
23 | 
24 | /**
25 |  * generateMockAuthCode: OAuth 인증 코드를 모방하는 문자열 생성
26 |  * @returns {string} 모의 인증 코드 문자열
27 |  */
28 | export function generateMockAuthCode(): string {
29 |   return 'valid_code'; // 테스트에서 유효한 코드로 인식되는 특정 문자열
30 | }
31 | 
32 | /**
33 |  * mockSupabaseSession: Supabase 세션 객체 모킹
34 |  * @param {string} userId 사용자 ID
35 |  * @param {string} provider 인증 제공자 (기본값: 'google')
36 |  * @returns {Object} 모의 세션 객체
37 |  */
38 | export function mockSupabaseSession(
39 |   userId: string = 'test_user_id', 
40 |   provider: string = 'google'
41 | ): {
42 |   access_token: string;
43 |   refresh_token: string;
44 |   user: {
45 |     id: string;
46 |     app_metadata: {
47 |       provider: string;
48 |     };
49 |   };
50 | } {
51 |   return {
52 |     access_token: 'test_access_token',
53 |     refresh_token: 'test_refresh_token',
54 |     user: {
55 |       id: userId,
56 |       app_metadata: {
57 |         provider
58 |       }
59 |     }
60 |   };
61 | }
62 | 
63 | /**
64 |  * mockAuthError: 인증 오류 객체 모킹
65 |  * @param {string} message 오류 메시지
66 |  * @param {number} status HTTP 상태 코드
67 |  * @returns {Object} 모의 오류 객체
68 |  */
69 | export function mockAuthError(
70 |   message: string = 'Auth error',
71 |   status: number = 400
72 | ): {
73 |   message: string;
74 |   status: number;
75 | } {
76 |   return {
77 |     message,
78 |     status
79 |   };
80 | } 
```

src/tests/mocks/env-mock.ts
```
1 | /**
2 |  * 파일명: env-mock.ts
3 |  * 목적: 테스트를 위한 환경 모킹 유틸리티
4 |  * 역할: 서버/클라이언트 환경 감지 기능 모킹
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | import { vi, MockInstance } from 'vitest';
9 | 
10 | /**
11 |  * window 객체 모킹
12 |  * @returns 모의 window 객체
13 |  */
14 | export function mockWindow() {
15 |   return {
16 |     location: {
17 |       hostname: 'localhost',
18 |       protocol: 'http:',
19 |       port: '3000',
20 |       pathname: '/',
21 |       href: 'http://localhost:3000/',
22 |       origin: 'http://localhost:3000',
23 |       search: '',
24 |       hash: '',
25 |       assign: vi.fn(),
26 |       replace: vi.fn()
27 |     },
28 |     localStorage: {
29 |       getItem: vi.fn(),
30 |       setItem: vi.fn(),
31 |       removeItem: vi.fn(),
32 |       clear: vi.fn()
33 |     },
34 |     sessionStorage: {
35 |       getItem: vi.fn(),
36 |       setItem: vi.fn(),
37 |       removeItem: vi.fn(),
38 |       clear: vi.fn()
39 |     },
40 |     navigator: {
41 |       userAgent: 'Mozilla/5.0 (Test) Test/1.0',
42 |       language: 'ko-KR',
43 |     },
44 |     document: {
45 |       cookie: '',
46 |       createElement: vi.fn(),
47 |       querySelector: vi.fn(),
48 |       querySelectorAll: vi.fn(),
49 |       getElementById: vi.fn(),
50 |     },
51 |     fetch: vi.fn(),
52 |     addEventListener: vi.fn(),
53 |     removeEventListener: vi.fn(),
54 |     setTimeout: vi.fn(),
55 |     clearTimeout: vi.fn(),
56 |     crypto: {
57 |       getRandomValues: vi.fn(),
58 |       subtle: {
59 |         digest: vi.fn()
60 |       }
61 |     },
62 |     btoa: vi.fn((str: string) => Buffer.from(str).toString('base64')),
63 |     atob: vi.fn((str: string) => Buffer.from(str, 'base64').toString()),
64 |     __SUPABASE_AUTH_SET_ITEM: vi.fn(),
65 |     __SUPABASE_AUTH_GET_ITEM: vi.fn(),
66 |     __SUPABASE_AUTH_REMOVE_ITEM: vi.fn(),
67 |     __SUPABASE_AUTH_CODE_VERIFIER: null,
68 |   };
69 | }
70 | 
71 | /**
72 |  * process.env 모킹
73 |  * @returns 모의 process.env 객체
74 |  */
75 | export function mockProcessEnv(): Record<string, string> {
76 |   return {
77 |     NODE_ENV: 'test',
78 |     NEXT_PUBLIC_SUPABASE_URL: 'https://test-project.supabase.co',
79 |     NEXT_PUBLIC_SUPABASE_ANON_KEY: 'mock-anon-key',
80 |     NEXT_PUBLIC_OAUTH_REDIRECT_URL: 'http://localhost:3000',
81 |   };
82 | }
83 | 
84 | /**
85 |  * 클라이언트 환경 모킹
86 |  */
87 | export function mockClientEnvironment() {
88 |   // 원래 객체 저장 (나중에 복원하기 위해)
89 |   const originalWindow = global.window;
90 |   const originalDocument = global.document;
91 |   const originalLocalStorage = global.localStorage;
92 |   const originalSessionStorage = global.sessionStorage;
93 |   const originalNavigator = global.navigator;
[TRUNCATED]
```

src/tests/mocks/storage-mock.ts
```
1 | /**
2 |  * 파일명: storage-mock.ts
3 |  * 목적: 브라우저 스토리지 API 모킹
4 |  * 역할: 테스트 환경에서 스토리지 API 시뮬레이션
5 |  * 작성일: 2025-03-27
6 |  */
7 | 
8 | import { vi } from 'vitest';
9 | 
10 | /**
11 |  * localStorage 모킹
12 |  * @returns 모의 localStorage 객체
13 |  */
14 | export function mockLocalStorage() {
15 |   const store: Record<string, string> = {};
16 | 
17 |   return {
18 |     getItem: vi.fn((key: string) => {
19 |       return store[key] || null;
20 |     }),
21 |     setItem: vi.fn((key: string, value: string) => {
22 |       store[key] = value;
23 |     }),
24 |     removeItem: vi.fn((key: string) => {
25 |       delete store[key];
26 |     }),
27 |     clear: vi.fn(() => {
28 |       Object.keys(store).forEach(key => {
29 |         delete store[key];
30 |       });
31 |     }),
32 |     key: vi.fn((index: number) => {
33 |       return Object.keys(store)[index] || null;
34 |     }),
35 |     length: vi.fn(() => {
36 |       return Object.keys(store).length;
37 |     }),
38 |     _getStore: () => ({ ...store }), // 테스트용 내부 메서드
39 |   };
40 | }
41 | 
42 | /**
43 |  * sessionStorage 모킹
44 |  * @returns 모의 sessionStorage 객체
45 |  */
46 | export function mockSessionStorage() {
47 |   return mockLocalStorage(); // 인터페이스가 동일하므로 localStorage 모킹 재사용
48 | }
49 | 
50 | /**
51 |  * 쿠키 모킹
52 |  * @returns 모의 document.cookie 작업을 위한 유틸리티
53 |  */
54 | export function mockCookies() {
55 |   let cookies: Record<string, string> = {};
56 | 
57 |   return {
58 |     get: vi.fn((name: string) => {
59 |       return cookies[name] || null;
60 |     }),
61 |     getAll: vi.fn(() => {
62 |       return Object.entries(cookies).map(([name, value]) => ({ name, value }));
63 |     }),
64 |     set: vi.fn((name: string, value: string = {}) => {
65 |       cookies[name] = value;
66 |     }),
67 |     delete: vi.fn((name: string) => {
68 |       delete cookies[name];
69 |     }),
70 |     has: vi.fn((name: string) => {
71 |       return name in cookies;
72 |     }),
73 |     clear: vi.fn(() => {
74 |       cookies = {};
75 |     }),
76 |     _getAll: () => ({ ...cookies }), // 테스트용 내부 메서드
77 |   };
78 | }
79 | 
80 | /**
81 |  * Web Crypto API 모킹
82 |  * @returns 모의 crypto 객체
83 |  */
84 | export function mockCrypto() {
85 |   return {
86 |     getRandomValues: vi.fn((array: Uint8Array) => {
87 |       // 예측 가능한 "랜덤" 값 생성 (테스트용)
88 |       for (let i = 0; i < array.length; i++) {
89 |         array[i] = i % 256;
90 |       }
91 |       return array;
92 |     }),
93 |     subtle: {
[TRUNCATED]
```

src/tests/mocks/supabase-mock.ts
```
1 | /**
2 |  * 파일명: supabase-mock.ts
3 |  * 목적: Supabase 클라이언트 모킹
4 |  * 역할: 테스트 환경에서 Supabase 인증 및 API 호출 시뮬레이션
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2023-10-27 : 타입 정의 개선 - Function 타입을 구체적인 함수 시그니처로 변경
7 |  */
8 | 
9 | import { User, Session } from '@supabase/supabase-js';
10 | import { vi } from 'vitest';
11 | 
12 | /**
13 |  * 모의 Supabase 세션 생성
14 |  * @param userId 사용자 ID
15 |  * @param provider 인증 공급자
16 |  * @returns 모의 세션 객체
17 |  */
18 | export function mockSupabaseSession(
19 |   userId: string = 'test_user_id', 
20 |   provider: string = 'google'
21 | ): Session {
22 |   return {
23 |     access_token: `mock_access_token_${userId}`,
24 |     refresh_token: `mock_refresh_token_${userId}`,
25 |     expires_in: 3600,
26 |     expires_at: Math.floor(Date.now() / 1000) + 3600,
27 |     token_type: 'bearer',
28 |     user: {
29 |       id: userId,
30 |       app_metadata: {
31 |         provider,
32 |         providers: [provider]
33 |       },
34 |       user_metadata: {
35 |         full_name: 'Test User',
36 |         avatar_url: 'https://example.com/avatar.png'
37 |       },
38 |       aud: 'authenticated',
39 |       created_at: new Date().toISOString(),
40 |       role: 'authenticated',
41 |       email: `${userId}@example.com`,
42 |     }
43 |   };
44 | }
45 | 
46 | /**
47 |  * 모의 Supabase 응답 생성
48 |  * @param data 응답 데이터
49 |  * @param error 응답 오류
50 |  * @returns 모의 Supabase 응답 객체
51 |  */
52 | export function mockSupabaseResponse<T>(data: T | null = null, error: Error | null = null) {
53 |   return { data, error };
54 | }
55 | 
56 | /**
57 |  * 클라이언트 환경 Supabase 모킹
58 |  * @returns 모의 Supabase 클라이언트
59 |  */
60 | export function mockSupabaseBrowserClient() {
61 |   // 기본 세션 및 사용자 상태
62 |   let currentSession: Session | null = null;
63 |   let currentUser: User | null = null;
64 |   let codeVerifier: string | null = null;
65 |   
66 |   // 상태 변경 콜백 저장
67 |   // 구체적인 함수 시그니처 정의
68 |   const authStateChangeCallbacks: Array<(event: string, session: Session | null) => void> = [];
69 | 
70 |   return {
71 |     auth: {
72 |       getSession: vi.fn(() => {
73 |         return Promise.resolve(mockSupabaseResponse(
74 |           { session: currentSession }, 
75 |           null
76 |         ));
77 |       }),
78 |       getUser: vi.fn(() => {
79 |         return Promise.resolve(mockSupabaseResponse(
80 |           { user: currentUser }, 
81 |           null
82 |         ));
83 |       }),
84 |       signInWithOAuth: vi.fn(({ provider, options }: any) => {
85 |         // PKCE 플로우 검증을 위한 옵션 저장
86 |         if (options.queryParams.code_challenge) {
[TRUNCATED]
```

src/tests/msw/handlers.ts
```
1 | /**
2 |  * 파일명: handlers.ts
3 |  * 목적: MSW 핸들러 정의
4 |  * 역할: API 요청을 가로채기 위한 MSW 핸들러 제공
5 |  * 작성일: 2025-03-30
6 |  * 수정일: 2025-04-08
7 |  * 수정일: 2023-10-27 : 린터 오류 수정 (미사용 변수 제거)
8 |  */
9 | 
10 | import { http, HttpResponse } from 'msw';
11 | 
12 | /**
13 |  * createMockSession: 모의 Supabase 세션 생성
14 |  * @param options - 세션 생성 옵션
15 |  * @returns 모의 세션 객체
16 |  */
17 | export function createMockSession(options: {
18 |   success?: boolean;
19 |   accessToken?: string;
20 |   refreshToken?: string;
21 |   userId?: string;
22 |   provider?: string;
23 |   errorMessage?: string;
24 | } = {}) {
25 |   const {
26 |     success = true,
27 |     accessToken = 'mock_access_token',
28 |     refreshToken = 'mock_refresh_token',
29 |     userId = 'mock_user_id',
30 |     provider = 'google',
31 |     errorMessage = '인증 실패',
32 |   } = options;
33 | 
34 |   if (success) {
35 |     return {
36 |       data: {
37 |         session: {
38 |           access_token: accessToken,
39 |           refresh_token: refreshToken,
40 |           user: {
41 |             id: userId,
42 |             app_metadata: { provider }
43 |           }
44 |         }
45 |       },
46 |       error: null
47 |     };
48 |   } else {
49 |     return {
50 |       data: { session: null },
51 |       error: { message: errorMessage, status: 401 }
52 |     };
53 |   }
54 | }
55 | 
56 | /**
57 |  * 카드 데이터 타입
58 |  */
59 | export interface CardData {
60 |   id: string;
61 |   title: string;
62 |   content: string;
63 |   cardTags: Array<{ id: string; name: string; }>;
64 | }
65 | 
66 | /**
67 |  * 카드 데이터 생성 함수
68 |  * @param id - 카드 ID
69 |  * @returns 카드 데이터 객체
70 |  */
71 | export function createMockCard(id: string = 'test-card-123'): CardData {
72 |   return {
73 |     id,
74 |     title: '테스트 카드',
75 |     content: '테스트 내용',
76 |     cardTags: []
77 |   };
78 | }
79 | 
80 | // Supabase 인증 API 엔드포인트 핸들러
81 | export const handlers = [
82 |   // Supabase 세션 교환 API 모킹
83 |   http.post('*/auth/v1/token*', async ({ request }) => {
84 |     // URL 파라미터를 사용하여 성공 또는 실패 시나리오 결정
85 |     const url = new URL(request.url);
86 |     const mockFail = url.searchParams.get('mock_fail') === 'true';
87 |     const mockTimeout = url.searchParams.get('mock_timeout') === 'true';
88 | 
89 |     // 타임아웃 시뮬레이션
90 |     if (mockTimeout) {
91 |       await new Promise(resolve => setTimeout(resolve, 10000));
92 |     }
93 | 
94 |     // 요청 데이터 파싱
95 |     const formData = await request.formData();
[TRUNCATED]
```

src/tests/msw/server.ts
```
1 | /**
2 |  * 파일명: server.ts
3 |  * 목적: MSW 테스트 서버 설정
4 |  * 역할: API 요청을 모킹하기 위한 MSW 서버 제공
5 |  * 작성일: 2025-03-30
6 |  * 수정일: 2025-04-09
7 |  */
8 | 
9 | import { HttpResponse } from 'msw';
10 | import { setupServer } from 'msw/node';
11 | 
12 | import createLogger from '@/lib/logger';
13 | 
14 | import { handlers } from './handlers';
15 | 
16 | // 로거 생성
17 | const logger = createLogger('MSWServer');
18 | 
19 | // MSW 서버 설정
20 | export const server = setupServer(...handlers);
21 | 
22 | // Node.js v20에서 문제가 발생하는 요청에 대한 즉각 응답 처리
23 | server.events.on('request:start', ({ request }) => {
24 |   try {
25 |     // URL 패턴 검사
26 |     const url = new URL(request.url);
27 |     
28 |     // 문제가 발생할 수 있는 URL 패턴 처리
29 |     if (url.pathname.includes('problem-url')) {
30 |       logger.warn('문제가 있는 URL 요청 감지, 즉시 응답 처리', { url: url.toString() });
31 |       return HttpResponse.json({ error: 'Simulated error' }, { status: 500 });
32 |     }
33 |     
34 |     // auth 관련 요청은 즉시 응답 처리하여 타임아웃 방지
35 |     if (url.pathname.includes('/auth/v1/token')) {
36 |       logger.debug('인증 관련 요청 감지, 빠른 응답 처리', { url: url.toString() });
37 |       return HttpResponse.json({
38 |         access_token: 'test_access_token',
39 |         refresh_token: 'test_refresh_token',
40 |         token_type: 'bearer',
41 |         expires_in: 3600,
42 |         user: {
43 |           id: 'test_user_id',
44 |           app_metadata: { provider: 'google' },
45 |           aud: 'authenticated',
46 |           email: 'test@example.com'
47 |         }
48 |       });
49 |     }
50 |     
51 |     return undefined;
52 |   } catch (error) {
53 |     logger.error('요청 처리 중 오류 발생', { error });
54 |     return HttpResponse.json({ error: 'internal_error' }, { status: 500 });
55 |   }
56 | });
57 | 
58 | /**
59 |  * setupMSW: 테스트에서 MSW 서버 설정
60 |  * @returns 정리 함수
61 |  */
62 | export function setupMSW() {
63 |   // 테스트 전 서버 시작
64 |   beforeEach(() => {
65 |     server.listen({ 
66 |       onUnhandledRequest: 'bypass' // warn 대신 bypass 사용
67 |     });
68 |     logger.info('MSW 서버 시작됨');
69 |   });
70 | 
71 |   // 테스트 후 핸들러 초기화
72 |   afterEach(() => {
73 |     server.resetHandlers();
74 |     logger.info('MSW 핸들러 초기화됨');
75 |   });
76 | 
77 |   // 모든 테스트 완료 후 서버 종료
78 |   afterAll(() => {
79 |     server.close();
80 |     logger.info('MSW 서버 종료됨');
81 |   });
82 | 
83 |   // 추가 핸들러 등록 함수 반환
84 |   return {
85 |     // 핸들러 추가
86 |     use: (...handlers: Parameters<typeof server.use>) => {
87 |       server.use(...handlers);
[TRUNCATED]
```

src/tests/theme/integration.test.tsx
```
1 | /**
2 |  * 파일명: integration.test.tsx
3 |  * 목적: 테마 관련 컴포넌트 통합 테스트
4 |  * 역할: ThemeContext와 NodeSizeSettings의 통합 검증
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2023-10-27 : 린터 오류 수정 (미사용 변수 제거)
7 |  */
8 | 
9 | import React from 'react';
10 | 
11 | import { render, screen, fireEvent } from '@testing-library/react';
12 | import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
13 | import '@testing-library/jest-dom/vitest';
14 | 
15 | // updateNodeSize 모킹 함수
16 | const updateNodeSizeMock = vi.fn();
17 | const updateNodeInternalsMock = vi.fn();
18 | 
19 | // ReactFlow 모킹
20 | vi.mock('@xyflow/react', () => {
21 |   return {
22 |     useReactFlow: () => ({
23 |       getNodes: () => [{ id: 'node-1' }, { id: 'node-2' }],
24 |     }),
25 |     useUpdateNodeInternals: () => updateNodeInternalsMock,
26 |     ReactFlowProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
27 |   };
28 | });
29 | 
30 | // ThemeContext 모킹
31 | vi.mock('../../contexts/ThemeContext', () => {
32 |   return {
33 |     ThemeProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
34 |     useTheme: () => ({
35 |       theme: {
36 |         node: {
37 |           width: 220,
38 |           height: 48,
39 |           maxHeight: 180,
40 |           backgroundColor: '#ffffff',
41 |           borderColor: '#C1C1C1',
42 |           borderWidth: 1,
43 |           borderRadius: 8,
44 |           selectedBorderColor: '#0071e3',
45 |           font: {
46 |             family: 'Pretendard, sans-serif',
47 |             titleSize: 14,
48 |             contentSize: 12,
49 |             tagsSize: 10,
50 |           }
51 |         },
52 |         edge: {
53 |           color: '#C1C1C1',
54 |           width: 1,
55 |           selectedColor: '#0071e3',
56 |           animated: false,
57 |         },
58 |         handle: {
59 |           size: 8,
60 |           backgroundColor: '#ffffff',
61 |           borderColor: '#555555',
62 |           borderWidth: 1,
63 |         },
64 |         layout: {
65 |           spacing: {
66 |             horizontal: 30,
67 |             vertical: 30,
68 |           },
69 |           padding: 20,
70 |         },
71 |       },
72 |       updateTheme: vi.fn(),
73 |       updateNodeSize: updateNodeSizeMock,
74 |     }),
75 |   };
76 | });
77 | 
78 | // NodeSizeSettings 모킹
79 | vi.mock('../../components/settings/NodeSizeSettings', () => {
80 |   return {
81 |     NodeSizeSettings: () => {
82 |       React.useEffect(() => {
83 |         // 컴포넌트가 마운트될 때 테스트 데이터 설정
84 |         setTimeout(() => {
85 |           // 다른 테스트에서 호출됨
86 |         }, 0);
87 |       }, []);
88 | 
89 |       return (
90 |         <div>
91 |           <label>너비: <span>220px</span></label>
92 |           <input data-testid="width-input" type="number" />
93 |           <label>헤더 높이: <span>48px</span></label>
94 |           <input data-testid="height-input" type="number" />
95 |           <button
96 |             data-testid="apply-button"
97 |             onClick={() => updateNodeSizeMock(200, 60, 250)}
98 |           >
99 |             변경사항 적용
100 |           </button>
[TRUNCATED]
```

src/tests/utils/async-utils.ts
```
1 | /**
2 |  * 파일명: async-utils.ts
3 |  * 목적: 비동기 테스트 유틸리티 제공
4 |  * 역할: 비동기 테스트에 필요한 유틸리티 함수 제공
5 |  * 작성일: 2025-03-30
6 |  * 수정일: 2023-10-27 : ESLint 오류 수정 (미사용 변수 제거)
7 |  */
8 | 
9 | import { vi } from 'vitest';
10 | 
11 | /**
12 |  * flushPromises: 비동기 큐의 모든 프로미스를 해결
13 |  * @returns {Promise<void>} 비동기 큐가 비워질 때까지 기다리는 프로미스
14 |  */
15 | export async function flushPromises(times = 1): Promise<void> {
16 |   for (let i = 0; i < times; i++) {
17 |     // 현재 큐의 모든 비동기 작업 실행
18 |     await new Promise(resolve => setTimeout(resolve, 0));
19 |   }
20 | }
21 | 
22 | /**
23 |  * runAllTimers: 모든 타이머를 즉시 실행
24 |  * @returns {Promise<void>} 타이머 실행 완료 대기
25 |  */
26 | export async function runAllTimers(): Promise<void> {
27 |   // 모든 타이머 즉시 실행
28 |   vi.runAllTimers();
29 |   
30 |   // 타이머 이후 발생한 비동기 작업 처리
31 |   await flushPromises();
32 | }
33 | 
34 | /**
35 |  * runTimersUntil: 특정 조건이 충족될 때까지 타이머 실행
36 |  * @param condition 타이머 중단 조건
37 |  * @param options 옵션 (최대 타이머, 타임아웃)
38 |  */
39 | export async function runTimersUntil(
40 |   condition: () => boolean | Promise<boolean>,
41 |   options: { maxTimers?: number; timeout?: number } = {}
42 | ): Promise<void> {
43 |   const { maxTimers = 100, timeout = 5000 } = options;
44 |   const startTime = Date.now();
45 |   
46 |   for (let i = 0; i < maxTimers; i++) {
47 |     // 타임아웃 체크
48 |     if (Date.now() - startTime > timeout) {
49 |       throw new Error(`타임아웃: ${timeout}ms 안에 조건이 충족되지 않음`);
50 |     }
51 |     
52 |     // 타이머 실행 및 비동기 큐 비우기
53 |     vi.advanceTimersByTime(100);
54 |     await flushPromises();
55 |     
56 |     // 조건 체크
57 |     if (await condition()) {
58 |       return;
59 |     }
60 |   }
61 |   
62 |   throw new Error(`최대 타이머 실행(${maxTimers}) 후에도 조건이 충족되지 않음`);
63 | }
64 | 
65 | /**
66 |  * pollUntil: 조건이 충족될 때까지 폴링
67 |  * @param condition 폴링 중단 조건
68 |  * @param options 옵션 (간격, 타임아웃, 최대 시도 횟수)
69 |  */
70 | export async function pollUntil<T>(
71 |   condition: () => T | Promise<T>,
72 |   options: { interval?: number; timeout?: number; maxTries?: number } = {}
73 | ): Promise<T> {
74 |   const { interval = 50, timeout = 5000, maxTries = 100 } = options;
75 |   const startTime = Date.now();
76 |   let tries = 0;
77 |   
78 |   while (tries < maxTries) {
79 |     tries++;
80 |     
81 |     // 타임아웃 체크
82 |     if (Date.now() - startTime > timeout) {
[TRUNCATED]
```

src/tests/utils/react-flow-mock.ts
```
1 | /**
2 |  * 파일명: react-flow-mock.ts
3 |  * 목적: React Flow 컴포넌트 테스트를 위한 모킹 유틸리티
4 |  * 역할: 테스트 환경에서 React Flow에 필요한 브라우저 환경 API 모킹
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2023-10-27 : any 타입을 구체적인 타입으로 변경
7 |  */
8 | 
9 | // React Flow 공식 문서에서 제시하는 테스트 유틸리티 구현
10 | 
11 | /**
12 |  * ResizeObserver 모의 구현
13 |  * 브라우저 환경이 아닌 Jest/Vitest에서 동작하기 위한 구현체
14 |  */
15 | class ResizeObserver {
16 |   callback: ResizeObserverCallback;
17 | 
18 |   constructor(callback: ResizeObserverCallback) {
19 |     this.callback = callback;
20 |   }
21 | 
22 |   observe(target: Element) {
23 |     this.callback([{ target } as ResizeObserverEntry], this);
24 |   }
25 | 
26 |   unobserve() {}
27 | 
28 |   disconnect() {}
29 | }
30 | 
31 | /**
32 |  * DOMMatrixReadOnly 모의 구현
33 |  * 브라우저 환경이 아닌 Jest/Vitest에서 동작하기 위한 구현체
34 |  */
35 | class DOMMatrixReadOnly {
36 |   m22: number;
37 |   constructor(transform: string) {
38 |     const scale = transform?.match(/scale\(([1-9.])\)/)?.[1];
39 |     this.m22 = scale !== undefined ? +scale : 1;
40 |   }
41 | }
42 | 
43 | // 모킹이 한 번만 초기화되도록 플래그 관리
44 | let init = false;
45 | 
46 | /**
47 |  * mockReactFlow: React Flow를 모킹하는 함수
48 |  * Jest/Vitest 테스트 환경에서 React Flow 사용 시 필요한 브라우저 API 모킹
49 |  */
50 | export const mockReactFlow = () => {
51 |   if (init) return;
52 |   init = true;
53 | 
54 |   // 전역 객체에 ResizeObserver 추가
55 |   global.ResizeObserver = ResizeObserver as unknown as typeof global.ResizeObserver;
56 | 
57 |   // 전역 객체에 DOMMatrixReadOnly 추가
58 |   global.DOMMatrixReadOnly = DOMMatrixReadOnly as unknown as typeof global.DOMMatrixReadOnly;
59 | 
60 |   // HTMLElement에 offsetHeight, offsetWidth 속성 추가
61 |   Object.defineProperties(global.HTMLElement.prototype, {
62 |     offsetHeight: {
63 |       get() {
64 |         return parseFloat(this.style.height) || 1;
65 |       },
66 |     },
67 |     offsetWidth: {
68 |       get() {
69 |         return parseFloat(this.style.width) || 1;
70 |       },
71 |     },
72 |   });
73 | 
74 |   // SVGElement에 getBBox 메서드 추가
75 |   (global.SVGElement.prototype as unknown as { getBBox: () => { x: number; y: number; width: number; height: number } }).getBBox = () => ({
76 |     x: 0,
77 |     y: 0,
78 |     width: 0,
79 |     height: 0,
80 |   });
81 | }; 
```

src/app/admin/logs/LogViewerPageMock.tsx
```
1 | /**
2 |  * 파일명: LogViewerPageMock.tsx
3 |  * 목적: 로그 뷰어 페이지 테스트를 위한 모킹 컴포넌트
4 |  * 역할: 실제 컴포넌트의 동작을 시뮬레이션
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2024-05-21 : import 순서 수정
7 |  */
8 | 
9 | import React, { useState } from 'react'
10 | 
11 | import { Log, mockLogs, mockModules } from '@/tests/msw/handlers/logs'
12 | 
13 | export const LogViewerPageMock: React.FC = () => {
14 |     const [selectedModule, setSelectedModule] = useState('')
15 |     const [selectedLevel, setSelectedLevel] = useState('')
16 |     const [logData, setLogData] = useState<Log[]>(mockLogs)
17 |     const [showError, setShowError] = useState(false)
18 |     const [showEmpty, setShowEmpty] = useState(false)
19 |     const [showDetail, setShowDetail] = useState(false)
20 |     const [selectedLog, setSelectedLog] = useState<Log | null>(null)
21 | 
22 |     const handleFilterApply = () => {
23 |         // 에러 시뮬레이션
24 |         if (selectedModule === 'error-trigger') {
25 |             setShowError(true)
26 |             setShowEmpty(false)
27 |             setLogData([])
28 |             return
29 |         }
30 | 
31 |         // 빈 결과 시뮬레이션
32 |         if (selectedModule === 'empty-trigger') {
33 |             setShowError(false)
34 |             setShowEmpty(true)
35 |             setLogData([])
36 |             return
37 |         }
38 | 
39 |         // 일반 필터링 시뮬레이션
40 |         setShowError(false)
41 |         setShowEmpty(false)
42 | 
43 |         let filtered = [...mockLogs]
44 |         if (selectedModule) {
45 |             filtered = filtered.filter(log => log.module === selectedModule)
46 |         }
47 |         if (selectedLevel) {
48 |             filtered = filtered.filter(log => log.level === selectedLevel)
49 |         }
50 | 
51 |         setLogData(filtered)
52 |     }
53 | 
54 |     const handleFilterReset = () => {
55 |         setSelectedModule('')
56 |         setSelectedLevel('')
57 |         setShowError(false)
58 |         setShowEmpty(false)
59 |         setLogData(mockLogs)
60 |     }
61 | 
62 |     const handleLogClick = (log: Log) => {
63 |         setSelectedLog(log)
64 |         setShowDetail(true)
65 |     }
66 | 
67 |     const handleCloseDetail = () => {
68 |         setShowDetail(false)
69 |         setSelectedLog(null)
70 |     }
71 | 
72 |     return (
73 |         <div>
74 |             <h1>로그 뷰어</h1>
75 | 
76 |             {/* 필터 컨트롤 */}
77 |             <div>
78 |                 <label htmlFor="module">모듈</label>
79 |                 <select
80 |                     id="module"
81 |                     value={selectedModule}
82 |                     onChange={(e) => setSelectedModule(e.target.value)}
83 |                     data-testid="module-select"
84 |                 >
85 |                     <option value="">모든 모듈</option>
86 |                     {mockModules.map((module: string) => (
87 |                         <option key={module} value={module}>{module}</option>
88 |                     ))}
89 |                     <option value="error-trigger">에러 트리거</option>
90 |                     <option value="empty-trigger">빈 결과 트리거</option>
91 |                 </select>
92 | 
93 |                 <label htmlFor="level">레벨</label>
94 |                 <select
[TRUNCATED]
```

src/app/admin/logs/page.test.tsx
```
1 | /**
2 |  * 파일명: src/app/admin/logs/page.test.tsx
3 |  * 목적: 로그 뷰어 관리자 페이지 테스트
4 |  * 역할: 로그 조회 및 필터링 기능 테스트
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-01
7 |  * 수정일: 2024-05-21 : import 순서 수정
8 |  * 수정일: 2024-05-22 : import 순서 오류 수정
9 |  * 수정일: 2024-05-23 : import 순서 및 그룹화 오류 수정
10 |  */
11 | 
12 | import { render, screen, fireEvent } from '@testing-library/react'
13 | import { describe, expect, it, vi, beforeEach, afterEach } from 'vitest'
14 | 
15 | import '@testing-library/jest-dom/vitest'
16 | 
17 | import { mockLogs } from '@/tests/msw/handlers/logs'
18 | 
19 | import { LogViewerPageMock } from './LogViewerPageMock'
20 | import { setupLogViewerTests, teardownLogViewerTests } from './test-utils'
21 | 
22 | // Next.js 모킹
23 | vi.mock('next/navigation', () => ({
24 |   useRouter: () => ({
25 |     push: vi.fn(),
26 |     replace: vi.fn(),
27 |     prefetch: vi.fn(),
28 |     back: vi.fn()
29 |   }),
30 |   useSearchParams: () => new URLSearchParams()
31 | }))
32 | 
33 | describe('LogViewerPage', () => {
34 |   beforeEach(() => {
35 |     setupLogViewerTests()
36 |   })
37 | 
38 |   afterEach(() => {
39 |     teardownLogViewerTests()
40 |   })
41 | 
42 |   describe('기본 UI 렌더링', () => {
43 |     it('페이지 타이틀과 필터 컨트롤이 올바르게 표시되어야 함', () => {
44 |       render(<LogViewerPageMock />)
45 | 
46 |       // 페이지 타이틀 확인
47 |       expect(screen.getByText('로그 뷰어')).toBeInTheDocument()
48 | 
49 |       // 필터 컨트롤 확인
50 |       expect(screen.getByLabelText('모듈')).toBeInTheDocument()
51 |       expect(screen.getByLabelText('레벨')).toBeInTheDocument()
52 |       expect(screen.getByLabelText('로그 수')).toBeInTheDocument()
53 |       expect(screen.getByText('필터 적용')).toBeInTheDocument()
54 |       expect(screen.getByText('필터 초기화')).toBeInTheDocument()
55 |     })
56 | 
57 |     it('초기 로그 목록이 올바르게 표시되어야 함', () => {
58 |       render(<LogViewerPageMock />)
59 |       expect(screen.getByText(mockLogs[0].message)).toBeInTheDocument()
60 |     })
61 |   })
62 | 
63 |   describe('필터 기능', () => {
64 |     it('모듈 필터가 올바르게 작동해야 함', () => {
65 |       render(<LogViewerPageMock />)
66 | 
67 |       const moduleSelect = screen.getByTestId('module-select')
68 |       fireEvent.change(moduleSelect, { target: { value: 'auth' } })
69 | 
70 |       const applyButton = screen.getByTestId('apply-filter')
71 |       fireEvent.click(applyButton)
72 | 
73 |       const filteredLogs = mockLogs.filter(log => log.module === 'auth')
74 |       expect(screen.getByText(filteredLogs[0].message)).toBeInTheDocument()
75 |     })
76 | 
77 |     it('레벨 필터가 올바르게 작동해야 함', () => {
78 |       render(<LogViewerPageMock />)
79 | 
80 |       const levelSelect = screen.getByTestId('level-select')
81 |       fireEvent.change(levelSelect, { target: { value: 'error' } })
82 | 
[TRUNCATED]
```

src/app/admin/logs/page.tsx
```
1 | /**
2 |  * 파일명: page.tsx
3 |  * 목적: 로그 뷰어 관리자 페이지
4 |  * 역할: 애플리케이션 로그를 조회하고 필터링하는 인터페이스 제공
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2023-10-27 : ESLint 오류 수정 (any 타입 제거, useEffect 의존성 배열 수정)
7 |  * 수정일: 2023-10-27 : fetchLogs를 useCallback으로 감싸 무한 렌더링 방지
8 |  * 수정일: 2024-05-21 : import 순서 수정
9 |  * 수정일: 2024-05-22 : import 순서 오류 수정
10 |  */
11 | 
12 | 'use client';
13 | 
14 | import { useEffect, useState, useCallback } from 'react';
15 | 
16 | import { useRouter } from 'next/navigation';
17 | 
18 | interface LogEntry {
19 |   timestamp: string;
20 |   level: string;
21 |   module: string;
22 |   message: string;
23 |   data?: Record<string, unknown>;
24 |   sessionId?: string;
25 |   serverTimestamp?: string;
26 | }
27 | 
28 | export default function LogViewerPage() {
29 |   const router = useRouter();
30 |   const [logs, setLogs] = useState<LogEntry[]>([]);
31 |   const [loading, setLoading] = useState(true);
32 |   const [error, setError] = useState<string | null>(null);
33 |   const [modules, setModules] = useState<string[]>([]);
34 |   const [sessionIds, setSessionIds] = useState<string[]>([]);
35 | 
36 |   // 필터링 상태
37 |   const [selectedModule, setSelectedModule] = useState<string>('');
38 |   const [selectedLevel, setSelectedLevel] = useState<string>('');
39 |   const [selectedSessionId, setSelectedSessionId] = useState<string>('');
40 |   const [limit, setLimit] = useState(100);
41 | 
42 |   // 로그 데이터 가져오기
43 |   const fetchLogs = useCallback(async () => {
44 |     try {
45 |       setLoading(true);
46 | 
47 |       // 필터 파라미터 구성
48 |       const params = new URLSearchParams();
49 |       if (selectedModule) params.append('module', selectedModule);
50 |       if (selectedLevel) params.append('level', selectedLevel);
51 |       if (selectedSessionId) params.append('sessionId', selectedSessionId);
52 |       params.append('limit', limit.toString());
53 | 
54 |       const response = await fetch(`/api/logs/view?${params.toString()}`);
55 | 
56 |       if (!response.ok) {
57 |         throw new Error(`서버 오류: ${response.status} ${response.statusText}`);
58 |       }
59 | 
60 |       const data = await response.json();
61 | 
62 |       setLogs(data.logs || []);
63 |       setModules(data.modules || []);
64 |       setSessionIds(data.sessionIds || []);
65 |       setError(null);
66 |     } catch (err: unknown) {
67 |       const errorMessage = err instanceof Error ? err.message : '로그를 가져오는 중 오류가 발생했습니다.';
68 |       setError(errorMessage);
69 |       console.error('로그 가져오기 오류:', err);
70 |     } finally {
71 |       setLoading(false);
72 |     }
73 |   }, [selectedModule, selectedLevel, selectedSessionId, limit]);
74 | 
75 |   // 컴포넌트 마운트 시 로그 가져오기
76 |   useEffect(() => {
77 |     fetchLogs();
78 |   }, [fetchLogs]);
79 | 
80 |   // 필터 변경 시 로그 새로고침
[TRUNCATED]
```

src/app/admin/logs/test-utils.ts
```
1 | /**
2 |  * 파일명: src/app/admin/logs/test-utils.ts
3 |  * 목적: 로그 뷰어 테스트를 위한 유틸리티 함수
4 |  * 역할: 테스트 설정과 해제를 담당
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2024-05-21 : import 순서 수정
7 |  * 수정일: 2024-05-22 : import 순서 오류 수정
8 |  * 수정일: 2024-05-23 : import 순서 및 그룹화 오류 수정
9 |  */
10 | 
11 | import { http, HttpResponse } from 'msw'
12 | import { vi } from 'vitest'
13 | 
14 | import { mockLogs, mockModules, mockSessionIds } from '@/tests/msw/handlers/logs'
15 | import { server } from '@/tests/msw/server'
16 | 
17 | // API 응답에 사용할 기본 데이터
18 | const defaultApiResponse = {
19 |   logs: mockLogs,
20 |   modules: mockModules,
21 |   sessionIds: mockSessionIds,
22 |   levels: ['debug', 'info', 'warn', 'error'],
23 |   total: mockLogs.length,
24 |   filtered: mockLogs.length
25 | }
26 | 
27 | /**
28 |  * setupLogViewerTests: 로그 뷰어 테스트를 위한 환경을 설정
29 |  */
30 | export const setupLogViewerTests = () => {
31 |   // API 성공 응답 설정
32 |   server.use(
33 |     http.get('/api/logs/view', () => {
34 |       return HttpResponse.json(defaultApiResponse)
35 |     })
36 |   )
37 | }
38 | 
39 | /**
40 |  * teardownLogViewerTests: 로그 뷰어 테스트 환경을 정리
41 |  */
42 | export const teardownLogViewerTests = () => {
43 |   server.resetHandlers()
44 |   vi.clearAllMocks()
45 | } 
```

src/app/api/db-init/route.ts
```
1 | /**
2 |  * 파일명: src/app/api/db-init/route.ts
3 |  * 목적: 데이터베이스 초기화를 위한 API 엔드포인트 제공
4 |  * 역할: 개발 환경에서 데이터베이스를 초기화하는 API를 처리
5 |  * 작성일: 2023-11-01
6 |  * 수정일: 2024-05-31 : 사용하지 않는 request 매개변수 제거
7 |  * 수정일: 2024-06-26 : 사용하지 않는 NextRequest import 제거
8 |  */
9 | import { NextResponse } from 'next/server';
10 | 
11 | import { initDatabase } from '@/lib/db-init';
12 | 
13 | /**
14 |  * DB 초기화 API 엔드포인트
15 |  * 개발 환경에서만 사용 가능
16 |  */
17 | export async function GET() {
18 |   // 개발 환경인지 확인
19 |   if (process.env.NODE_ENV !== 'development') {
20 |     return NextResponse.json(
21 |       { error: '이 API는 개발 환경에서만 사용 가능합니다.' },
22 |       { status: 403 }
23 |     );
24 |   }
25 | 
26 |   try {
27 |     await initDatabase();
28 |     
29 |     return NextResponse.json(
30 |       { success: true, message: '데이터베이스 초기화가 완료되었습니다.' },
31 |       { status: 200 }
32 |     );
33 |   } catch (error) {
34 |     console.error('DB 초기화 API 오류:', error);
35 |     
36 |     return NextResponse.json(
37 |       { 
38 |         success: false, 
39 |         message: '데이터베이스 초기화 중 오류가 발생했습니다.', 
40 |         error: error instanceof Error ? error.message : String(error) 
41 |       },
42 |       { status: 500 }
43 |     );
44 |   }
45 | } 
```

src/app/api/cards/route.ts
```
1 | /**
2 |  * 파일명: src/app/api/cards/route.ts
3 |  * 목적: 카드 API 엔드포인트
4 |  * 역할: 카드 생성 및 조회 기능 제공
5 |  * 작성일: 2024-05-22
6 |  */
7 | 
8 | import { NextRequest, NextResponse } from 'next/server';
9 | 
10 | import { z } from 'zod';
11 | 
12 | import prisma from '@/lib/prisma';
13 | 
14 | // 카드 생성 스키마
15 | const createCardSchema = z.object({
16 |   title: z.string().min(1, '제목은 필수입니다.'),
17 |   content: z.string().optional(),
18 |   userId: z.string().uuid('유효한 사용자 ID가 필요합니다.'),
19 |   tags: z.array(z.string()).optional()
20 | });
21 | 
22 | // 태그 처리 함수
23 | async function processTagsForCard(cardId: string, tagNames: string[] = []) {
24 |   try {
25 |     // 중복 태그 제거 및 공백 제거
26 |     const uniqueTags = [...new Set(tagNames.map(tag => tag.trim()))].filter(tag => tag.length > 0);
27 |     
28 |     // 카드와 연결된 기존 태그 삭제
29 |     await prisma.cardTag.deleteMany({
30 |       where: { cardId }
31 |     });
32 |     
33 |     // 각 태그에 대해 처리
34 |     for (const tagName of uniqueTags) {
35 |       // 태그가 존재하는지 확인하고, 없으면 생성
36 |       let tag = await prisma.tag.findUnique({
37 |         where: { name: tagName }
38 |       });
39 |       
40 |       if (!tag) {
41 |         tag = await prisma.tag.create({
42 |           data: { name: tagName }
43 |         });
44 |       }
45 |       
46 |       // 카드와 태그 연결
47 |       await prisma.cardTag.create({
48 |         data: {
49 |           cardId,
50 |           tagId: tag.id
51 |         }
52 |       });
53 |     }
54 |   } catch (error) {
55 |     console.error('태그 처리 중 오류:', error);
56 |     // 태그 처리 실패해도 흐름 계속 (태그는 필수가 아님)
57 |   }
58 | }
59 | 
60 | // 데이터베이스 연결 안전하게 수행하는 래퍼 함수
61 | async function safeDbOperation<T>(operation: () => Promise<T>, errorMessage: string): Promise<{ data: T | null; error: string | null }> {
62 |   try {
63 |     const result = await operation();
64 |     return { data: result, error: null };
65 |   } catch (error) {
66 |     console.error(`${errorMessage}:`, error);
67 |     return { data: null, error: errorMessage };
68 |   }
69 | }
70 | 
71 | // 카드 생성 API
72 | export async function POST(request: NextRequest) {
73 |   try {
74 |     // 요청 본문 파싱 안전하게 처리
75 |     let body;
76 |     try {
77 |       body = await request.json();
78 |     } catch (jsonError) {
79 |       console.error('요청 본문 파싱 오류:', jsonError);
80 |       return NextResponse.json(
81 |         { error: '유효하지 않은 요청 형식입니다.' },
82 |         { status: 400 }
83 |       );
84 |     }
85 |     
86 |     // 데이터 유효성 검사
[TRUNCATED]
```

src/app/api/ideamap-settings/route.ts
```
1 | /**
2 |  * 파일명: src/app/api/ideamap-settings/route.ts
3 |  * 목적: 아이디어맵 설정 관리 API
4 |  * 역할: 사용자별 아이디어맵 설정의 CRUD 기능 제공
5 |  * 작성일: 2024-05-22
6 |  */
7 | 
8 | import { NextRequest, NextResponse } from 'next/server';
9 | 
10 | import { z } from 'zod';
11 | 
12 | import prisma from '@/lib/prisma';
13 | 
14 | // 아이디어맵 설정 스키마
15 | const ideaMapSettingsSchema = z.object({
16 |   userId: z.string().uuid('유효한 사용자 ID가 필요합니다.'),
17 |   settings: z.object({
18 |     snapToGrid: z.boolean(),
19 |     snapGrid: z.tuple([z.number(), z.number()]),
20 |     connectionLineType: z.string(),
21 |     markerEnd: z.string().nullable(),
22 |     strokeWidth: z.number(),
23 |     markerSize: z.number(),
24 |     edgeColor: z.string(),
25 |     selectedEdgeColor: z.string(),
26 |     animated: z.boolean()
27 |   })
28 | });
29 | 
30 | // 부분 업데이트용 아이디어맵 설정 스키마 (더 유연한 검사)
31 | const partialIdeaMapSettingsSchema = z.object({
32 |   userId: z.string(), // UUID 검사 제거하여 더 유연하게 함
33 |   settings: z.object({
34 |     snapToGrid: z.boolean().optional(),
35 |     snapGrid: z.tuple([z.number(), z.number()]).optional(),
36 |     connectionLineType: z.string().optional(),
37 |     markerEnd: z.union([z.string(), z.null()]).optional(), // 문자열 또는 null 허용
38 |     strokeWidth: z.number().optional(),
39 |     markerSize: z.number().optional(),
40 |     edgeColor: z.string().optional(),
41 |     selectedEdgeColor: z.string().optional(),
42 |     animated: z.boolean().optional()
43 |   }).partial()
44 | });
45 | 
46 | // 아이디어맵 설정 저장 API
47 | export async function POST(request: NextRequest) {
48 |   try {
49 |     const body = await request.json();
50 |     const { userId, settings } = ideaMapSettingsSchema.parse(body);
51 | 
52 |     // 기존 설정이 있는지 확인
53 |     const existingSettings = await prisma.boardSettings.findUnique({
54 |       where: { userId }
55 |     });
56 | 
57 |     // 설정 업데이트 또는 생성
58 |     if (existingSettings) {
59 |       await prisma.boardSettings.update({
60 |         where: { userId },
61 |         data: {
62 |           settings: settings
63 |         }
64 |       });
65 |     } else {
66 |       await prisma.boardSettings.create({
67 |         data: {
68 |           userId,
69 |           settings
70 |         }
71 |       });
72 |     }
73 | 
74 |     return NextResponse.json({ success: true }, { status: 200 });
75 |   } catch (error) {
76 |     console.error('아이디어맵 설정 저장 실패:', error);
77 |     return NextResponse.json({ error: '아이디어맵 설정을 저장하는 데 실패했습니다.' }, { status: 500 });
78 |   }
79 | }
80 | 
81 | // 아이디어맵 설정 업데이트 API
82 | export async function PUT(request: NextRequest) {
83 |   try {
84 |     const body = await request.json();
85 |     const { userId, settings } = ideaMapSettingsSchema.parse(body);
86 | 
[TRUNCATED]
```

src/app/api/health-check/route.ts
```
1 | /**
2 |  * 파일명: src/app/api/health-check/route.ts
3 |  * 목적: 데이터베이스 연결 상태를 확인하는 헬스 체크 API
4 |  * 역할: 애플리케이션의 서버와 데이터베이스 연결 상태를 모니터링
5 |  * 작성일: 2023-10-27
6 |  * 수정일: 2024-05-17 : 사용하지 않는 request 매개변수 제거
7 |  * 수정일: 2024-05-17 : 사용하지 않는 NextRequest 가져오기 제거
8 |  */
9 | import { NextResponse } from 'next/server';
10 | 
11 | import prisma from '@/lib/prisma';
12 | 
13 | /**
14 |  * DB 연결 상태를 확인하는 헬스 체크 API
15 |  * HEAD 또는 GET 요청 모두 사용 가능
16 |  */
17 | export async function HEAD() {
18 |   try {
19 |     // Prisma로 간단한 쿼리 실행하여 DB 연결 확인
20 |     await prisma.$queryRaw`SELECT 1`;
21 |     
22 |     // 응답 본문 없이 200 OK만 반환
23 |     return new NextResponse(null, { status: 200 });
24 |   } catch (error) {
25 |     console.error('DB 연결 실패:', error);
26 |     return new NextResponse(null, { status: 503 }); // Service Unavailable
27 |   }
28 | }
29 | 
30 | export async function GET() {
31 |   try {
32 |     // Prisma로 간단한 쿼리 실행하여 DB 연결 확인
33 |     await prisma.$queryRaw`SELECT 1`;
34 |     
35 |     return NextResponse.json({ status: 'ok', message: 'Database connection successful' });
36 |   } catch (error) {
37 |     console.error('DB 연결 실패:', error);
38 |     
39 |     return NextResponse.json(
40 |       { status: 'error', message: 'Database connection failed' },
41 |       { status: 503 } // Service Unavailable
42 |     );
43 |   }
44 | } 
```

src/app/api/tags/route.ts
```
1 | /**
2 |  * 파일명: src/app/api/tags/route.ts
3 |  * 목적: 태그 관련 API 엔드포인트 제공
4 |  * 역할: 태그 목록 조회, 태그 사용 횟수 집계, 태그 생성 등 기능 제공
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-03-27
7 |  */
8 | 
9 | import { NextRequest, NextResponse } from 'next/server';
10 | 
11 | import { auth } from '@/lib/auth-server';
12 | import prisma from '@/lib/prisma';
13 | 
14 | /**
15 |  * GET: 태그 목록을 반환하는 API
16 |  * @param request - 요청 객체
17 |  * @returns 태그 목록 및 사용 횟수
18 |  */
19 | export async function GET(request: NextRequest) {
20 |   try {
21 |     const searchParams = request.nextUrl.searchParams;
22 |     const includeCount = searchParams.get('includeCount') === 'true';
23 |     const searchQuery = searchParams.get('q') || '';
24 |     
25 |     if (includeCount) {
26 |       // 사용 횟수와 함께 태그 목록 반환
27 |       const tags = await prisma.tag.findMany({
28 |         where: {
29 |           name: {
30 |             contains: searchQuery,
31 |           },
32 |         },
33 |         include: {
34 |           _count: {
35 |             select: { cardTags: true },
36 |           },
37 |         },
38 |         orderBy: {
39 |           name: 'asc',
40 |         },
41 |       });
42 |       
43 |       // 응답 형식 변환
44 |       const formattedTags = tags.map(tag => ({
45 |         id: tag.id,
46 |         name: tag.name,
47 |         count: tag._count.cardTags,
48 |         createdAt: tag.createdAt,
49 |       }));
50 |       
51 |       return NextResponse.json(formattedTags);
52 |     } else {
53 |       // 기본 태그 목록만 반환
54 |       const tags = await prisma.tag.findMany({
55 |         where: searchQuery ? {
56 |           name: {
57 |             contains: searchQuery,
58 |           },
59 |         } : undefined,
60 |         orderBy: {
61 |           name: 'asc',
62 |         },
63 |       });
64 |       
65 |       return NextResponse.json(tags);
66 |     }
67 |   } catch (error) {
68 |     console.error('태그 조회 오류:', error);
69 |     return NextResponse.json(
70 |       { error: '태그 목록을 불러오는데 실패했습니다' },
71 |       { status: 500 }
72 |     );
73 |   }
74 | }
75 | 
76 | /**
77 |  * POST: 새 태그를 생성하는 API
78 |  * @param request - 요청 객체
79 |  * @returns 생성된 태그 정보
80 |  */
81 | export async function POST(request: NextRequest) {
82 |   try {
83 |     // 사용자 인증 확인
84 |     const session = await auth();
85 |     if (!session || !session.user) {
86 |       return NextResponse.json(
87 |         { error: '인증이 필요합니다' },
88 |         { status: 401 }
89 |       );
90 |     }
91 |     
92 |     const { name } = await request.json();
93 |     
94 |     if (!name || typeof name !== 'string' || name.trim() === '') {
95 |       return NextResponse.json(
96 |         { error: '유효한 태그 이름이 필요합니다' },
[TRUNCATED]
```

src/app/api/logs/route.ts
```
1 | /**
2 |  * 파일명: route.ts
3 |  * 목적: 클라이언트 로그를 서버에 저장하는 API 엔드포인트
4 |  * 역할: 로그 데이터를 받아 서버 로그에 기록하고 필요시 데이터베이스에 저장
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2024-05-22 : import 순서 수정, any 타입 구체화
7 |  * 수정일: 2025-04-05 : Vercel 환경에서 파일 시스템 접근 제한 문제 해결
8 |  */
9 | 
10 | import fs from 'fs';
11 | import path from 'path';
12 | 
13 | import { NextRequest, NextResponse } from 'next/server';
14 | 
15 | import { createClient } from '@supabase/supabase-js';
16 | // import { createBrowserSupabaseClient } from '@/lib/supabase-browser'; // 클라이언트용 함수 제거
17 | 
18 | // 로그 파일 경로 설정
19 | const LOG_DIR = process.env.LOG_DIR || 'logs';
20 | const LOG_FILE = path.join(process.cwd(), LOG_DIR, 'client-logs.json');
21 | // Vercel 환경 확인
22 | const IS_VERCEL = process.env.VERCEL === '1';
23 | 
24 | // 서버 전용 Supabase 클라이언트 생성 함수
25 | const createServerSupabaseClient = () => {
26 |   const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
27 |   const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
28 |   
29 |   if (!supabaseUrl || !supabaseServiceKey) {
30 |     console.error('Supabase 환경 변수가 설정되지 않았습니다');
31 |     return null;
32 |   }
33 |   
34 |   return createClient(supabaseUrl, supabaseServiceKey);
35 | };
36 | 
37 | /**
38 |  * ensureLogDir: 로그 디렉토리가 존재하는지 확인하고, 없으면 생성
39 |  */
40 | const ensureLogDir = () => {
41 |   // Vercel 환경에서는 실행하지 않음
42 |   if (IS_VERCEL) return;
43 |   
44 |   const logDirPath = path.join(process.cwd(), LOG_DIR);
45 |   if (!fs.existsSync(logDirPath)) {
46 |     fs.mkdirSync(logDirPath, { recursive: true });
47 |     console.log(`로그 디렉토리 생성: ${logDirPath}`);
48 |   }
49 | };
50 | 
51 | /**
52 |  * saveLogToFile: 로그 데이터를 파일에 저장
53 |  * @param logData 저장할 로그 데이터
54 |  */
55 | const saveLogToFile = (logData: {
56 |   module: string;
57 |   level: string;
58 |   message: string;
59 |   data?: Record<string, unknown>;
60 |   timestamp?: string;
61 | }) => {
62 |   try {
63 |     // 서버 콘솔에 로그 출력
64 |     console.log(`[CLIENT-LOG][${logData.module}][${logData.level}] ${logData.message}`, logData.data || '');
65 |     
66 |     // Vercel 환경에서는 파일 저장 건너뜀
67 |     if (IS_VERCEL) {
68 |       return true;
69 |     }
70 |     
71 |     ensureLogDir();
72 |     
73 |     // 기존 로그 파일 읽기
74 |     let logs = [];
75 |     if (fs.existsSync(LOG_FILE)) {
76 |       const fileContent = fs.readFileSync(LOG_FILE, 'utf-8');
[TRUNCATED]
```

src/app/auth/error/page.test.tsx
```
1 | /**
2 |  * 파일명: src/app/auth/error/page.test.tsx
3 |  * 목적: 인증 오류 페이지의 기능 테스트
4 |  * 역할: 인증 과정에서 발생하는 오류 메시지가 올바르게 표시되는지 검증
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-03-30
7 |  * 수정일: 2024-09-28 : 컴포넌트 구조 변경에 따른 테스트 업데이트
8 |  */
9 | 
10 | import { render, screen } from '@testing-library/react';
11 | import { describe, expect, it, vi, beforeEach } from 'vitest';
12 | 
13 | import ErrorPage from './page';
14 | import AuthErrorDisplay from '@/components/auth/AuthErrorDisplay';
15 | 
16 | // 모킹 설정
17 | const mockPush = vi.fn();
18 | const mockGet = vi.fn();
19 | 
20 | vi.mock('next/navigation', () => ({
21 |   useSearchParams: () => ({
22 |     get: mockGet
23 |   }),
24 |   useRouter: () => ({
25 |     push: mockPush
26 |   })
27 | }));
28 | 
29 | // Suspense 모킹
30 | vi.mock('react', async () => {
31 |   const actual = await vi.importActual('react');
32 |   return {
33 |     ...actual,
34 |     Suspense: ({ children }: { children: React.ReactNode }) => <>{children}</>
35 |   };
36 | });
37 | 
38 | // AuthErrorDisplay 컴포넌트 모킹
39 | vi.mock('@/components/auth/AuthErrorDisplay', () => ({
40 |   default: vi.fn(() => {
41 |     const mockError = mockGet('error') || 'default';
42 |     const mockDescription = mockGet('error_description') || '';
43 | 
44 |     return (
45 |       <>
46 |         <p data-testid="error-message">
47 |           {mockError === 'default' && '인증 과정에서 오류가 발생했습니다.'}
48 |           {mockError === 'invalid_callback' && '유효하지 않은 인증 콜백입니다.'}
49 |           {mockError === 'verification_failed' && '이메일 인증에 실패했습니다.'}
50 |           {mockError === 'unknown_error' && '인증 과정에서 오류가 발생했습니다.'}
51 |           {mockError === 'test_error' && '인증 과정에서 오류가 발생했습니다.'}
52 |         </p>
53 | 
54 |         {mockDescription && (
55 |           <p data-testid="error-description">{mockDescription}</p>
56 |         )}
57 | 
58 |         <div>
59 |           <a href="/login">로그인 페이지로 돌아가기</a>
60 |           <a href="/">홈으로 돌아가기</a>
61 |         </div>
62 |       </>
63 |     );
64 |   })
65 | }));
66 | 
67 | describe('ErrorPage', () => {
68 |   beforeEach(() => {
69 |     vi.clearAllMocks();
70 |     mockGet.mockImplementation((param: string) => {
71 |       if (param === 'error') return 'default';
72 |       if (param === 'error_description') return '';
73 |       return null;
74 |     });
75 |     vi.spyOn(console, 'error').mockImplementation(() => { });
76 |   });
77 | 
78 |   it('기본 오류 메시지를 올바르게 표시해야 합니다', () => {
79 |     render(<ErrorPage />);
80 | 
81 |     expect(screen.getByRole('heading', { name: '인증 오류' })).toBeInTheDocument();
82 |     expect(screen.getByTestId('error-message')).toHaveTextContent('인증 과정에서 오류가 발생했습니다.');
83 |   });
84 | 
[TRUNCATED]
```

src/app/auth/error/page.tsx
```
1 | /**
2 |  * 파일명: src/app/auth/error/page.tsx
3 |  * 목적: 인증 과정에서 발생한 오류 표시
4 |  * 역할: 사용자에게 인증 오류 메시지를 보여주고 후속 조치 안내
5 |  * 작성일: 2025-03-26
6 |  * 수정일: 2025-03-27
7 |  * 수정일: 2024-09-28 : 동적 렌더링 강제를 통한 useSearchParams 오류 해결
8 |  * 수정일: 2024-09-28 : Suspense 경계로 useSearchParams를 감싸 빌드 오류 해결
9 |  */
10 | 
11 | import { Suspense } from 'react'
12 | import AuthErrorDisplay from '@/components/auth/AuthErrorDisplay'
13 | 
14 | // LoadingFallback 컴포넌트 정의
15 | function LoadingFallback() {
16 |   return <p className="text-gray-500">오류 정보 로딩 중...</p>
17 | }
18 | 
19 | export default function AuthErrorPage() {
20 |   return (
21 |     <div className="flex flex-col items-center justify-center min-h-screen bg-gray-50 p-4">
22 |       <div className="w-full max-w-md p-8 space-y-4 bg-white rounded-lg shadow-md">
23 |         <div className="text-center">
24 |           <h1 className="text-2xl font-bold text-red-600 mb-2">인증 오류</h1>
25 |           <Suspense fallback={<LoadingFallback />}>
26 |             <AuthErrorDisplay />
27 |           </Suspense>
28 |         </div>
29 |       </div>
30 |     </div>
31 |   )
32 | } 
```

src/app/auth/callback/route.ts
```
1 | /**
2 |  * 파일명: src/app/auth/callback/route.ts
3 |  * 목적: OAuth 콜백 처리
4 |  * 역할: OAuth 인증 완료 후 사용자를 적절한 페이지로 리다이렉트
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-05 : 로그 메시지 강화 및 추가
7 |  */
8 | 
9 | import { NextRequest, NextResponse } from 'next/server'
10 | 
11 | import { createClient } from '@/lib/supabase/server'
12 | 
13 | export async function GET(request: NextRequest) {
14 |   try {
15 |     // 핸들러 시작 로그 추가
16 |     console.log('[AuthCallback] Route handler started.');
17 |     
18 |     // 요청 URL 로깅
19 |     console.log('[AuthCallback] Received request URL:', request.url);
20 |     
21 |     // URL에서 인증 코드 추출
22 |     const requestUrl = new URL(request.url)
23 |     const code = requestUrl.searchParams.get('code')
24 |     
25 |     // 인증 코드 추출 로그 강화
26 |     if (code) {
27 |       console.log('[AuthCallback] Authorization code found:', code.substring(0, 10) + '...'); // 코드 일부만 로깅
28 |     } else {
29 |       console.error('[AuthCallback] Authorization code NOT found in URL.'); // 에러 로그로 변경
30 |       return NextResponse.redirect(new URL('/login?error=인증 코드를 찾을 수 없습니다', request.url))
31 |     }
32 |     
33 |     // 리다이렉트 대상 경로 (기본값: 홈)
34 |     const next = '/'
35 |     
36 |     // 서버 클라이언트 생성
37 |     const supabase = await createClient()
38 |     
39 |     // 세션 교환 시도 로그
40 |     console.log('[AuthCallback] Attempting to exchange code for session with code:', code.substring(0, 10) + '...');
41 |     
42 |     // PKCE 인증 흐름 완료 (코드 → 토큰 교환)
43 |     const { error } = await supabase.auth.exchangeCodeForSession(code)
44 |     
45 |     // 세션 교환 결과 로그 강화
46 |     if (error) {
47 |       console.error('[AuthCallback] Code exchange failed. Error:', error); // 에러 객체 전체 로깅
48 |       // 리디렉션 URL 생성 전 로그 추가
49 |       const errorRedirectUrl = new URL(`/login?error=코드 교환 실패&error_description=${encodeURIComponent(error.message)}`, request.url);
50 |       console.log('[AuthCallback] Redirecting to (error):', errorRedirectUrl.toString());
51 |       return NextResponse.redirect(errorRedirectUrl);
52 |     } else {
53 |       console.log('[AuthCallback] Code exchange successful.'); // 성공 로그 추가
54 |     }
55 |     
56 |     // 성공 리디렉션 로그
57 |     const successRedirectUrl = new URL(next, request.url);
58 |     console.log('[AuthCallback] Redirecting to (success):', successRedirectUrl.toString());
59 |     return NextResponse.redirect(successRedirectUrl);
60 |   } catch (error: unknown) {
61 |     // 전체 예외 처리 로그 강화
62 |     console.error('[AuthCallback] Unhandled exception during callback processing:', error); // 에러 객체 로깅
63 |     const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류 발생';
[TRUNCATED]
```

src/app/auth/login/page.tsx
```
1 | /**
2 |  * 파일명: src/app/auth/login/page.tsx
3 |  * 목적: 사용자 로그인 페이지
4 |  * 역할: 소셜 로그인 및 이메일 로그인 기능 제공
5 |  * 작성일: 2025-03-30
6 |  * 수정일: 2023-11-02 : NextAuth 의존성 제거 및 Supabase 인증으로 완전히 전환
7 |  */
8 | 
9 | 'use client';
10 | 
11 | import { useState } from 'react';
12 | 
13 | import { Button } from '@/components/ui/button';
14 | import { Card, CardContent, CardDescription, CardHeader } from '@/components/ui/card';
15 | import { signInWithGoogle } from '@/lib/auth';
16 | 
17 | export default function LoginPage() {
18 |   const [isLoading, setIsLoading] = useState(false);
19 | 
20 |   const handleGoogleLogin = async () => {
21 |     try {
22 |       setIsLoading(true);
23 |       const result = await signInWithGoogle();
24 | 
25 |       if (result.success && result.url) {
26 |         // Supabase OAuth 흐름에 따라 리디렉션
27 |         window.location.href = result.url;
28 |       } else {
29 |         console.error('로그인 URL 생성 실패:', result.error);
30 |         alert('로그인 처리 중 오류가 발생했습니다.');
31 |       }
32 |     } catch (error) {
33 |       console.error('로그인 오류:', error);
34 |     } finally {
35 |       setIsLoading(false);
36 |     }
37 |   };
38 | 
39 |   return (
40 |     <div className="container mx-auto flex items-center justify-center min-h-screen py-8">
41 |       <Card className="w-full max-w-md">
42 |         <CardHeader className="@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6" data-slot="card-header">
43 |           <h1 className="leading-none font-semibold" data-slot="card-title">
44 |             로그인
45 |           </h1>
46 |           <CardDescription>
47 |             소셜 계정으로 간편하게 로그인하세요.
48 |           </CardDescription>
49 |         </CardHeader>
50 |         <CardContent>
51 |           <div className="space-y-4">
52 |             <Button
53 |               variant="outline"
54 |               className="w-full"
55 |               onClick={handleGoogleLogin}
56 |               disabled={isLoading}
57 |             >
58 |               {isLoading ? '로그인 중...' : 'Google로 로그인'}
59 |             </Button>
60 |           </div>
61 |         </CardContent>
62 |       </Card>
63 |     </div>
64 |   );
65 | } 
```

src/app/cards/[id]/DeleteButton.test.tsx
```
1 | /**
2 |  * 파일명: src/app/cards/[id]/DeleteButton.test.tsx
3 |  * 목적: 카드 삭제 버튼 컴포넌트 테스트
4 |  * 역할: 카드 삭제 기능을 테스트
5 |  * 작성일: 2025-03-29
6 |  * 수정일: 2024-05-07 : Triple-slash 참조 제거 및 import 문으로 변경
7 |  * 수정일: 2025-04-09
8 |  * 수정일: 2025-04-01
9 |  * 수정일: 2025-04-10 : API 호출 테스트를 위한 구현 방식 변경 및 안정적인 테스트 구현
10 |  * 수정일: 2025-04-11 : 컴포넌트 UI 상호작용 테스트 추가로 코드 커버리지 개선
11 |  * 수정일: 2025-04-12 : 비동기 테스트 안정성 개선 및 타임아웃 설정 추가
12 |  * 수정일: 2025-04-12 : 다이얼로그 상호작용 문제 해결 및 테스트 방식 리팩토링
13 |  * 수정일: 2025-04-12 : act 경고 해결 및 테스트 안정성 개선을 위해 테스트 전략 변경
14 |  * 수정일: 2025-05-16 : triple-slash reference를 import 문으로 변경
15 |  * 수정일: 2025-05-19 : 린터 오류 수정 (사용하지 않는 import 제거, import 순서 변경)
16 |  */
17 | import React from 'react';
18 | 
19 | import { render, screen } from '@testing-library/react';
20 | import { toast } from 'sonner';
21 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
22 | import '@testing-library/jest-dom/vitest';
23 | 
24 | import DeleteButton, { callIfExists } from './DeleteButton';
25 | 
26 | // 모킹 설정
27 | const mockPush = vi.fn();
28 | vi.mock('next/navigation', () => ({
29 |   useRouter: () => ({
30 |     push: mockPush
31 |   })
32 | }));
33 | 
34 | vi.mock('sonner', () => ({
35 |   toast: {
36 |     success: vi.fn(),
37 |     error: vi.fn()
38 |   }
39 | }));
40 | 
41 | // Dialog 모킹으로 테스트 안정성 확보
42 | vi.mock('@/components/ui/dialog', () => {
43 |   return {
44 |     Dialog: ({ children }: { children: React.ReactNode }) => <div data-testid="dialog">{children}</div>,
45 |     DialogContent: ({ children }: { children: React.ReactNode }) => <div data-testid="dialog-content">{children}</div>,
46 |     DialogHeader: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
47 |     DialogTitle: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
48 |     DialogDescription: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
49 |     DialogFooter: ({ children }: { children: React.ReactNode }) => <div data-testid="dialog-footer">{children}</div>,
50 |     DialogTrigger: ({ children }: { children: React.ReactNode }) => <div data-testid="dialog-trigger">{children}</div>,
51 |     DialogClose: ({ children }: { children: React.ReactNode }) => <div data-testid="dialog-close">{children}</div>,
52 |   };
53 | });
54 | 
55 | // 테스트 유틸리티 함수
56 | // 각각의 모킹 fetch 응답 패턴
57 | const mockFetchSuccess = () => {
58 |   global.fetch = vi.fn().mockImplementation(() =>
[TRUNCATED]
```

src/app/cards/[id]/DeleteButton.tsx
```
1 | "use client";
2 | 
3 | import { useState } from "react";
4 | 
5 | import { useRouter } from "next/navigation";
6 | 
7 | import { Trash2 } from "lucide-react";
8 | import { toast } from "sonner";
9 | 
10 | import { Button } from "@/components/ui/button";
11 | import {
12 |   Dialog,
13 |   DialogContent,
14 |   DialogHeader,
15 |   DialogTitle,
16 |   DialogDescription,
17 |   DialogFooter,
18 |   DialogTrigger,
19 |   DialogClose,
20 | } from "@/components/ui/dialog";
21 | 
22 | interface DeleteButtonProps {
23 |   cardId: string;
24 |   // 테스트를 위한 프로퍼티 추가 (선택적)
25 |   onSuccessfulDelete?: () => void;
26 | }
27 | 
28 | // 테스트를 위해 함수를 컴포넌트 외부로 분리
29 | export function callIfExists(callback?: () => void): void {
30 |   if (callback) {
31 |     callback();
32 |   }
33 | }
34 | 
35 | export default function DeleteButton({
36 |   cardId,
37 |   onSuccessfulDelete
38 | }: DeleteButtonProps) {
39 |   const [isDeleting, setIsDeleting] = useState(false);
40 |   const [open, setOpen] = useState(false);
41 |   const router = useRouter();
42 | 
43 |   const handleDelete = async () => {
44 |     setIsDeleting(true);
45 | 
46 |     try {
47 |       // API 호출
48 |       const response = await fetch(`/api/cards/${cardId}`, {
49 |         method: "DELETE",
50 |       });
51 | 
52 |       // 실패 응답 처리
53 |       if (!response.ok) {
54 |         const errorData = await response.json();
55 |         throw new Error(errorData.error || "카드 삭제에 실패했습니다.");
56 |       }
57 | 
58 |       // 성공 시에만 다음 코드 실행
59 | 
60 |       // 성공 시 다이얼로그 닫기
61 |       setOpen(false);
62 | 
63 |       // 성공적인 삭제 후 토스트 메시지 표시
64 |       toast.success("카드가 성공적으로 삭제되었습니다.");
65 | 
66 |       // 성공 시에만 리디렉션 수행
67 |       router.push("/cards");
68 | 
69 |       // 성공 시에만 콜백 호출
70 |       if (onSuccessfulDelete) {
71 |         onSuccessfulDelete();
72 |       }
73 | 
74 |       // 성공 시에만 여기까지 실행됨
75 | 
76 |     } catch (error) {
77 |       // 모든 종류의 오류 처리 (네트워크 오류, 응답 오류 등)
78 |       console.error("Error deleting card:", error);
79 | 
80 |       // 오류 메시지 표시
81 |       toast.error(error instanceof Error ? error.message : "카드 삭제에 실패했습니다.");
82 | 
83 |       // 오류 발생 시 다이얼로그만 닫음 (리디렉션 없음)
84 |       setOpen(false);
85 | 
86 |       // 오류 시 리디렉션이 발생하지 않음
87 |     } finally {
88 |       setIsDeleting(false);
89 |     }
90 |     // 함수 종료
91 |   };
92 | 
93 |   return (
94 |     <Dialog open={open} onOpenChange={setOpen}>
95 |       <DialogTrigger asChild>
96 |         <Button variant="destructive" size="sm">
97 |           <Trash2 className="mr-2 h-4 w-4" />
98 |           카드 삭제
99 |         </Button>
[TRUNCATED]
```

src/app/cards/[id]/page.test.tsx
```
1 | /**
2 |  * 파일명: src/app/cards/[id]/page.test.tsx
3 |  * 목적: 카드 상세 페이지 테스트
4 |  * 역할: 카드 상세 페이지 렌더링 및 기능 검증
5 |  * 작성일: 2025-02-15
6 |  * 수정일: 2024-05-16 : Triple-slash 참조 제거 및 import 문으로 변경
7 |  */
8 | 
9 | import React from 'react';
10 | 
11 | import { render, screen, cleanup } from '@testing-library/react';
12 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
13 | import '@testing-library/jest-dom/vitest';
14 | 
15 | import CardPage, { generateMetadata } from './page';
16 | 
17 | // next/navigation 모킹
18 | vi.mock('next/navigation', () => ({
19 |   notFound: vi.fn(),
20 |   useRouter: vi.fn(() => ({
21 |     push: vi.fn()
22 |   }))
23 | }));
24 | 
25 | // Prisma 모킹 - 함수를 inline으로 정의
26 | vi.mock('@/lib/prisma', () => {
27 |   return {
28 |     default: {
29 |       card: {
30 |         findUnique: vi.fn()
31 |       }
32 |     }
33 |   }
34 | });
35 | 
36 | // formatDate 모킹
37 | vi.mock('@/lib/utils', () => ({
38 |   formatDate: vi.fn(() => '2023년 1월 1일'),
39 |   cn: vi.fn((...args: any[]) => args.join(' '))
40 | }));
41 | 
42 | // EditCardContent 컴포넌트 모킹
43 | vi.mock('@/components/cards/EditCardContent', () => {
44 |   return {
45 |     default: vi.fn(({ initialContent }: { initialContent: string }) => (
46 |       <div data-testid="edit-card-content">{initialContent}</div>
47 |     ))
48 |   };
49 | });
50 | 
51 | describe('CardPage', () => {
52 |   const params = { id: 'card123' };
53 | 
54 |   // 가짜 카드 데이터
55 |   const mockCard = {
56 |     id: 'card123',
57 |     title: '테스트 카드',
58 |     content: '테스트 내용입니다.',
59 |     createdAt: new Date(),
60 |     updatedAt: new Date(),
61 |     user: {
62 |       id: 'user123',
63 |       name: '테스트 사용자',
64 |       email: 'test@example.com'
65 |     },
66 |     cardTags: [
67 |       {
68 |         id: 'ct1',
69 |         cardId: 'card123',
70 |         tagId: 'tag1',
71 |         tag: {
72 |           id: 'tag1',
73 |           name: '태그1'
74 |         }
75 |       },
76 |       {
77 |         id: 'ct2',
78 |         cardId: 'card123',
79 |         tagId: 'tag2',
80 |         tag: {
81 |           id: 'tag2',
82 |           name: '태그2'
83 |         }
84 |       }
85 |     ]
86 |   };
87 | 
88 |   // 테스트에서 사용할 모듈 참조 변수
89 |   let prisma: any;
90 | 
91 |   beforeEach(async () => {
92 |     vi.clearAllMocks();
93 |     // 테스트에서 사용할 모킹된 모듈을 동적으로 가져옴
94 |     const prismaModule = await import('@/lib/prisma');
95 |     prisma = prismaModule.default;
96 |   });
97 | 
98 |   afterEach(() => {
99 |     cleanup();
100 |   });
101 | 
[TRUNCATED]
```

src/app/cards/[id]/page.tsx
```
1 | /**
2 |  * 파일명: src/app/cards/[id]/page.tsx
3 |  * 목적: 특정 카드의 상세 정보를 보여주는 페이지
4 |  * 역할: 카드 ID를 기반으로 상세 정보 조회 및 표시
5 |  * 작성일: 2024-05-28
6 |  */
7 | 
8 | import Link from "next/link";
9 | import { notFound } from "next/navigation";
10 | 
11 | import { ArrowLeft } from "lucide-react";
12 | import { Metadata } from "next";
13 | 
14 | import EditCardContent from "@/components/cards/EditCardContent";
15 | import { Button } from "@/components/ui/button";
16 | import prisma from "@/lib/prisma";
17 | 
18 | import DeleteButton from "./DeleteButton";
19 | 
20 | interface PageProps {
21 |   params: {
22 |     id: string;
23 |   };
24 | }
25 | 
26 | export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
27 |   const cardId = String(params.id);
28 |   const card = await getCard(cardId);
29 | 
30 |   if (!card) {
31 |     return {
32 |       title: "카드를 찾을 수 없음",
33 |     };
34 |   }
35 | 
36 |   return {
37 |     title: `${card.title} | Backyard`,
38 |   };
39 | }
40 | 
41 | async function getCard(id: string) {
42 |   try {
43 |     // @ts-expect-error - Prisma 스키마와 TypeScript 타입 간의 불일치. CardTag 관계 타입 문제 해결 필요
44 |     const card = await prisma.card.findUnique({
45 |       where: { id },
46 |       include: {
47 |         user: true,
48 |         // @ts-expect-error - Prisma 스키마에서 CardTag 모델의 관계 타입과 TypeScript 타입 정의 불일치
49 |         cardTags: {
50 |           include: {
51 |             tag: true,
52 |           },
53 |         },
54 |       },
55 |     });
56 |     return card;
57 |   } catch (error) {
58 |     console.error("카드 조회 오류:", error);
59 |     return null;
60 |   }
61 | }
62 | 
63 | export default async function CardPage({ params }: PageProps) {
64 |   const cardId = String(params.id);
65 |   const card = await getCard(cardId);
66 | 
67 |   if (!card) {
68 |     notFound();
69 |     // 테스트를 위해 빈 컴포넌트 반환 (notFound 이후에도 코드가 실행될 수 있음)
70 |     return <div data-testid="not-found"></div>;
71 |   }
72 | 
73 |   return (
74 |     <div className="container max-w-4xl py-6 space-y-8">
75 |       <div className="flex justify-between items-center">
76 |         <Link href="/cards">
77 |           <Button variant="ghost" size="sm">
78 |             <ArrowLeft className="h-4 w-4 mr-2" />
79 |             뒤로 가기
80 |           </Button>
81 |         </Link>
82 |         <DeleteButton cardId={cardId} />
83 |       </div>
84 | 
85 |       <div className="space-y-4">
86 |         <h1 className="text-3xl font-bold">{card.title}</h1>
[TRUNCATED]
```

src/app/auth/test/page.tsx
```
1 | /**
2 |  * 파일명: auth/test/page.tsx
3 |  * 목적: 인증 기능 테스트 페이지
4 |  * 역할: 다양한 인증 상태 및 스토리지 검사 기능 제공
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-14 : NextAuth signIn 제거 및 Supabase 인증 방식으로 완전히 전환
7 |  */
8 | 
9 | 'use client';
10 | 
11 | import { useState, useEffect } from 'react';
12 | 
13 | import { Button } from '@/components/ui/button';
14 | import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
15 | import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
16 | import { signOut, getCurrentUser, ExtendedUser, signInWithGoogle } from '@/lib/auth';
17 | 
18 | export default function AuthTestPage() {
19 |   const [user, setUser] = useState<ExtendedUser | null>(null);
20 |   const [loading, setLoading] = useState(true);
21 | 
22 |   useEffect(() => {
23 |     const fetchUser = async () => {
24 |       try {
25 |         const currentUser = await getCurrentUser();
26 |         setUser(currentUser);
27 |       } catch (e) {
28 |         console.error('사용자 정보 로드 오류:', e);
29 |       } finally {
30 |         setLoading(false);
31 |       }
32 |     };
33 | 
34 |     fetchUser();
35 |   }, []);
36 | 
37 |   const handleGoogleLogin = async () => {
38 |     try {
39 |       const result = await signInWithGoogle();
40 |       if (result.success && result.url) {
41 |         window.location.href = result.url;
42 |       } else {
43 |         console.error('로그인 URL 생성 실패:', result.error);
44 |         alert('로그인 처리 중 오류가 발생했습니다.');
45 |       }
46 |     } catch (e) {
47 |       console.error('로그인 오류:', e);
48 |     }
49 |   };
50 | 
51 |   const handleLogout = async () => {
52 |     try {
53 |       await signOut();
54 |       setUser(null);
55 |       alert('로그아웃 성공');
56 |     } catch (e) {
57 |       console.error('로그아웃 오류:', e);
58 |     }
59 |   };
60 | 
61 |   const runAllTests = async () => {
62 |     setLoading(true);
63 |     try {
64 |       await fetch('/api/test/run-all', {
65 |         method: 'POST'
66 |       });
67 |     } finally {
68 |       setLoading(false);
69 |     }
70 |   };
71 | 
72 |   if (loading) {
73 |     return (
74 |       <div className="container mx-auto py-8">
75 |         <h1 className="text-3xl font-bold mb-8">인증 테스트 페이지</h1>
76 |         <p>로딩 중...</p>
77 |       </div>
78 |     );
79 |   }
80 | 
81 |   if (!user) {
82 |     return (
83 |       <div className="container mx-auto py-8">
84 |         <h1 className="text-3xl font-bold mb-8">인증 테스트 페이지</h1>
85 |         <Button onClick={handleGoogleLogin}>Google 로그인 테스트</Button>
86 |       </div>
87 |     );
88 |   }
89 | 
90 |   return (
[TRUNCATED]
```

src/components/ideamap/components/IdeaMap.test.tsx
```
1 | /**
2 |  * 파일명: IdeaMap.test.tsx
3 |  * 목적: IdeaMap 컴포넌트 테스트
4 |  * 역할: IdeaMap 컴포넌트의 기능을 검증하는 테스트 코드 제공
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-01
7 |  * 수정일: 2024-05-17 : 사용되지 않는 import와 변수 제거
8 |  */
9 | 
10 | import React from 'react';
11 | 
12 | import { render, screen, fireEvent } from '@testing-library/react';
13 | import { toast } from 'sonner';
14 | import { vi, describe, it, expect, beforeEach } from 'vitest';
15 | 
16 | import '@testing-library/jest-dom';
17 | import { mockReactFlow } from '@/tests/utils/react-flow-mock';
18 | 
19 | import IdeaMap from './IdeaMap';
20 | 
21 | // React Flow 모킹
22 | mockReactFlow();
23 | 
24 | // window 객체 모킹 - addEventListener 문제 해결
25 | Object.defineProperty(global, 'window', {
26 |   value: {
27 |     ...global.window,
28 |     addEventListener: vi.fn(),
29 |     removeEventListener: vi.fn(),
30 |   },
31 |   writable: true,
32 | });
33 | 
34 | // document.body 설정 - waitFor 문제 해결
35 | document.body.innerHTML = '<div id="root"></div>';
36 | 
37 | // 모듈 모킹
38 | vi.mock('@xyflow/react', async () => {
39 |   const actual = await vi.importActual('@xyflow/react');
40 |   return {
41 |     ...actual,
42 |     useReactFlow: vi.fn(() => ({
43 |       screenToFlowPosition: vi.fn(({ x, y }) => ({ x, y })),
44 |       fitView: vi.fn(),
45 |       getNodes: vi.fn(() => []),
46 |       getEdges: vi.fn(() => []),
47 |       setNodes: vi.fn(),
48 |       setEdges: vi.fn(),
49 |     })),
50 |     useUpdateNodeInternals: vi.fn(() => vi.fn()),
51 |     Background: () => <div data-testid="react-flow-background" />,
52 |     Controls: () => <div data-testid="react-flow-controls" />,
53 |     Panel: ({ children, position }: any) => <div data-testid={`panel-${position}`}>{children}</div>,
54 |     ReactFlow: ({ children, nodes, edges }: any) => (
55 |       <div data-testid="react-flow-container">
56 |         <div data-testid="react-flow-nodes">{JSON.stringify(nodes)}</div>
57 |         <div data-testid="react-flow-edges">{JSON.stringify(edges)}</div>
58 |         {children}
59 |       </div>
60 |     ),
61 |   };
62 | });
63 | 
64 | // IdeaMap 컴포넌트 자체 모킹으로 변경
65 | vi.mock('./IdeaMap', () => ({
66 |   default: ({ showControls }: { showControls?: boolean }) => {
67 |     // React Hook "useState" 규칙 위반 문제 해결 - 컴포넌트 이름 변경
68 |     const MockIdeaMap = () => {
69 |       const [isCreateModalOpen, setIsCreateModalOpen] = React.useState(false);
70 | 
71 |       const handleCreateCard = () => {
72 |         setIsCreateModalOpen(true);
73 |       };
74 | 
75 |       const handleCloseModal = () => {
76 |         setIsCreateModalOpen(false);
77 |       };
78 | 
[TRUNCATED]
```

src/components/ideamap/components/IdeaMap.tsx
```
1 | /**
2 |  * 파일명: src/components/ideamap/components/IdeaMap.tsx
3 |  * 목적: 보드 메인 컨테이너 컴포넌트
4 |  * 역할: 보드 기능의 메인 UI 컴포넌트로, React Flow와 관련 훅을 조합하여 완전한 보드 환경 제공
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-17 : 렌더링 최적화 (불필요한 리렌더링 방지)
7 |  */
8 | 
9 | 'use client';
10 | 
11 | import React, { useState, useEffect, useRef, useCallback, memo } from 'react';
12 | import { toast } from 'sonner';
13 | 
14 | import { useReactFlow } from '@xyflow/react';
15 | 
16 | import CreateCardModal from '@/components/cards/CreateCardModal';
17 | import { useAuth } from '@/contexts/AuthContext';
18 | import { useAddNodeOnEdgeDrop } from '@/hooks/useAddNodeOnEdgeDrop';
19 | import { useAppStore } from '@/store/useAppStore';
20 | import { Card } from '@/store/useAppStore';
21 | import { useIdeaMapStore } from '@/store/useIdeaMapStore';
22 | 
23 | // 보드 관련 컴포넌트 임포트
24 | import IdeaMapCanvas from './IdeaMapCanvas';
25 | // 보드 관련 훅 임포트
26 | import { useEdges } from '../hooks/useEdges';
27 | import { useIdeaMapData } from '../hooks/useIdeaMapData';
28 | import { useIdeaMapHandlers } from '../hooks/useIdeaMapHandlers';
29 | import { useNodeClickHandlers } from '../hooks/useNodes';
30 | // 타입 임포트
31 | import { NodeInspector } from '../nodes/NodeInspector';
32 | import {
33 |   IdeaMapComponentProps,
34 |   XYPosition,
35 |   SafeRef,
36 |   IdeaMapSettings,
37 |   NodeChange
38 | } from '../types/ideamap-types';
39 | import { IDEAMAP_EDGES_STORAGE_KEY } from '@/lib/ideamap-constants';
40 | import { Node } from '@xyflow/react';
41 | 
42 | /**
43 |  * IdeaMap: 아이디어맵 메인 컨테이너 컴포넌트
44 |  * @param onSelectCard 카드 선택 시 호출될 콜백 함수
45 |  * @param className 추가 CSS 클래스
46 |  * @param showControls 컨트롤 표시 여부
47 |  */
48 | function IdeaMap({
49 |   onSelectCard,
50 |   className = "",
51 |   showControls = true
52 | }: IdeaMapComponentProps) {
53 |   console.log('[IdeaMap] 컴포넌트 렌더링 시작', { showControls });
54 | 
55 |   // 상태 관리
56 |   const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
57 | 
58 |   // 엣지 드롭 관련 상태
59 |   const [isEdgeDropModalOpen, setIsEdgeDropModalOpen] = useState(false);
60 |   const [edgeDropPosition, setEdgeDropPosition] = useState<XYPosition | null>(null);
61 |   const [edgeDropNodeId, setEdgeDropNodeId] = useState<string | null>(null);
62 |   const [edgeDropHandleType, setEdgeDropHandleType] = useState<'source' | 'target' | null>(null);
63 | 
64 |   // 뷰포트 변경 디바운스를 위한 타이머
65 |   const viewportChangeTimer = useRef<NodeJS.Timeout | null>(null);
66 | 
67 |   // 인증 상태 가져오기
68 |   const { user, isLoading: isAuthLoading } = useAuth();
69 |   console.log('[IdeaMap] 인증 상태:', { userId: user?.id, isAuthLoading });
70 | 
71 |   // 레퍼런스 및 기타 훅
72 |   const reactFlowWrapper = useRef<HTMLDivElement>(null) as SafeRef<HTMLDivElement>;
73 |   const reactFlowInstance = useReactFlow();
74 |   console.log('[IdeaMap] ReactFlow 인스턴스 확인:', !!reactFlowInstance);
75 | 
76 |   // useAppStore에서 필요한 상태만 선택적으로 가져오기
[TRUNCATED]
```

src/components/ideamap/components/IdeaMapCanvas.test.tsx
```
1 | /**
2 |  * 파일명: IdeaMapCanvas.test.tsx
3 |  * 목적: IdeaMapCanvas 컴포넌트 테스트
4 |  * 역할: IdeaMapCanvas 컴포넌트의 렌더링과 기능을 테스트
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-01
7 |  * 수정일: 2023-10-27 : import 순서 및 미사용 변수 제거
8 |  * 수정일: 2023-10-27 : 불필요한 props 제거 및 테스트 환경 수정
9 |  */
10 | 
11 | import React from 'react';
12 | import { ReactNode } from 'react';
13 | 
14 | import { render, screen, fireEvent } from '@testing-library/react';
15 | 
16 | import '@testing-library/jest-dom';
17 | 
18 | import { MarkerType, ConnectionLineType, Node, Edge } from '@xyflow/react';
19 | import { vi, describe, it, expect, beforeEach } from 'vitest';
20 | 
21 | import { createTestNode, createTestEdge } from '@/tests/test-utils';
22 | 
23 | import IdeaMapCanvas from './IdeaMapCanvas';
24 | 
25 | // React Flow 모킹
26 | vi.mock('@xyflow/react', async () => {
27 |   const actual = await vi.importActual('@xyflow/react');
28 |   return {
29 |     ...actual,
30 |     Panel: ({
31 |       children,
32 |       className,
33 |       position = 'top-right',
34 |       ...props
35 |     }: {
36 |       children: ReactNode;
37 |       className?: string;
38 |       position?: string;
39 |       [key: string]: any;
40 |     }) => (
41 |       <div data-testid={`panel-${position}`} className={className} {...props}>
42 |         {children}
43 |       </div>
44 |     ),
45 |     ReactFlow: ({ children, onNodeClick, onPaneClick, defaultEdgeOptions, ...props }: {
46 |       children?: ReactNode;
47 |       onNodeClick?: (event: any, node: any) => void;
48 |       onPaneClick?: (event: any) => void;
49 |       defaultEdgeOptions?: any;
50 |       [key: string]: any;
51 |     }) => (
52 |       <div
53 |         className="react-flow"
54 |         data-testid="react-flow-container"
55 |         onClick={(e) => onPaneClick?.(e)}
56 |       >
57 |         <div data-testid="react-flow-nodes">
58 |           {props.nodes?.map((node: any) => (
59 |             <div
60 |               key={node.id}
61 |               data-testid={`node-${node.id}`}
62 |               onClick={(e) => onNodeClick?.(e, node)}
63 |             >
64 |               {JSON.stringify(node)}
65 |             </div>
66 |           ))}
67 |         </div>
68 |         <div data-testid="react-flow-edges">
69 |           {JSON.stringify(props.edges)}
70 |         </div>
71 |         <div data-testid="default-edge-options">
72 |           {JSON.stringify(defaultEdgeOptions)}
73 |         </div>
74 |         {children}
75 |       </div>
76 |     ),
77 |     Background: () => <div data-testid="react-flow-background" />,
78 |     Controls: () => <div data-testid="react-flow-controls" />,
79 |     MarkerType: {
80 |       ArrowClosed: 'arrowclosed'
81 |     },
82 |     ConnectionLineType: {
83 |       Bezier: 'bezier',
84 |       Straight: 'straight',
85 |       Step: 'step',
[TRUNCATED]
```

src/components/ideamap/components/IdeaMapCanvas.tsx
```
1 | /**
2 |  * 파일명: src/components/ideamap/components/IdeaMapCanvas.tsx
3 |  * 목적: ReactFlow 캔버스 렌더링 컴포넌트
4 |  * 역할: Board 컴포넌트에서 ReactFlow 캔버스 관련 로직을 분리하여 렌더링을 담당
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-03-30
7 |  * 수정일: 2023-10-27 : ESLint 오류 수정 (미사용 변수 제거, any 타입 수정)
8 |  * 수정일: 2023-10-27 : wrapperRef 타입을 SafeRef로 수정
9 |  * 수정일: 2023-10-27 : import 순서 수정 및 미사용 변수(ConnectionLineType) 제거
10 |  * 수정일: 2023-10-27 : connectionLineType 타입을 ConnectionLineType으로 수정
11 |  * 수정일: 2024-05-30 : fitView 옵션을 개선하여 노드가 항상 보이도록 수정
12 |  * 수정일: 2024-06-27 : fitView 옵션 개선 및 defaultViewport 설정 강화
13 |  * 수정일: 2024-06-27 : 뷰포트 관리 로직 추가 및 자동 fitView 기능 개선
14 |  * 수정일: 2024-06-28 : 디버깅을 위한 console.log 추가
15 |  * 수정일: 2024-07-18 : 엣지 관련 디버깅 로그 활성화 및 데이터 확인 로직 추가
16 |  */
17 | 
18 | 'use client';
19 | import React, { useMemo, useRef, useCallback, useEffect } from 'react';
20 | 
21 | import {
22 |   ReactFlow,
23 |   Controls,
24 |   Background,
25 |   ConnectionMode,
26 |   Node,
27 |   Edge,
28 |   NodeChange,
29 |   EdgeChange,
30 |   Connection,
31 |   OnConnectStart,
32 |   OnConnectEnd,
33 |   MarkerType,
34 |   Viewport,
35 |   ConnectionLineType,
36 |   ReactFlowInstance
37 | } from '@xyflow/react';
38 | 
39 | import { SafeRef } from '@/components/ideamap/types/ideamap-types';
40 | import { NODE_TYPES, EDGE_TYPES } from '@/lib/flow-constants';
41 | import { IdeaMapSettings } from '@/lib/ideamap-utils';
42 | // 노드 타입과 엣지 타입 컴포넌트 직접 가져오기
43 | // import CardNode from '@/components/ideamap/nodes/CardNode';
44 | // import CustomEdge from '@/components/ideamap/nodes/CustomEdge';
45 | // 노드 타입 직접 가져오기 대신 flow-constants에서 가져오기
46 | import { cn } from '@/lib/utils';
47 | // 삭제 3/29
48 | // import BoardControls from './BoardControls';
49 | 
50 | interface IdeaMapCanvasProps {
51 |   /** ReactFlow 노드 배열 */
52 |   nodes: Node[];
53 |   /** ReactFlow 엣지 배열 */
54 |   edges: Edge[];
55 |   /** 노드 변경 핸들러 */
56 |   onNodesChange: (changes: NodeChange[]) => void;
57 |   /** 엣지 변경 핸들러 */
58 |   onEdgesChange: (changes: EdgeChange[]) => void;
59 |   /** 연결 생성 핸들러 */
60 |   onConnect: (connection: Connection) => void;
61 |   /** 연결 시작 핸들러 */
62 |   onConnectStart: OnConnectStart;
63 |   /** 연결 종료 핸들러 */
64 |   onConnectEnd: OnConnectEnd;
65 |   /** 노드 클릭 핸들러 */
66 |   onNodeClick: (e: React.MouseEvent, node: Node) => void;
67 |   /** 빈 공간 클릭 핸들러 */
68 |   onPaneClick: (e: React.MouseEvent) => void;
69 |   /** 아이디어맵 설정 */
70 |   ideaMapSettings: IdeaMapSettings;
71 |   /** 컨트롤 표시 여부 */
72 |   showControls?: boolean;
73 |   /** 래퍼 ref */
74 |   wrapperRef: SafeRef<HTMLDivElement>;
[TRUNCATED]
```

src/components/ideamap/hooks/test-utils.ts
```
1 | /**
2 |  * 파일명: test-utils.ts
3 |  * 목적: 보드 핸들러 테스트를 위한 유틸리티 함수 및 모킹 객체 제공
4 |  * 역할: 테스트 설정, 정리, 모킹된 액션 제공
5 |  * 작성일: 2025-04-01
6 |  */
7 | 
8 | import { ReactNode } from 'react';
9 | 
10 | import { renderHook } from '@testing-library/react';
11 | import { Node, Edge, XYPosition } from '@xyflow/react';
12 | import { vi } from 'vitest';
13 | import { create } from 'zustand';
14 | 
15 | 
16 | 
17 | // 카드 데이터 타입 정의
18 | export interface CardData extends Record<string, unknown> {
19 |   id: string;
20 |   title: string;
21 |   content: string;
22 | }
23 | 
24 | // Zustand 스토어 타입 정의
25 | interface AppStore {
26 |   selectedCardIds: string[];
27 |   selectCards: (cardIds: string[]) => void;
28 | }
29 | 
30 | // 테스트 노드 데이터
31 | const TEST_NODES: Node<CardData>[] = [
32 |   {
33 |     id: 'node1',
34 |     position: { x: 0, y: 0 },
35 |     data: { id: 'card1', title: '카드 1', content: '내용 1' },
36 |     type: 'card',
37 |   },
38 |   {
39 |     id: 'node2',
40 |     position: { x: 100, y: 100 },
41 |     data: { id: 'card2', title: '카드 2', content: '내용 2' },
42 |     type: 'card',
43 |   },
44 | ];
45 | 
46 | // Zustand 스토어 모킹
47 | export const mockStore = create<AppStore>((set) => ({
48 |   selectedCardIds: [],
49 |   selectCards: (cardIds: string[]) => {
50 |     console.log('[AppStore] 카드 선택 변경:', cardIds);
51 |     set({ selectedCardIds: cardIds });
52 |   },
53 | }));
54 | 
55 | // 모킹된 액션들
56 | export const mockActions = {
57 |   store: {
58 |     saveLayout: vi.fn((nodesToSave?: Node<CardData>[]) => true),
59 |     setNodes: vi.fn((updater: ((nodes: Node<CardData>[]) => Node<CardData>[]) | Node<CardData>[]) => void {}),
60 |     fetchCards: vi.fn(async () => ({ nodes: TEST_NODES, edges: [] })),
61 |   },
62 |   selection: {
63 |     handleSelectionChange: vi.fn(({ nodes }: { nodes: Node[]; edges: Edge[] }) => void {}),
64 |   },
65 | };
66 | 
67 | /**
68 |  * createTestNodes: 테스트용 노드 생성
69 |  * @returns {Node<CardData>[]} 테스트용 노드 배열
70 |  */
71 | export const createTestNodes = (): Node<CardData>[] => TEST_NODES;
72 | 
73 | /**
74 |  * createReactFlowWrapper: ReactFlow 래퍼 요소 생성
75 |  * @returns {React.RefObject<HTMLDivElement>} ReactFlow 래퍼 요소의 ref 객체
76 |  */
77 | export const createReactFlowWrapper = () => {
78 |   const div = document.createElement('div');
79 |   div.style.width = '800px';
80 |   div.style.height = '600px';
81 |   return {
82 |     current: div,
83 |   };
84 | };
85 | 
86 | /**
87 |  * createReactFlowInstance: ReactFlow 인스턴스 생성
88 |  * @returns {Object} 모킹된 ReactFlow 인스턴스
89 |  */
90 | export const createReactFlowInstance = () => ({
[TRUNCATED]
```

src/components/ideamap/hooks/useEdges.test.tsx
```
1 | /**
2 |  * 파일명: useEdges.test.tsx
3 |  * 목적: useEdges 커스텀 훅 테스트
4 |  * 역할: 엣지 관련 훅이 useIdeaMapStore 액션을 올바르게 호출하는지 검증
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-11 (리팩토링)
7 |  */
8 | 
9 | import { renderHook, act } from '@testing-library/react';
10 | import { Edge, Connection, Node, MarkerType, ConnectionLineType, Position, EdgeChange } from '@xyflow/react';
11 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
12 | 
13 | import { IdeaMapSettings } from '@/lib/ideamap-utils';
14 | 
15 | // 모든 모킹은 파일 최상단에 위치
16 | vi.mock('sonner', () => ({
17 |   toast: {
18 |     success: vi.fn(),
19 |     info: vi.fn(),
20 |     error: vi.fn(),
21 |   }
22 | }));
23 | 
24 | // useIdeaMapStore 모킹
25 | vi.mock('@/store/useIdeaMapStore', () => {
26 |   const mockApplyEdgeChangesAction = vi.fn();
27 |   const mockConnectNodesAction = vi.fn();
28 |   const mockSaveEdgesAction = vi.fn().mockReturnValue(true);
29 |   const mockUpdateAllEdgeStylesAction = vi.fn();
30 |   const mockCreateEdgeOnDropAction = vi.fn();
31 |   const mockSetEdges = vi.fn();
32 | 
33 |   const edges = [{
34 |     id: 'edge-1',
35 |     source: 'node-1',
36 |     target: 'node-2',
37 |     type: 'custom',
38 |   }];
39 | 
40 |   return {
41 |     useIdeaMapStore: (selector: ((state: any) => any) | undefined) => {
42 |       if (typeof selector === 'function') {
43 |         const state = {
44 |           edges,
45 |           setEdges: mockSetEdges,
46 |           applyEdgeChangesAction: mockApplyEdgeChangesAction,
47 |           connectNodesAction: mockConnectNodesAction,
48 |           saveEdgesAction: mockSaveEdgesAction,
49 |           updateAllEdgeStylesAction: mockUpdateAllEdgeStylesAction,
50 |           createEdgeOnDropAction: mockCreateEdgeOnDropAction,
51 |           hasUnsavedChanges: false
52 |         };
53 |         return selector(state);
54 |       }
55 |       return {
56 |         edges,
57 |         setEdges: mockSetEdges,
58 |         applyEdgeChangesAction: mockApplyEdgeChangesAction,
59 |         connectNodesAction: mockConnectNodesAction,
60 |         saveEdgesAction: mockSaveEdgesAction,
61 |         updateAllEdgeStylesAction: mockUpdateAllEdgeStylesAction,
62 |         createEdgeOnDropAction: mockCreateEdgeOnDropAction,
63 |         hasUnsavedChanges: false
64 |       };
65 |     }
66 |   };
67 | });
68 | 
69 | // React Flow 모킹
70 | vi.mock('@xyflow/react', async () => {
71 |   const actual = await vi.importActual('@xyflow/react');
72 |   return {
73 |     ...actual,
74 |   };
75 | });
76 | 
77 | // 테스트할 훅 임포트
78 | import { useIdeaMapStore } from '@/store/useIdeaMapStore';
79 | 
80 | import { useEdges } from './useEdges';
81 | 
82 | // 테스트용 보드 설정
83 | const mockIdeaMapSettings: IdeaMapSettings = {
84 |   snapToGrid: false,
85 |   snapGrid: [15, 15],
86 |   connectionLineType: ConnectionLineType.SmoothStep,
87 |   markerEnd: MarkerType.Arrow as MarkerType, // 타입 캐스팅 추가
88 |   strokeWidth: 2,
89 |   markerSize: 20,
90 |   edgeColor: '#C1C1C1',
91 |   selectedEdgeColor: '#FF0072',
92 |   animated: false,
93 | };
94 | 
95 | // 테스트용 노드 데이터
96 | const mockNodes: Node[] = [
97 |   {
[TRUNCATED]
```

src/components/ideamap/hooks/useEdges.ts
```
1 | /**
2 |  * 파일명: useEdges.ts
3 |  * 목적: 엣지 관련 상태 및 로직 관리
4 |  * 역할: useIdeaMapStore의 엣지 관련 액션들을 사용하는 래퍼 훅
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-11
7 |  */
8 | 
9 | import { useCallback } from 'react';
10 | 
11 | import { Edge, Connection, Node, EdgeChange } from '@xyflow/react';
12 | 
13 | import { IdeaMapSettings } from '@/lib/ideamap-utils';
14 | import { useIdeaMapStore } from '@/store/useIdeaMapStore';
15 | 
16 | /**
17 |  * useEdges: useIdeaMapStore의 엣지 관련 액션들을 사용하는 래퍼 훅
18 |  * @param ideaMapSettings 아이디어맵 설정 객체
19 |  * @param nodes 노드 배열
20 |  * @param initialEdges 초기 엣지 데이터 (옵션)
21 |  * @returns 엣지 관련 상태 및 함수들
22 |  */
23 | export function useEdges({
24 |   ideaMapSettings,
25 |   nodes,
26 |   initialEdges = []
27 | }: {
28 |   ideaMapSettings: IdeaMapSettings;
29 |   nodes: Node[];
30 |   initialEdges?: Edge[];
31 | }) {
32 |   // useIdeaMapStore에서 엣지 관련 상태 및 액션 가져오기
33 |   const edges = useIdeaMapStore(state => state.edges);
34 |   const setEdges = useIdeaMapStore(state => state.setEdges);
35 |   const applyEdgeChangesAction = useIdeaMapStore(state => state.applyEdgeChangesAction);
36 |   const connectNodesAction = useIdeaMapStore(state => state.connectNodesAction);
37 |   const saveEdgesAction = useIdeaMapStore(state => state.saveEdgesAction);
38 |   const updateAllEdgeStylesAction = useIdeaMapStore(state => state.updateAllEdgeStylesAction);
39 |   const createEdgeOnDropAction = useIdeaMapStore(state => state.createEdgeOnDropAction);
40 |   const hasUnsavedChanges = useIdeaMapStore(state => state.hasUnsavedChanges);
41 | 
42 |   // 엣지 변경 핸들러 (단순히 useIdeaMapStore 액션 호출)
43 |   const handleEdgesChange = useCallback((changes: EdgeChange[]) => {
44 |     applyEdgeChangesAction(changes);
45 |   }, [applyEdgeChangesAction]);
46 | 
47 |   // 노드 연결 핸들러 (단순히 useIdeaMapStore 액션 호출)
48 |   const onConnect = useCallback((params: Connection) => {
49 |     connectNodesAction(params);
50 |   }, [connectNodesAction]);
51 | 
52 |   // 엣지 저장 함수 (단순히 useIdeaMapStore 액션 호출)
53 |   const saveEdges = useCallback((edgesToSave?: Edge[]) => {
54 |     // 특정 엣지 목록이 제공되면 먼저 상태 업데이트
55 |     if (edgesToSave) {
56 |       setEdges(edgesToSave);
57 |     }
58 |     return saveEdgesAction();
59 |   }, [setEdges, saveEdgesAction]);
60 | 
61 |   // 엣지 스타일 업데이트 함수 (단순히 useIdeaMapStore 액션 호출)
62 |   const updateEdgeStyles = useCallback(() => {
63 |     updateAllEdgeStylesAction();
64 |   }, [updateAllEdgeStylesAction]);
65 | 
66 |   // 엣지 생성 함수 (단순히 useIdeaMapStore 액션 호출)
67 |   const createEdgeOnDrop = useCallback((sourceId: string, targetId: string) => {
68 |     return createEdgeOnDropAction(sourceId, targetId);
69 |   }, [createEdgeOnDropAction]);
70 | 
71 |   // 기존 API와 호환성을 위해 동일한 인터페이스 유지
72 |   return {
73 |     edges,
74 |     setEdges,
75 |     handleEdgesChange,
76 |     onConnect,
77 |     saveEdges,
78 |     updateEdgeStyles,
79 |     createEdgeOnDrop,
80 |     hasUnsavedChanges
81 |   };
82 | } 
```

src/components/ideamap/hooks/useIdeaMapData.test.tsx
```
1 | /**
2 |  * 파일명: src/components/ideamap/hooks/useIdeaMapData.test.tsx
3 |  * 목적: useIdeaMapData 훅의 기능 테스트
4 |  * 역할: 아이디어맵 데이터 로딩 및 로딩 상태 관리 테스트
5 |  * 작성일: 2023-04-10
6 |  * 수정일: 2025-05-05
7 |  * 수정일: 2025-05-06 : 미사용 변수 제거 및 ESLint 오류 수정
8 |  * 수정일: 2025-05-07 : IdeaMapState 인터페이스에 누락된 속성 추가
9 |  * 수정일: 2025-05-07 : 남아있는 ESLint 오류 수정
10 |  */
11 | 
12 | import { renderHook, act } from '@testing-library/react';
13 | import { ConnectionLineType, MarkerType } from '@xyflow/react';
14 | import { http, HttpResponse } from 'msw';
15 | import { describe, it, expect, beforeEach, vi, afterEach, afterAll, beforeAll } from 'vitest';
16 | 
17 | import { useIdeaMapStore } from '@/store/useIdeaMapStore';
18 | import { mockLocalStorage } from '@/tests/mocks/storage-mock';
19 | import { server } from '@/tests/msw/server';
20 | 
21 | import { useIdeaMapData } from './useIdeaMapData';
22 | 
23 | // 모든 모킹은 파일 상단에 그룹화
24 | // 외부 모듈부터 모킹 (호이스팅 고려)
25 | // @xyflow/react 모킹
26 | const mockFitView = vi.fn().mockResolvedValue(undefined);
27 | const mockSetViewport = vi.fn().mockResolvedValue(undefined);
28 | const mockGetZoom = vi.fn().mockReturnValue(1);
29 | const mockGetViewport = vi.fn().mockReturnValue({ x: 0, y: 0, zoom: 1 });
30 | 
31 | vi.mock('@xyflow/react', async () => {
32 |   const actual = await vi.importActual('@xyflow/react');
33 |   return {
34 |     ...actual,
35 |     useReactFlow: () => ({
36 |       fitView: mockFitView,
37 |       setViewport: mockSetViewport,
38 |       getZoom: mockGetZoom,
39 |       getViewport: mockGetViewport
40 |     })
41 |   };
42 | });
43 | 
44 | // loadIdeaMapData 모킹을 위한 함수
45 | const mockLoadIdeaMapData = vi.fn().mockResolvedValue(undefined);
46 | 
47 | // 기본 상태 객체 정의 - IdeaMapState 인터페이스에 맞춰 모든 필수 속성 포함
48 | const createMockState = (overrides = {}) => ({
49 |   // 노드 관련
50 |   nodes: [{
51 |     id: 'node-1',
52 |     position: { x: 0, y: 0 },
53 |     data: {
54 |       id: 'card-1',
55 |       title: '카드 1',
56 |       content: '카드 1 내용',
57 |       tags: []
58 |     }
59 |   }],
60 |   setNodes: vi.fn(),
61 |   onNodesChange: vi.fn(),
62 | 
63 |   // 엣지 관련
64 |   edges: [{ id: 'edge-1', source: 'node-1', target: 'node-2' }],
65 |   setEdges: vi.fn(),
66 |   onEdgesChange: vi.fn(),
67 |   onConnect: vi.fn(),
68 | 
69 |   // 아이디어맵 설정
70 |   ideaMapSettings: {
71 |     layout: 'horizontal',
72 |     strokeWidth: 2,
73 |     animated: false,
74 |     lineType: 'straight',
75 |     nodePadding: 10,
76 |     nodeSpacing: 20,
77 |     applyForce: false,
78 |     snapToGrid: false,
79 |     snapGrid: [10, 10] as [number, number],
80 |     connectionLineType: 'bezier' as ConnectionLineType,
[TRUNCATED]
```

src/components/ideamap/hooks/useIdeaMapData.ts
```
1 | /**
2 |  * 파일명: useIdeaMapData.ts
3 |  * 목적: 아이디어맵 데이터 로드 및 관리를 위한 커스텀 훅
4 |  * 역할: useIdeaMapStore에서 아이디어맵 데이터와 로딩 상태를 가져오는 래퍼 훅
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-10
7 |  * 수정일: 2025-04-17 : 렌더링 최적화 (불필요한 리렌더링 방지)
8 |  */
9 | 
10 | import { Edge } from '@xyflow/react';
11 | import { useState, useCallback, useEffect, useRef } from 'react';
12 | import { Node } from '@xyflow/react';
13 | import { useAppStore } from '@/store/useAppStore';
14 | import { useIdeaMapStore } from '@/store/useIdeaMapStore';
15 | 
16 | import { Node as NodeType, CardData } from '../types/ideamap-types';
17 | 
18 | /**
19 |  * useIdeaMapData: 아이디어맵 데이터를 로드하고 관리하는 훅
20 |  * @param onSelectCard 카드 선택 시 호출될 콜백 함수
21 |  * @returns {Object} 아이디어맵 데이터 관련 상태와 함수들
22 |  */
23 | export function useIdeaMapData(onSelectCard: (cardId: string) => void) {
24 |   console.log('[useIdeaMapData] 훅 초기화');
25 |   
26 |   // 상태 관리
27 |   const [isLoading, setIsLoading] = useState(true);
28 |   const [error, setError] = useState<Error | null>(null);
29 |   
30 |   // 초기 데이터 로드 완료 여부 추적
31 |   const initialLoadCompleteRef = useRef(false);
32 |   
33 |   // 아이디어맵 스토어에서 필요한 상태와 액션만 선택적으로 가져오기
34 |   const nodes = useIdeaMapStore(state => state.nodes);
35 |   const edges = useIdeaMapStore(state => state.edges);
36 |   const isIdeaMapLoading = useIdeaMapStore(state => state.isIdeaMapLoading);
37 |   const ideaMapError = useIdeaMapStore(state => state.ideaMapError);
38 |   const loadIdeaMapData = useIdeaMapStore(state => state.loadIdeaMapData);
39 |   const loadedViewport = useIdeaMapStore(state => state.loadedViewport);
40 |   const needsFitView = useIdeaMapStore(state => state.needsFitView);
41 |   
42 |   // 앱 스토어에서 필요한 액션만 선택적으로 가져오기
43 |   const setCards = useAppStore(state => state.setCards);
44 |   
45 |   /**
46 |    * 노드와 엣지 데이터 로드 함수
47 |    */
48 |   const loadNodesAndEdges = useCallback(async () => {
49 |     console.log('[useIdeaMapData] loadNodesAndEdges 함수 호출');
50 |     
51 |     // 이미 로드 완료된 상태면 중복 호출 방지
52 |     if (initialLoadCompleteRef.current && !isLoading) {
53 |       console.log('[useIdeaMapData] 이미 데이터 로드 완료, 중복 호출 방지');
54 |       return;
55 |     }
56 |     
57 |     try {
58 |       setIsLoading(true);
59 |       setError(null);
60 |       
61 |       console.log('[useIdeaMapData] 아이디어맵 데이터 로드 시작');
62 |       // 카드 데이터 API에서 가져오기
63 |       const response = await fetch('/api/cards');
64 |       
65 |       if (!response.ok) {
66 |         throw new Error(`데이터 로드 실패 (상태: ${response.status})`);
67 |       }
68 |       
69 |       const cardData = await response.json();
70 |       console.log('[useIdeaMapData] API에서 카드 데이터 로드 완료:', { 카드수: cardData.length });
71 |       
[TRUNCATED]
```

src/components/ideamap/hooks/useIdeaMapHandlers.test.tsx
```
1 | /**
2 |  * 파일명: useIdeaMapHandlers.test.tsx
3 |  * 목적: 아이디어맵 핸들러 훅의 기능 테스트
4 |  * 역할: 선택, 드래그 앤 드롭, 카드 생성 핸들러 테스트
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-11
7 |  */
8 | 
9 | import { act } from '@testing-library/react';
10 | import { renderHook } from '@testing-library/react';
11 | import { Node, Edge } from '@xyflow/react';
12 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
13 | 
14 | import { useAppStore } from '@/store/useAppStore';
15 | import { useIdeaMapStore } from '@/store/useIdeaMapStore';
16 | import {
17 |   createTestNode,
18 |   createDragEvent,
19 |   createMouseEvent,
20 |   mockReactFlow
21 | } from '@/tests/test-utils';
22 | 
23 | import { useIdeaMapHandlers } from './useIdeaMapHandlers';
24 | import { CardData } from '../types/ideamap-types';
25 | 
26 | // Zustand 스토어 모킹
27 | const mockSelectCards = vi.fn();
28 | vi.mock('@/store/useAppStore', () => ({
29 |   useAppStore: vi.fn((selector) => {
30 |     const state = {
31 |       selectedCardIds: [],
32 |       selectCards: mockSelectCards,
33 |     };
34 |     return selector ? selector(state) : state;
35 |   }),
36 | }));
37 | 
38 | // useIdeaMapStore 모킹
39 | const mockAddNodeAtPosition = vi.fn().mockResolvedValue({ id: 'new-node', data: { title: '새 노드' } });
40 | const mockAddCardAtCenterPosition = vi.fn().mockResolvedValue({ id: 'new-card', data: { title: '새 카드' } });
41 | const mockCreateEdgeAndNodeOnDrop = vi.fn().mockResolvedValue({ id: 'edge-node', data: { title: '연결 노드' } });
42 | 
43 | vi.mock('@/store/useIdeaMapStore', () => ({
44 |   useIdeaMapStore: vi.fn((selector) => {
45 |     const state = {
46 |       addNodeAtPosition: mockAddNodeAtPosition,
47 |       addCardAtCenterPosition: mockAddCardAtCenterPosition,
48 |       createEdgeAndNodeOnDrop: mockCreateEdgeAndNodeOnDrop,
49 |     };
50 |     return selector ? selector(state) : state;
51 |   }),
52 | }));
53 | 
54 | describe('useIdeaMapHandlers', () => {
55 |   // 테스트 데이터 준비
56 |   const testNodes = [
57 |     createTestNode('card1'),
58 |     createTestNode('card2'),
59 |   ];
60 | 
61 |   // HTMLDivElement 생성
62 |   const divElement = document.createElement('div');
63 |   Object.defineProperties(divElement, {
64 |     getBoundingClientRect: {
65 |       value: () => ({
66 |         left: 0,
67 |         top: 0,
68 |         right: 800,
69 |         bottom: 600,
70 |         width: 800,
71 |         height: 600,
72 |       }),
73 |     },
74 |   });
75 | 
76 |   const mockProps = {
77 |     reactFlowWrapper: { current: divElement } as React.RefObject<HTMLDivElement>,
78 |     reactFlowInstance: mockReactFlow,
79 |     fetchCards: vi.fn().mockResolvedValue({ nodes: [], edges: [] }),
80 |   };
81 | 
82 |   beforeEach(() => {
83 |     vi.clearAllMocks();
84 |     // setTimeout 모킹
85 |     vi.useFakeTimers();
86 |   });
87 | 
88 |   afterEach(() => {
89 |     vi.useRealTimers();
90 |   });
91 | 
92 |   describe('선택 핸들러', () => {
93 |     it('노드가 선택되면 선택된 카드 ID를 업데이트한다', () => {
[TRUNCATED]
```

src/components/ideamap/hooks/useIdeaMapHandlers.ts
```
1 | /**
2 |  * 파일명: useBoardHandlers.ts
3 |  * 목적: 보드 이벤트 핸들러 관련 로직 분리
4 |  * 역할: 보드 드래그, 드롭, 선택 등 이벤트 처리 로직을 관리
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-11
7 |  */
8 | 
9 | import { useCallback } from 'react';
10 | 
11 | import { Node, Edge, XYPosition } from '@xyflow/react';
12 | 
13 | import { useAppStore } from '@/store/useAppStore';
14 | import { useIdeaMapStore } from '@/store/useIdeaMapStore';
15 | 
16 | import { CardData } from '../types/ideamap-types';
17 | 
18 | /**
19 |  * useIdeaMapHandlers: 아이디어맵 이벤트 핸들러 관련 로직을 관리하는 훅
20 |  * @param reactFlowWrapper ReactFlow 래퍼 참조
21 |  * @param reactFlowInstance ReactFlow 인스턴스
22 |  * @param fetchCards 카드 데이터를 다시 불러오는 함수
23 |  * @returns 아이디어맵 이벤트 핸들러 함수들
24 |  */
25 | export function useIdeaMapHandlers({
26 |   reactFlowWrapper,
27 |   reactFlowInstance,
28 |   fetchCards
29 | }: {
30 |   reactFlowWrapper: React.RefObject<HTMLDivElement>;
31 |   reactFlowInstance: any;
32 |   fetchCards: () => Promise<{ nodes: Node<CardData>[]; edges: Edge[] }>;
33 | }) {
34 |   // 전역 상태에서 선택된 카드 정보 및 액션 가져오기
35 |   const { selectCards } = useAppStore();
36 |   
37 |   // 아이디어맵 스토어에서 노드 추가 관련 액션 가져오기
38 |   const addNodeAtPosition = useIdeaMapStore(state => state.addNodeAtPosition);
39 |   const addCardAtCenterPosition = useIdeaMapStore(state => state.addCardAtCenterPosition);
40 |   const createEdgeAndNodeOnDrop = useIdeaMapStore(state => state.createEdgeAndNodeOnDrop);
41 | 
42 |   /**
43 |    * ReactFlow 선택 변경 이벤트 핸들러
44 |    * @param selection 현재 선택된 노드와 엣지 정보
45 |    */
46 |   const handleSelectionChange = useCallback(({ nodes }: { nodes: Node<CardData>[]; edges: Edge[] }) => {
47 |     console.log('[IdeaMapComponent] 선택 변경 감지:', { 
48 |       선택된_노드_수: nodes.length,
49 |       선택된_노드_ID: nodes.map(node => node.data.id)
50 |     });
51 | 
52 |     // 선택된 노드 ID 배열 추출
53 |     const selectedNodeIds = nodes.map(node => node.data.id);
54 |     
55 |     // 전역 상태 업데이트
56 |     selectCards(selectedNodeIds);
57 |   }, [selectCards]);
58 | 
59 |   /**
60 |    * 드래그 오버 이벤트 핸들러
61 |    * @param event 드래그 이벤트
62 |    */
63 |   const onDragOver = useCallback((event: React.DragEvent) => {
64 |     event.preventDefault();
65 |     event.dataTransfer.dropEffect = 'move';
66 |   }, []);
67 | 
68 |   /**
69 |    * 드롭 이벤트 핸들러
70 |    * @param event 드롭 이벤트
71 |    */
72 |   const onDrop = useCallback((event: React.DragEvent) => {
73 |     event.preventDefault();
74 | 
75 |     // React Flow 래퍼 요소가 없으면 중단
76 |     if (!reactFlowWrapper.current || !reactFlowInstance) {
77 |       return;
78 |     }
79 | 
80 |     // 드래그된 데이터 확인
81 |     const reactFlowData = event.dataTransfer.getData('application/reactflow');
82 |     if (!reactFlowData) return;
83 | 
84 |     try {
85 |       // 데이터 파싱
[TRUNCATED]
```

src/components/ideamap/hooks/useIdeaMapUtils.test.tsx
```
1 | /**
2 |  * 파일명: useIdeaMapUtils.test.tsx
3 |  * 목적: useIdeaMapUtils 훅을 테스트
4 |  * 역할: 아이디어맵 유틸리티 함수 관련 기능을 검증
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-01
7 |  */
8 | 
9 | import { renderHook, act } from '@testing-library/react';
10 | import { ConnectionLineType, MarkerType, Node, Edge, Viewport } from '@xyflow/react';
11 | import { http, HttpResponse } from 'msw';
12 | import { toast } from 'sonner';
13 | import { vi, expect, beforeEach, afterEach, beforeAll, afterAll } from 'vitest';
14 | 
15 | import { IDEAMAP_TRANSFORM_KEY } from '@/lib/ideamap-constants';
16 | import { IdeaMapSettings, saveIdeaMapSettingsToServer, loadIdeaMapSettingsFromServer } from '@/lib/ideamap-utils';
17 | import { getGridLayout, getLayoutedElements } from '@/lib/layout-utils';
18 | import { useAppStore } from '@/store/useAppStore';
19 | import { AppState } from '@/store/useAppStore';
20 | import { server } from '@/tests/msw/server';
21 | import { mockReactFlow } from '@/tests/utils/react-flow-mock';
22 | 
23 | import { useIdeaMapUtils } from './useIdeaMapUtils';
24 | 
25 | // MSW 서버 설정
26 | beforeAll(() => server.listen());
27 | afterEach(() => server.resetHandlers());
28 | afterAll(() => server.close());
29 | 
30 | // 기본 모의 엣지 배열 생성
31 | const defaultMockEdges = [
32 |   { id: 'edge-mock-1', source: 'node1', target: 'node2' },
33 | ];
34 | 
35 | // 기본 모의 노드 배열 생성
36 | const defaultLayoutedNodes = [
37 |   { id: 'node1', position: { x: 0, y: 0 }, data: { title: '카드 1', content: '내용 1' } },
38 |   { id: 'node2', position: { x: 100, y: 100 }, data: { title: '카드 2', content: '내용 2' } },
39 | ];
40 | 
41 | // 모든 vi.mock 호출을 먼저 수행
42 | vi.mock('@xyflow/react', async () => {
43 |   const actual = await vi.importActual('@xyflow/react');
44 |   return {
45 |     ...actual,
46 |     useReactFlow: () => ({
47 |       ...mockReactFlow,
48 |       getViewport: () => ({ x: 100, y: 200, zoom: 2 }),
49 |     }),
50 |     MarkerType: {
51 |       ArrowClosed: 'arrowclosed',
52 |     },
53 |     ConnectionLineType: {
54 |       Bezier: 'bezier',
55 |       Step: 'step',
56 |       SmoothStep: 'smoothstep',
57 |       Straight: 'straight',
58 |     }
59 |   };
60 | });
61 | 
62 | // Zustand 스토어 모킹
63 | vi.mock('@/store/useAppStore', () => {
64 |   const setIdeaMapSettingsMock = vi.fn();
65 | 
66 |   return {
67 |     useAppStore: (selector: ((state: Partial<AppState>) => any) | undefined) => {
68 |       if (typeof selector === 'function') {
69 |         return selector({
70 |           ideaMapSettings: {
71 |             strokeWidth: 2,
72 |             edgeColor: '#000000',
73 |             selectedEdgeColor: '#ff0000',
74 |             animated: false,
75 |             markerEnd: 'arrowclosed' as MarkerType,
76 |             connectionLineType: 'straight' as ConnectionLineType,
77 |             snapToGrid: false,
78 |             snapGrid: [20, 20] as [number, number],
79 |             markerSize: 20,
80 |           },
81 |           setIdeaMapSettings: setIdeaMapSettingsMock,
82 |         });
83 |       }
84 | 
[TRUNCATED]
```

src/components/ideamap/hooks/useIdeaMapUtils.ts
```
1 | /**
2 |  * 파일명: useIdeaMapUtils.ts
3 |  * 목적: 아이디어맵 유틸리티 함수 관련 로직 분리
4 |  * 역할: 아이디어맵 레이아웃, 저장, 초기화 등 유틸리티 함수를 관리
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2023-10-27 : 미사용 import 및 변수 제거, useCallback 의존성 배열 수정
7 |  */
8 | 
9 | import { useCallback, useRef } from 'react';
10 | 
11 | import { Node, Edge, useReactFlow } from '@xyflow/react';
12 | import { toast } from 'sonner';
13 | 
14 | import { IDEAMAP_TRANSFORM_STORAGE_KEY } from '@/lib/ideamap-constants';
15 | import {
16 |   IdeaMapSettings,
17 |   loadIdeaMapSettingsFromServer,
18 |   saveIdeaMapSettingsToServer
19 | } from '@/lib/ideamap-utils';
20 | import { getGridLayout, getLayoutedElements } from '@/lib/layout-utils';
21 | import { useAppStore } from '@/store/useAppStore';
22 | 
23 | import { CardData } from '../types/ideamap-types';
24 | 
25 | /**
26 |  * useIdeaMapUtils: 아이디어맵 유틸리티 함수 관련 로직을 관리하는 훅
27 |  * @param reactFlowWrapper ReactFlow 래퍼 참조
28 |  * @param saveLayout 레이아웃 저장 함수
29 |  * @param saveEdges 엣지 저장 함수
30 |  * @param nodes 현재 노드 배열
31 |  * @param edges 현재 엣지 배열
32 |  * @param setNodes 노드 상태 설정 함수
33 |  * @param setEdges 엣지 상태 설정 함수
34 |  * @returns 아이디어맵 유틸리티 함수들
35 |  */
36 | export function useIdeaMapUtils({
37 |   reactFlowWrapper,
38 |   saveLayout,
39 |   saveEdges,
40 |   nodes,
41 |   edges,
42 |   setNodes,
43 |   setEdges
44 | }: {
45 |   reactFlowWrapper: React.RefObject<HTMLDivElement | null>;
46 |   updateNodeInternals?: (nodeId: string) => void;
47 |   saveLayout: (nodesToSave?: Node<CardData>[]) => boolean;
48 |   saveEdges: (edgesToSave?: Edge[]) => boolean;
49 |   nodes: Node<CardData>[];
50 |   edges: Edge[];
51 |   setNodes: (updater: ((nodes: Node<CardData>[]) => Node<CardData>[]) | Node<CardData>[]) => void;
52 |   setEdges: (updater: ((edges: Edge[]) => Edge[]) | Edge[]) => void;
53 | }) {
54 |   // 전역 상태에서 아이디어맵 설정 가져오기
55 |   const { setIdeaMapSettings } = useAppStore();
56 |   
57 |   // 저장되지 않은 변경사항 플래그
58 |   const hasUnsavedChanges = useRef(false);
59 |   
60 |   // ReactFlow 인스턴스
61 |   const reactFlowInstance = useReactFlow();
62 | 
63 |   /**
64 |    * 엣지 설정 적용 헬퍼 함수
65 |    * @param currentEdges 현재 엣지 배열
66 |    * @param settings 적용할 설정
67 |    * @returns 설정이 적용된 엣지 배열
68 |    */
69 |   const applyIdeaMapEdgeSettings = useCallback((currentEdges: Edge[], settings: IdeaMapSettings) => {
70 |     return currentEdges.map(edge => ({
71 |       ...edge,
72 |       animated: settings.animated,
73 |       style: {
74 |         ...edge.style,
75 |         strokeWidth: settings.strokeWidth,
76 |         stroke: edge.selected ? settings.selectedEdgeColor : settings.edgeColor
77 |       },
78 |       markerEnd: settings.markerEnd ? {
79 |         type: settings.markerEnd,
80 |         width: settings.markerSize,
81 |         height: settings.markerSize,
82 |       } : undefined
83 |     }));
84 |   }, []);
85 | 
86 |   /**
[TRUNCATED]
```

src/components/ideamap/hooks/useNodes.test.tsx
```
1 | /**
2 |  * 파일명: useNodes.test.tsx
3 |  * 목적: useNodeClickHandlers 커스텀 훅 테스트
4 |  * 역할: 노드 클릭 핸들러 기능의 정상 작동 검증
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-11
7 |  */
8 | 
9 | import { renderHook, act } from '@testing-library/react';
10 | import { Node } from '@xyflow/react';
11 | import { describe, it, expect, vi, beforeEach, afterEach, beforeAll, afterAll } from 'vitest';
12 | 
13 | 
14 | // 모든 모킹은 파일 상단에 배치 (호이스팅 문제 방지)
15 | // React Flow 모킹
16 | vi.mock('@/tests/utils/react-flow-mock', () => ({
17 |   mockReactFlow: vi.fn()
18 | }));
19 | 
20 | // useAppStore 모킹
21 | const clearSelectedCardsMock = vi.fn();
22 | const selectCardMock = vi.fn();
23 | const toggleSelectedCardMock = vi.fn();
24 | 
25 | vi.mock('@/store/useAppStore', () => ({
26 |   useAppStore: vi.fn(() => ({
27 |     selectedCardIds: ['test-node-1'],
28 |     toggleSelectedCard: toggleSelectedCardMock,
29 |     selectCard: selectCardMock,
30 |     clearSelectedCards: clearSelectedCardsMock,
31 |   }))
32 | }));
33 | 
34 | // 토스트 모킹
35 | vi.mock('sonner', () => ({
36 |   toast: {
37 |     success: vi.fn(),
38 |     info: vi.fn(),
39 |     error: vi.fn()
40 |   }
41 | }));
42 | 
43 | // 실제 컴포넌트 및 유틸리티 임포트 (모킹 후 임포트)
44 | import { mockReactFlow } from '@/tests/utils/react-flow-mock';
45 | 
46 | import { useNodeClickHandlers } from './useNodes';
47 | import { CardData } from '../types/board-types';
48 | 
49 | describe('useNodeClickHandlers', () => {
50 |   // 테스트 전 전역 설정
51 |   beforeAll(() => {
52 |     mockReactFlow();
53 |   });
54 | 
55 |   // 각 테스트 전 초기화
56 |   beforeEach(() => {
57 |     // 모든 모의 함수 초기화
58 |     vi.clearAllMocks();
59 |   });
60 | 
61 |   // 각 테스트 후 정리
62 |   afterEach(() => {
63 |     vi.resetAllMocks();
64 |   });
65 | 
66 |   // 모든 테스트 후 정리
67 |   afterAll(() => {
68 |     vi.restoreAllMocks();
69 |   });
70 | 
71 |   it('초기 상태가 올바르게 반환되어야 함', () => {
72 |     const { result } = renderHook(() => useNodeClickHandlers({}));
73 | 
74 |     expect(typeof result.current.handleNodeClick).toBe('function');
75 |     expect(typeof result.current.handlePaneClick).toBe('function');
76 |   });
77 | 
78 |   it('노드 클릭 시 handleNodeClick이 selectCard를 호출해야 함', () => {
79 |     const onSelectCardMock = vi.fn();
80 |     const { result } = renderHook(() => useNodeClickHandlers({ onSelectCard: onSelectCardMock }));
81 | 
82 |     // 테스트 노드 - 아직 선택되지 않은 노드를 사용
83 |     const testNode: Node<CardData> = {
84 |       id: 'test-node-2', // 선택되지 않은 새 노드 ID
85 |       type: 'default',
86 |       position: { x: 100, y: 200 },
87 |       data: {
88 |         id: 'test-node-2',
89 |         title: '테스트 노드 2',
[TRUNCATED]
```

src/components/ideamap/hooks/useNodes.ts
```
1 | /**
2 |  * 파일명: useNodes.ts
3 |  * 목적: 노드 클릭 핸들러 로직 관리
4 |  * 역할: 노드 클릭 및 패널 클릭 이벤트 핸들링 로직 캡슐화
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-11
7 |  */
8 | 
9 | import { useCallback } from 'react';
10 | 
11 | import { 
12 |   NodeMouseHandler,
13 |   Node
14 | } from '@xyflow/react';
15 | import { toast } from 'sonner';
16 | 
17 | import { useAppStore } from '@/store/useAppStore';
18 | 
19 | import { CardData } from '../types/board-types';
20 | 
21 | /**
22 |  * useNodeClickHandlers: 노드 클릭 관련 핸들러를 제공하는 훅
23 |  * @param onSelectCard 카드 선택 시 호출될 콜백 함수 (옵션)
24 |  * @param onNodeDoubleClick 노드 더블 클릭 시 호출될 콜백 함수 (옵션)
25 |  * @returns 노드 클릭 관련 핸들러 함수들
26 |  */
27 | export function useNodeClickHandlers({
28 |   onSelectCard,
29 |   onNodeDoubleClick
30 | }: {
31 |   onSelectCard?: (cardId: string | null) => void;
32 |   onNodeDoubleClick?: (node: Node<CardData>) => void;
33 | }) {
34 |   // 전역 상태에서 선택된 카드 정보 가져오기
35 |   const { selectedCardIds, toggleSelectedCard, selectCard, clearSelectedCards } = useAppStore();
36 |   
37 |   /**
38 |    * 노드 클릭 핸들러: 노드 선택 처리
39 |    * @param event 마우스 이벤트
40 |    * @param node 클릭된 노드
41 |    */
42 |   const handleNodeClick = useCallback<NodeMouseHandler>((event, node) => {
43 |     // 이벤트 전파 방지는 항상 수행
44 |     event.stopPropagation();
45 | 
46 |     // 노드가 undefined인 경우 처리
47 |     if (!node) {
48 |       console.warn('클릭된 노드가 undefined입니다.');
49 |       return;
50 |     }
51 |     
52 |     // 노드 타입 안전하게 변환
53 |     const typedNode = node as Node<CardData>;
54 |     
55 |     // 더블 클릭 처리
56 |     if (event.detail === 2 && onNodeDoubleClick) {
57 |       onNodeDoubleClick(typedNode);
58 |       return;
59 |     }
60 |     
61 |     // 다중 선택 모드 (Ctrl/Cmd 키 누른 상태)
62 |     const isMultiSelectMode = event.ctrlKey || event.metaKey;
63 |     
64 |     // 노드 id 가져오기
65 |     const nodeId = typedNode.id;
66 |     
67 |     // 기본 이벤트 관리
68 |     event.stopPropagation();
69 |     
70 |     if (isMultiSelectMode) {
71 |       // 다중 선택 모드: 선택된 카드 목록에 추가/제거
72 |       console.log('다중 선택 모드로 노드 클릭:', nodeId);
73 |       
74 |       // 토스트 메시지 결정을 위해 현재 선택 상태 미리 확인
75 |       const isCurrentlySelected = selectedCardIds.includes(nodeId);
76 |       
77 |       // 상태 업데이트
78 |       toggleSelectedCard(nodeId);
79 |       
80 |       // 성공 메시지 표시 - 다중 선택 모드
81 |       if (isCurrentlySelected) {
82 |         toast.success(`'${typedNode.data.title}'가 선택에서 제거되었습니다.`);
83 |       } else {
84 |         toast.success(`'${typedNode.data.title}'가 선택에 추가되었습니다.`);
85 |       }
86 |     } else {
[TRUNCATED]
```

src/components/ideamap/nodes/CardNode.test.tsx
```
1 | /**
2 |  * 파일명: CardNode.test.tsx
3 |  * 목적: CardNode 컴포넌트 테스트
4 |  * 역할: 카드 노드 컴포넌트의 기능 테스트
5 |  * 작성일: 2025-04-01
6 |  */
7 | 
8 | import { render, screen, fireEvent, waitFor } from '@testing-library/react';
9 | import { ReactFlowProvider, Node, NodeProps } from '@xyflow/react';
10 | import { describe, it, expect, vi, beforeEach, beforeAll } from 'vitest';
11 | 
12 | import { ThemeProvider } from '@/contexts/ThemeContext';
13 | import { DEFAULT_IDEAMAP_SETTINGS } from '@/lib/ideamap-utils';
14 | 
15 | // TiptapViewer 모킹
16 | vi.mock('@/components/editor/TiptapViewer', () => ({
17 |     default: ({ content }: { content: string }) => (
18 |         <div data-testid="tiptap-viewer">{content}</div>
19 |     )
20 | }));
21 | 
22 | // EditCardModal 모킹
23 | vi.mock('@/components/cards/EditCardModal', () => ({
24 |     EditCardModal: vi.fn(({ onClose }) => (
25 |         <div data-testid="edit-card-modal">
26 |             <button onClick={onClose} data-testid="close-modal-button">닫기</button>
27 |         </div>
28 |     ))
29 | }));
30 | 
31 | // ThemeContext 모킹
32 | vi.mock('@/contexts/ThemeContext', () => ({
33 |     useTheme: () => ({
34 |         theme: {
35 |             node: {
36 |                 width: 200,
37 |                 height: 30,
38 |                 maxHeight: 200,
39 |                 backgroundColor: '#ffffff',
40 |                 borderWidth: 1,
41 |                 borderColor: '#e2e8f0',
42 |                 selectedBorderColor: '#3b82f6',
43 |                 borderRadius: 6,
44 |                 font: {
45 |                     titleSize: 14,
46 |                     contentSize: 12,
47 |                     tagsSize: 10
48 |                 }
49 |             },
50 |             handle: {
51 |                 size: 8,
52 |                 backgroundColor: '#ffffff',
53 |                 borderColor: '#888888',
54 |                 borderWidth: 1
55 |             },
56 |             edge: {
57 |                 color: '#a1a1aa'
58 |             }
59 |         }
60 |     }),
61 |     ThemeProvider: ({ children }: { children: React.ReactNode }) => <div>{children}</div>
62 | }));
63 | 
64 | // AppStore 모킹
65 | vi.mock('@/store/useAppStore', () => ({
66 |     useAppStore: vi.fn((selector) => selector({
67 |         // 선택 관련 상태
68 |         selectedCardIds: [],
69 |         selectedCardId: null,
70 |         expandedCardId: null,
71 | 
72 |         // 선택 관련 액션
73 |         selectCard: vi.fn(),
74 |         selectCards: vi.fn(),
75 |         addSelectedCard: vi.fn(),
76 |         removeSelectedCard: vi.fn(),
77 |         toggleSelectedCard: vi.fn(),
78 |         clearSelectedCards: vi.fn(),
79 |         toggleExpandCard: vi.fn(),
80 | 
81 |         // 카드 데이터 상태
82 |         cards: [],
83 |         setCards: vi.fn(),
84 |         updateCard: vi.fn(),
85 | 
86 |         // 사이드바 상태
87 |         isSidebarOpen: false,
88 |         setSidebarOpen: vi.fn(),
89 |         toggleSidebar: vi.fn(),
90 | 
91 |         // 레이아웃 옵션
92 |         layoutDirection: 'auto' as const,
93 |         setLayoutDirection: vi.fn(),
94 | 
95 |         // 사이드바 너비
96 |         sidebarWidth: 300,
97 |         setSidebarWidth: vi.fn(),
98 | 
99 |         // 아이디어맵 설정
[TRUNCATED]
```

src/components/ideamap/nodes/CardNode.tsx
```
1 | /**
2 |  * 파일명: CardNode.tsx
3 |  * 목적: 보드에 표시되는 카드 노드 컴포넌트
4 |  * 역할: React Flow의 노드로 사용되는 카드 UI 컴포넌트
5 |  * 작성일: 2025-03-05
6 |  * 수정일: 2025-03-31
7 |  */
8 | 
9 | import React, { useMemo, useState, useCallback, useEffect, useRef } from 'react';
10 | import { CSSProperties } from 'react';
11 | 
12 | import { Handle, Position, NodeProps, useReactFlow, useUpdateNodeInternals } from '@xyflow/react';
13 | import { ChevronRight, ChevronUp } from 'lucide-react';
14 | import { createPortal } from 'react-dom';
15 | 
16 | import { EditCardModal } from '@/components/cards/EditCardModal';
17 | import TiptapViewer from '@/components/editor/TiptapViewer';
18 | import { useTheme } from '@/contexts/ThemeContext';
19 | import { loadDefaultIdeaMapUIConfig } from '@/lib/ideamap-ui-config';
20 | import { cn } from '@/lib/utils';
21 | import { useAppStore } from '@/store/useAppStore';
22 | 
23 | // 고유 식별자 추가 - 이 컴포넌트가 정확히 어느 파일에서 로드되었는지 확인
24 | const COMPONENT_ID = 'CardNode_from_nodes_directory';
25 | 
26 | // 디버깅용 로그 - 순환 참조 방지를 위해 NODE_TYPES 접근 제거
27 | console.log(`[${COMPONENT_ID}] 모듈이 로드됨 - 경로: @/components/ideamap/nodes/CardNode`);
28 | 
29 | // 노드 데이터 타입 정의
30 | export interface NodeData {
31 |   id: string;
32 |   title: string;
33 |   content: string;
34 |   type?: string;
35 |   width?: number;
36 |   height?: number;
37 |   color?: string;
38 |   backgroundColor?: string;
39 |   tags?: string[];
40 |   position?: {
41 |     x: number;
42 |     y: number;
43 |   };
44 |   // 추가 속성들
45 |   [key: string]: any;
46 | }
47 | 
48 | // Portal 컴포넌트 - 내부 정의
49 | const Portal: React.FC<{ children: React.ReactNode }> = ({ children }) => {
50 |   const [mounted, setMounted] = useState(false);
51 | 
52 |   useEffect(() => {
53 |     setMounted(true);
54 |     return () => setMounted(false);
55 |   }, []);
56 | 
57 |   return mounted ? createPortal(children, document.body) : null;
58 | };
59 | 
60 | // 카드 노드 컴포넌트 정의
61 | export default function CardNode({ data, isConnectable, selected, id }: NodeProps) {
62 |   const [isHovered, setIsHovered] = useState(false);
63 |   const { setNodes } = useReactFlow();
64 |   const nodeRef = useRef<HTMLDivElement>(null);
65 |   const updateNodeInternals = useUpdateNodeInternals();
66 |   const [isEditModalOpen, setIsEditModalOpen] = useState(false);
67 |   const [isActive, setIsActive] = useState(false);
68 | 
69 |   // ReactFlow 인스턴스 가져오기
70 |   const reactFlowInstance = useReactFlow();
71 | 
72 |   // 컴포넌트 초기화 로그 - 상세 정보 추가
73 |   // console.log(`[${COMPONENT_ID}] 컴포넌트 렌더링 시작:`, {
74 |   //   id: id,
75 |   //   title: data.title,
76 |   //   type: data.type,
77 |   //   expectedType: NODE_TYPES_KEYS.card,
78 |   //   isTypeValid: data.type === NODE_TYPES_KEYS.card,
[TRUNCATED]
```

src/components/ideamap/nodes/CustomEdge.test.tsx
```
1 | /**
2 |  * 파일명: CustomEdge.test.tsx
3 |  * 목적: CustomEdge 컴포넌트 테스트
4 |  * 역할: 엣지 컴포넌트의 기능 테스트
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-01
7 |  * 수정일: 2023-10-27 : 사용하지 않는 import 제거
8 |  */
9 | 
10 | import { render, screen } from '@testing-library/react';
11 | import { ReactFlowProvider, EdgeProps, Position, ConnectionLineType } from '@xyflow/react';
12 | import type * as XyflowReact from '@xyflow/react';
13 | import { describe, it, expect, vi, beforeEach } from 'vitest';
14 | 
15 | // AppStore 모킹
16 | vi.mock('@/store/useAppStore', () => ({
17 |   useAppStore: () => ({
18 |     boardSettings: {
19 |       edgeColor: '#000000',
20 |       selectedEdgeColor: '#ff0000',
21 |       strokeWidth: 2,
22 |       selectedStrokeWidth: 3,
23 |       animated: false,
24 |       markerEnd: true,
25 |       connectionLineType: 'bezier'
26 |     }
27 |   })
28 | }));
29 | 
30 | vi.mock('@xyflow/react', async (importOriginal) => {
31 |   const actual = (await importOriginal()) as typeof XyflowReact;
32 |   const getBezierPathMock = vi.fn().mockReturnValue(['M0 0 C100 0 100 100 200 100']);
33 |   const getStraightPathMock = vi.fn().mockReturnValue(['M0 0 L200 100']);
34 |   const getSmoothStepPathMock = vi.fn().mockReturnValue(['M0 0 Q100 0 100 50 Q100 100 200 100']);
35 | 
36 |   return {
37 |     ...actual,
38 |     getBezierPath: getBezierPathMock,
39 |     getStraightPath: getStraightPathMock,
40 |     getSmoothStepPath: getSmoothStepPathMock,
41 |     useStore: vi.fn(() => ({
42 |       selectedEdgeColor: '#ff0000',
43 |     })),
44 |     ReactFlowProvider: ({ children }: { children: React.ReactNode }) => <>{children}</>,
45 |     BaseEdge: ({ path, markerEnd, style, className, 'data-selected': selected, 'data-component-id': componentId }: any) => (
46 |       <g data-testid="base-edge" className={className} style={style} data-selected={selected} data-component-id={componentId}>
47 |         <path data-testid="edge-path" d={path} markerEnd={markerEnd} />
48 |       </g>
49 |     ),
50 |   };
51 | });
52 | 
53 | // CustomEdge 컴포넌트 임포트
54 | import CustomEdge from './CustomEdge';
55 | 
56 | describe('CustomEdge', () => {
57 |   const mockEdgeProps: Partial<EdgeProps> = {
58 |     id: 'test-edge-id',
59 |     source: 'source-node',
60 |     target: 'target-node',
61 |     sourceX: 100,
62 |     sourceY: 100,
63 |     targetX: 200,
64 |     targetY: 200,
65 |     sourcePosition: Position.Right,
66 |     targetPosition: Position.Left,
67 |     style: { strokeWidth: 2, stroke: '#000000' },
68 |     markerEnd: 'test-marker',
69 |     selected: false
70 |   };
71 | 
72 |   let getBezierPathMock: ReturnType<typeof vi.fn>;
73 |   let getStraightPathMock: ReturnType<typeof vi.fn>;
74 |   let getSmoothStepPathMock: ReturnType<typeof vi.fn>;
75 | 
76 |   beforeEach(async () => {
77 |     const xyflow = vi.mocked(await import('@xyflow/react'));
78 |     getBezierPathMock = xyflow.getBezierPath;
79 |     getStraightPathMock = xyflow.getStraightPath;
[TRUNCATED]
```

src/components/ideamap/nodes/CustomEdge.tsx
```
1 | /**
2 |  * 파일명: CustomEdge.tsx
3 |  * 목적: React Flow에서 사용할 커스텀 엣지 컴포넌트
4 |  * 역할: 노드 간 연결선을 시각화하는 컴포넌트
5 |  * 작성일: 2025-03-08
6 |  * 수정일: 2025-03-31
7 |  * 수정일: 2023-10-27 : 사용하지 않는 import/변수 제거 및 any 타입 개선
8 |  */
9 | 
10 | import React, { useMemo } from 'react';
11 | 
12 | import { BaseEdge, EdgeProps, getBezierPath, getSmoothStepPath, getStraightPath, ConnectionLineType } from '@xyflow/react';
13 | 
14 | import { useAppStore } from '@/store/useAppStore';
15 | 
16 | // 고유 식별자 추가 - 이 컴포넌트가 정확히 어느 파일에서 로드되었는지 확인
17 | const COMPONENT_ID = 'CustomEdge_from_nodes_directory';
18 | 
19 | // 디버깅용 로그 - 순환 참조 방지를 위해 EDGE_TYPES 접근 제거
20 | console.log(`[${COMPONENT_ID}] 모듈이 로드됨 - 경로: @/components/board/nodes/CustomEdge`);
21 | 
22 | // 확장된 엣지 Props 인터페이스
23 | interface CustomEdgeProps extends EdgeProps {
24 |   type?: string;
25 |   animated?: boolean;
26 |   data?: {
27 |     edgeType?: ConnectionLineType;
28 |     settings?: Record<string, unknown>;
29 |   };
30 | }
31 | 
32 | /**
33 |  * 커스텀 엣지 컴포넌트
34 |  * - ReactFlow의 기본 동작을 최대한 활용하고, 최소한의 조정만 적용
35 |  */
36 | // 컴포넌트 사용 시점 디버깅
37 | console.log('[CustomEdge] 컴포넌트 정의 전: 함수 형태의 컴포넌트 생성');
38 | 
39 | function CustomEdge({
40 |   sourceX,
41 |   sourceY,
42 |   targetX,
43 |   targetY,
44 |   sourcePosition,
45 |   targetPosition,
46 |   style = {},
47 |   markerEnd,
48 |   selected,
49 |   animated,
50 |   data,
51 |   ...restProps
52 | }: CustomEdgeProps) {
53 |   // Zustand 스토어에서 ideaMapSettings 가져오기
54 |   const { ideaMapSettings } = useAppStore();
55 | 
56 |   // 글로벌 설정과 로컬 설정 결합
57 |   const effectiveSettings = useMemo(() => {
58 |     // 로컬 설정이 있으면 우선적으로 사용, 없으면 글로벌 설정 사용
59 |     const localSettings = data?.settings;
60 |     return localSettings ? { ...ideaMapSettings, ...localSettings } : ideaMapSettings;
61 |   }, [ideaMapSettings, data?.settings]);
62 | 
63 |   // 엣지 연결 좌표 계산 (useMemo로 최적화)
64 |   const edgeParams = useMemo(() => ({
65 |     sourceX,
66 |     sourceY,
67 |     sourcePosition,
68 |     targetX,
69 |     targetY,
70 |     targetPosition,
71 |   }), [sourceX, sourceY, sourcePosition, targetX, targetY, targetPosition]);
72 | 
73 |   // 엣지 타입 결정: data.edgeType > ideaMapSettings.connectionLineType > 기본값
74 |   const effectiveEdgeType = useMemo(() => {
75 |     // data.edgeType이 있으면 우선 사용
76 |     if (data?.edgeType) {
77 |       return data.edgeType;
78 |     }
79 |     // 글로벌 설정의 connectionLineType 사용
80 |     return effectiveSettings.connectionLineType || 'bezier';
81 |   }, [data?.edgeType, effectiveSettings.connectionLineType]);
82 | 
83 |   // 엣지 패스 계산 (연결선 타입에 따라)
84 |   const [edgePath] = useMemo(() => {
85 |     // 타입에 따라 적절한 경로 생성 함수 사용
[TRUNCATED]
```

src/components/ideamap/nodes/NodeInspect.tsx
```
1 | /**
2 |  * 파일명: NodeInspect.tsx
3 |  * 목적: React Flow 노드 검사 컴포넌트
4 |  * 역할: 노드 정보를 표시해주는 디버깅용 컴포넌트
5 |  * 작성일: 2025-03-28
6 |  */
7 | 
8 | import { useEffect, useState } from 'react';
9 | 
10 | import { useReactFlow, NodeProps, NodeToolbar, Position } from '@xyflow/react';
11 | 
12 | /**
13 |  * NodeInspect 컴포넌트는 각 노드에 추가되어 노드의 데이터를 표시합니다.
14 |  * 실시간으로 노드 상태를 반영합니다.
15 |  */
16 | export default function NodeInspect(props: NodeProps) {
17 |   const { data, id, type } = props;
18 |   const { getNode } = useReactFlow();
19 |   // 실시간 상태 업데이트를 위한 상태
20 |   const [nodeState, setNodeState] = useState({ selected: false });
21 |   const [isVisible, setIsVisible] = useState(false);
22 |   
23 |   // 렌더링 전에 isVisible 상태를 설정
24 |   useEffect(() => {
25 |     setIsVisible(!!data?.isInspected);
26 |   }, [data?.isInspected]);
27 | 
28 |   // 실시간 노드 상태 업데이트
29 |   useEffect(() => {
30 |     // 노드 상태 업데이트 함수
31 |     const updateNodeState = () => {
32 |       const currentNode = getNode(id);
33 |       if (currentNode) {
34 |         setNodeState({
35 |           selected: !!currentNode.selected,
36 |         });
37 |       }
38 |     };
39 | 
40 |     // 초기 상태 설정
41 |     updateNodeState();
42 | 
43 |     // 주기적으로 노드 상태 업데이트 (실시간성 보장)
44 |     const intervalId = setInterval(updateNodeState, 100);
45 | 
46 |     return () => {
47 |       clearInterval(intervalId);
48 |     };
49 |   }, [id, getNode]);
50 | 
51 |   // 핸들 위치 정보
52 |   const handleInfo = {
53 |     leftTop: { position: Position.Left, top: '0%' },
54 |     leftBottom: { position: Position.Left, top: '100%' },
55 |     rightTop: { position: Position.Right, top: '0%' },
56 |     rightBottom: { position: Position.Right, top: '100%' },
57 |   };
58 | 
59 |   if (!isVisible) return null;
60 | 
61 |   return (
62 |     <NodeToolbar 
63 |       position={Position.Bottom}
64 |       className="nodrag bg-card shadow-md rounded p-2 text-xs max-w-xs" 
65 |       isVisible={true}
66 |     >
67 |       <div className="space-y-1">
68 |         <div><span className="font-medium">제목:</span> {data?.title || data?.label || '제목 없음'}</div>
69 |         <div><span className="font-medium">ID:</span> {id}</div>
70 |         <div><span className="font-medium">타입:</span> {type || '기본'}</div>
71 |         <div><span className="font-medium">선택됨:</span> {nodeState.selected ? '예' : '아니오'}</div>
72 |       </div>
73 |     </NodeToolbar>
74 |   );
75 | } 
```

src/components/ideamap/nodes/NodeInspector.tsx
```
1 | /**
2 |  * 파일명: NodeInspector.tsx
3 |  * 목적: 노드 상세 정보를 모달로 표시하는 컴포넌트
4 |  * 역할: 선택된 노드의 정보를 검사하고 표시
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-04-15
7 |  */
8 | 
9 | import { useEffect } from 'react';
10 | 
11 | import { Node } from '@xyflow/react';
12 | 
13 | import TiptapViewer from '@/components/editor/TiptapViewer';
14 | import { Badge } from '@/components/ui/badge';
15 | import { Modal } from '@/components/ui/modal';
16 | import { useNodeStore } from '@/store/useNodeStore';
17 | 
18 | interface NodeInspectorProps {
19 |   nodes: Node[];
20 | }
21 | 
22 | /**
23 |  * NodeInspector: 노드의 상세 정보를 모달로 표시하는 컴포넌트
24 |  * @param {NodeInspectorProps} props - 컴포넌트 속성
25 |  * @returns {JSX.Element} 노드 인스펙터 컴포넌트
26 |  */
27 | export function NodeInspector({ nodes }: NodeInspectorProps) {
28 |   const { inspectorOpen, inspectedNode, setInspectorOpen, setInspectedNode } = useNodeStore();
29 | 
30 |   // 모달이 닫힐 때 inspectedNode 초기화
31 |   const handleCloseModal = () => {
32 |     setInspectorOpen(false);
33 |   };
34 | 
35 |   // 노드 정보가 없거나 모달이 닫혀있으면 열린 상태로 렌더링하지만 보이지 않게 함
36 |   const shouldShowContent = inspectorOpen && inspectedNode;
37 | 
38 |   return (
39 |     <Modal.Root open={Boolean(shouldShowContent)} onOpenChange={handleCloseModal}>
40 |       <Modal.Content>
41 |         {shouldShowContent && (
42 |           <>
43 |             <Modal.Title>
44 |               {inspectedNode.data?.title || '제목 없음'}
45 |             </Modal.Title>
46 | 
47 |             <div className="py-4">
48 |               {/* 노드 ID 정보 */}
49 |               <div className="mb-4">
50 |                 <h3 className="text-sm font-semibold mb-1">ID</h3>
51 |                 <code className="bg-muted p-1 rounded text-xs">{inspectedNode.id}</code>
52 |               </div>
53 | 
54 |               {/* 노드 내용 */}
55 |               {inspectedNode.data?.content && (
56 |                 <div className="mb-4">
57 |                   <h3 className="text-sm font-semibold mb-1">내용</h3>
58 |                   <div className="bg-muted p-2 rounded">
59 |                     <TiptapViewer content={inspectedNode.data.content} />
60 |                   </div>
61 |                 </div>
62 |               )}
63 | 
64 |               {/* 노드 태그 */}
65 |               {inspectedNode.data?.tags && inspectedNode.data.tags.length > 0 && (
66 |                 <div className="mb-4">
67 |                   <h3 className="text-sm font-semibold mb-1">태그</h3>
68 |                   <div className="flex flex-wrap gap-1">
69 |                     {inspectedNode.data.tags.map((tag: string) => (
70 |                       <Badge key={tag} data-testid="node-tag">{tag}</Badge>
71 |                     ))}
72 |                   </div>
73 |                 </div>
74 |               )}
75 | 
76 |               {/* 노드 위치 정보 */}
77 |               <div className="mb-4">
78 |                 <h3 className="text-sm font-semibold mb-1">위치</h3>
[TRUNCATED]
```

src/components/ideamap/types/ideamap-types.ts
```
1 | /**
2 |  * 파일명: ideamap-types.ts
3 |  * 목적: IdeaMapComponent 및 관련 컴포넌트에서 사용되는 타입 정의
4 |  * 역할: 타입 정의를 중앙화하여 코드 중복을 방지하고 타입 안정성 제공
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2023-10-27 : ConnectionLineType 타입 추가 및 RefObject 타입 문제 해결
7 |  */
8 | 
9 | import React from 'react';
10 | 
11 | import { 
12 |   Node, 
13 |   Edge as ReactFlowEdge, 
14 |   Connection, 
15 |   XYPosition, 
16 |   NodeChange, 
17 |   EdgeChange, 
18 |   Position, 
19 |   ConnectionMode,
20 |   Viewport,
21 |   MarkerType,
22 |   ConnectionLineType
23 | } from '@xyflow/react';
24 | 
25 | // lib/ideamap-utils.ts에서 정의된 IdeaMapSettings 타입 가져오기
26 | import { IdeaMapSettings as OriginalIdeaMapSettings } from '@/lib/ideamap-utils';
27 | 
28 | /**
29 |  * IdeaMapComponent의 Props 인터페이스
30 |  * @interface IdeaMapComponentProps
31 |  */
32 | export interface IdeaMapComponentProps {
33 |   /** 카드 선택 시 호출될 콜백 함수 */
34 |   onSelectCard?: (cardId: string | null) => void;
35 |   /** 컴포넌트에 적용할 추가 CSS 클래스 */
36 |   className?: string;
37 |   /** 컨트롤 표시 여부 */
38 |   showControls?: boolean;
39 | }
40 | 
41 | /**
42 |  * 카드(노드) 데이터 인터페이스
43 |  * @interface CardData
44 |  */
45 | export interface CardData {
46 |   id: string;
47 |   title: string;
48 |   content: string | null;
49 |   tags?: string[];
50 |   cardTags?: Array<{tag: {name: string}}>;
51 |   [key: string]: any;
52 | }
53 | 
54 | /**
55 |  * lib/ideamap-utils.ts에서 가져온 IdeaMapSettings 타입을 재내보냅니다.
56 |  * 이를 통해 IdeaMap 컴포넌트에서 사용하는 타입이 lib/ideamap-utils.ts의 타입과 일치하게 됩니다.
57 |  */
58 | export type IdeaMapSettings = OriginalIdeaMapSettings;
59 | 
60 | /**
61 |  * 안전한 HTMLElement RefObject 타입
62 |  * - TypeScript 타입 체크를 위한 RefObject 타입 확장
63 |  */
64 | export type SafeRef<T extends HTMLElement = HTMLDivElement> = React.RefObject<T>;
65 | 
66 | /**
67 |  * 아이디어맵 노드 타입
68 |  * @type IdeaMapNode
69 |  */
70 | export type IdeaMapNode = Node<CardData>;
71 | 
72 | /**
73 |  * 아이디어맵 엣지 타입
74 |  * @type IdeaMapEdge
75 |  */
76 | export type IdeaMapEdge = ReactFlowEdge;
77 | 
78 | /**
79 |  * Edge 배열 타입 - 타입 호환성을 위한 타입 정의
80 |  */
81 | export type Edges = ReactFlowEdge[];
82 | 
83 | /**
84 |  * Edge 변경 핸들러 타입
85 |  */
86 | export type EdgeSetFunction = (edges: ReactFlowEdge[] | ((currentEdges: ReactFlowEdge[]) => ReactFlowEdge[])) => void;
87 | 
88 | /**
89 |  * 엣지 드롭 데이터 인터페이스
90 |  * @interface EdgeDropData
91 |  */
92 | export interface EdgeDropData {
93 |   position: XYPosition;
94 |   connectingNodeId: string;
95 |   handleType: 'source' | 'target';
96 | }
97 | 
[TRUNCATED]
```

src/components/ideamap/utils/ideamap-constants.ts
```
1 | /**
2 |  * 파일명: constants.ts
3 |  * 목적: 보드 컴포넌트 관련 상수 정의
4 |  * 역할: 보드 컴포넌트에서 사용되는 모든 상수값 제공
5 |  * 작성일: 2025-03-28
6 |  * 수정일: 2025-03-30
7 |  */
8 | 
9 | import { ConnectionLineType, Position } from '@xyflow/react';
10 | 
11 | // 레이아웃 방향
12 | export const LAYOUT_DIRECTION = {
13 |   HORIZONTAL: 'LR',
14 |   VERTICAL: 'TB'
15 | };
16 | 
17 | // 노드 타입
18 | export const NODE_TYPES = {
19 |   CARD: 'card'
20 | };
21 | 
22 | // 엣지 타입
23 | export const EDGE_TYPES = {
24 |   CUSTOM: 'custom'
25 | };
26 | 
27 | // 핸들 위치 정보
28 | export const HANDLE_POSITIONS = {
29 |   TOP: Position.Top,
30 |   RIGHT: Position.Right,
31 |   BOTTOM: Position.Bottom,
32 |   LEFT: Position.Left
33 | };
34 | 
35 | // 연결선 타입
36 | export const CONNECTION_LINE_TYPES = {
37 |   BEZIER: ConnectionLineType.Bezier,
38 |   STEP: ConnectionLineType.Step,
39 |   SMOOTHSTEP: ConnectionLineType.SmoothStep,
40 |   STRAIGHT: ConnectionLineType.Straight
41 | };
42 | 
43 | // 기본 노드 크기
44 | export const DEFAULT_NODE_DIMENSIONS = {
45 |   WIDTH: 300,
46 |   MIN_HEIGHT: 100
47 | };
48 | 
49 | // 자동 저장 딜레이 (밀리초)
50 | export const AUTO_SAVE_DELAY = 1000;
51 | 
52 | // 노드 기본 간격 값
53 | export const NODE_SPACING = {
54 |   HORIZONTAL: 100,
55 |   VERTICAL: 80
56 | };
57 | 
58 | // 새 노드 기본 데이터
59 | export const DEFAULT_NEW_CARD = {
60 |   title: '새 카드',
61 |   content: '',
62 |   tags: []
63 | };
64 | 
65 | // 보드 줌 설정
66 | export const ZOOM_SETTINGS = {
67 |   MIN: 0.5,
68 |   MAX: 2,
69 |   STEP: 0.1
70 | };
71 | 
72 | // 툴팁 표시 지연 (밀리초)
73 | export const TOOLTIP_DELAY = 500; 
```

src/components/ideamap/utils/ideamap-graphUtils.ts
```
1 | /**
2 |  * 파일명: graphUtils.ts
3 |  * 목적: 그래프 관련 순수 함수 모음
4 |  * 역할: 노드, 엣지 처리를 위한 순수 유틸리티 함수 제공
5 |  * 작성일: 2025-03-28
6 |  */
7 | 
8 | import { Node, Edge, XYPosition, Position, MarkerType } from '@xyflow/react';
9 | 
10 | import { IDEAMAP_LAYOUT_STORAGE_KEY, IDEAMAP_EDGES_STORAGE_KEY } from '@/lib/ideamap-constants';
11 | import { IdeaMapSettings } from '@/lib/ideamap-utils';
12 | 
13 | /**
14 |  * 레이아웃을 로컬 스토리지에 저장
15 |  * @param nodes 저장할 노드 배열
16 |  * @returns 성공 여부
17 |  */
18 | export const saveLayout = (nodes: Node[]): boolean => {
19 |   try {
20 |     // 노드 ID와 위치만 저장
21 |     const nodePositions = nodes.reduce((acc: Record<string, { position: XYPosition }>, node: Node) => {
22 |       acc[node.id] = { position: node.position };
23 |       return acc;
24 |     }, {});
25 |     
26 |     localStorage.setItem(IDEAMAP_LAYOUT_STORAGE_KEY, JSON.stringify(nodePositions));
27 |     return true;
28 |   } catch (err) {
29 |     console.error('레이아웃 저장 실패:', err);
30 |     return false;
31 |   }
32 | };
33 | 
34 | /**
35 |  * 엣지를 로컬 스토리지에 저장
36 |  * @param edges 저장할 엣지 배열
37 |  * @returns 성공 여부
38 |  */
39 | export const saveEdges = (edges: Edge[]): boolean => {
40 |   try {
41 |     localStorage.setItem(IDEAMAP_EDGES_STORAGE_KEY, JSON.stringify(edges));
42 |     return true;
43 |   } catch (err) {
44 |     console.error('엣지 저장 실패:', err);
45 |     return false;
46 |   }
47 | };
48 | 
49 | /**
50 |  * 모든 레이아웃 데이터 저장 (노드와 엣지)
51 |  * @param nodes 저장할 노드 배열
52 |  * @param edges 저장할 엣지 배열
53 |  * @returns 성공 여부
54 |  */
55 | export const saveAllLayoutData = (nodes: Node[], edges: Edge[]): boolean => {
56 |   const layoutSaved = saveLayout(nodes);
57 |   const edgesSaved = saveEdges(edges);
58 |   
59 |   return layoutSaved && edgesSaved;
60 | };
61 | 
62 | /**
63 |  * 삭제된 노드를 로컬 스토리지에서 제거
64 |  * @param deletedNodeIds 삭제된 노드 ID 배열
65 |  */
66 | export const removeDeletedNodesFromStorage = (deletedNodeIds: string[]): void => {
67 |   try {
68 |     // 노드 위치 정보 처리
69 |     const savedPositionsStr = localStorage.getItem(IDEAMAP_LAYOUT_STORAGE_KEY);
70 |     if (savedPositionsStr) {
71 |       const savedPositions = JSON.parse(savedPositionsStr);
72 |       
73 |       // 삭제된 노드 ID를 제외한 새 위치 정보 객체 생성
74 |       const updatedPositions = Object.fromEntries(
75 |         Object.entries(savedPositions).filter(([id]) => !deletedNodeIds.includes(id))
76 |       );
77 |       
78 |       // 업데이트된 위치 정보 저장
79 |       localStorage.setItem(IDEAMAP_LAYOUT_STORAGE_KEY, JSON.stringify(updatedPositions));
80 |       
81 |       // 엣지 정보도 업데이트 (삭제된 노드와 연결된 엣지 제거)
[TRUNCATED]
```

src/tests/msw/handlers/logs.ts
```
1 | /**
2 |  * 파일명: logs.ts
3 |  * 목적: 로그 뷰어 테스트를 위한 목업 데이터
4 |  * 역할: 테스트에서 사용할 로그 데이터 제공
5 |  * 작성일: 2025-04-01
6 |  */
7 | 
8 | export interface Log {
9 |   timestamp: string
10 |   module: string
11 |   level: string
12 |   message: string
13 |   sessionId: string
14 |   data?: Record<string, unknown>
15 | }
16 | 
17 | export const mockModules = ['auth', 'database', 'api', 'system'] as const
18 | 
19 | export const mockSessionIds = [
20 |   'sess_123456',
21 |   'sess_789012',
22 |   'sess_345678',
23 |   'sess_901234'
24 | ]
25 | 
26 | export const mockLogs: Log[] = [
27 |   {
28 |     timestamp: '2024-03-31T10:00:00Z',
29 |     module: 'auth',
30 |     level: 'info',
31 |     message: '사용자 로그인 성공',
32 |     sessionId: 'sess_123456',
33 |     data: {
34 |       userId: 'user_123',
35 |       loginMethod: 'password'
36 |     }
37 |   },
38 |   {
39 |     timestamp: '2024-03-31T10:01:00Z',
40 |     module: 'database',
41 |     level: 'error',
42 |     message: '데이터베이스 연결 실패',
43 |     sessionId: 'sess_789012',
44 |     data: {
45 |       errorCode: 'DB_001',
46 |       retryCount: 3
47 |     }
48 |   },
49 |   {
50 |     timestamp: '2024-03-31T10:02:00Z',
51 |     module: 'api',
52 |     level: 'warn',
53 |     message: 'API 응답 지연',
54 |     sessionId: 'sess_345678',
55 |     data: {
56 |       endpoint: '/api/users',
57 |       responseTime: 5000
58 |     }
59 |   },
60 |   {
61 |     timestamp: '2024-03-31T10:03:00Z',
62 |     module: 'system',
63 |     level: 'debug',
64 |     message: '시스템 상태 점검',
65 |     sessionId: 'sess_901234',
66 |     data: {
67 |       cpuUsage: 45,
68 |       memoryUsage: 60
69 |     }
70 |   }
71 | ] 
```

src/app/api/auth/status/route.ts
```
1 | /**
2 |  * 파일명: route.ts
3 |  * 목적: 로그인 상태 확인 API
4 |  * 역할: 현재 로그인 상태와 사용자 정보 반환
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2024-05-21 : import 순서 수정
7 |  * 수정일: 2024-05-22 : import 순서 오류 수정
8 |  */
9 | 
10 | import { NextResponse } from 'next/server'
11 | 
12 | import { createClient } from '@/lib/supabase/server'
13 | 
14 | export async function GET() {
15 |   try {
16 |     const supabase = await createClient()
17 |     const { data, error } = await supabase.auth.getUser()
18 |     
19 |     if (error) {
20 |       return NextResponse.json({ 
21 |         loggedIn: false, 
22 |         error: error.message 
23 |       })
24 |     }
25 |     
26 |     return NextResponse.json({ 
27 |       loggedIn: !!data?.user,
28 |       user: data.user ? {
29 |         id: data.user.id,
30 |         email: data.user.email,
31 |         provider: data.user.app_metadata?.provider || 'unknown'
32 |       } : null
33 |     })
34 |   } catch (error) {
35 |     console.error('인증 상태 확인 중 오류:', error)
36 |     return NextResponse.json({ 
37 |       loggedIn: false, 
38 |       error: '인증 상태 확인 중 오류가 발생했습니다' 
39 |     }, { status: 500 })
40 |   }
41 | } 
```

src/app/api/cards/[id]/route.ts
```
1 | /**
2 |  * 파일명: src/app/api/cards/[id]/route.ts
3 |  * 목적: 개별 카드 API 엔드포인트
4 |  * 역할: 카드 조회, 수정, 삭제 기능 제공
5 |  * 작성일: 2024-05-21
6 |  * 수정일: 2025-04-16 : params를 await로 비동기적으로 접근하도록 수정 (Next.js 15 규칙에 맞게)
7 |  */
8 | 
9 | import { NextRequest, NextResponse } from 'next/server';
10 | 
11 | import { PrismaClient } from '@prisma/client';
12 | import { z } from 'zod';
13 | 
14 | import prisma from '@/lib/prisma';
15 | 
16 | // 카드 수정 스키마
17 | const updateCardSchema = z.object({
18 |   title: z.string().min(1, '제목은 필수입니다.').optional(),
19 |   content: z.string().optional(),
20 |   userId: z.string().optional(),
21 |   tags: z.array(z.string()).optional(),
22 | });
23 | 
24 | // 카드 내용 부분 업데이트 스키마
25 | const patchCardSchema = z.object({
26 |   content: z.string().optional(),
27 | });
28 | 
29 | // 개별 카드 조회 API
30 | export async function GET(
31 |   request: NextRequest,
32 |   context: { params: { id: string } }
33 | ) {
34 |   try {
35 |     // params 객체를 비동기적으로 접근
36 |     const params = await context.params;
37 |     const { id } = params;
38 |     console.log(`카드 상세 조회 요청: ID=${id}`);
39 |     
40 |     // 카드 조회 (태그 정보 포함)
41 |     const card = await prisma.card.findUnique({
42 |       where: { id },
43 |       include: {
44 |         user: {
45 |           select: {
46 |             id: true,
47 |             name: true
48 |           }
49 |         },
50 |         cardTags: {
51 |           include: {
52 |             tag: true
53 |           }
54 |         }
55 |       }
56 |     });
57 |     
58 |     if (!card) {
59 |       console.log(`카드 찾을 수 없음: ID=${id}`);
60 |       return NextResponse.json(
61 |         { error: '카드를 찾을 수 없습니다.' },
62 |         { status: 404 }
63 |       );
64 |     }
65 |     
66 |     console.log(`카드 조회 성공: ID=${id}`);
67 |     return NextResponse.json(card);
68 |   } catch (error) {
69 |     // 오류 로깅 부분도 안전하게 접근
70 |     const params = await context.params;
71 |     console.error(`카드 조회 오류 (ID=${params?.id || '알 수 없음'}):`, error);
72 |     return NextResponse.json(
73 |       { error: '카드를 조회하는 중 오류가 발생했습니다.' },
74 |       { status: 500 }
75 |     );
76 |   }
77 | }
78 | 
79 | // 카드 수정 API
80 | export async function PUT(
81 |   request: NextRequest,
82 |   context: { params: { id: string } }
83 | ) {
84 |   try {
85 |     // params 객체를 비동기적으로 접근
86 |     const params = await context.params;
87 |     const { id } = params;
88 |     const body = await request.json();
89 |     
[TRUNCATED]
```

src/app/api/tags/[id]/route.ts
```
1 | /**
2 |  * 파일명: src/app/api/tags/[id]/route.ts
3 |  * 목적: 개별 태그 API 엔드포인트
4 |  * 역할: 태그 조회, 수정, 삭제 기능 제공
5 |  * 작성일: 2024-05-22
6 |  */
7 | 
8 | import { NextRequest, NextResponse } from 'next/server';
9 | 
10 | import { z } from 'zod';
11 | 
12 | import prisma from '@/lib/prisma';
13 | 
14 | // 태그 수정 스키마
15 | const updateTagSchema = z.object({
16 |   name: z.string().min(1, '태그 이름은 필수입니다.'),
17 |   color: z.string().optional(),
18 | });
19 | 
20 | // 개별 태그 조회 API
21 | export async function GET(
22 |   request: NextRequest,
23 |   context: { params: { id: string } }
24 | ) {
25 |   try {
26 |     const id = context.params.id;
27 |     
28 |     // 태그 조회
29 |     const tag = await prisma.tag.findUnique({
30 |       where: { id }
31 |     });
32 |     
33 |     if (!tag) {
34 |       return NextResponse.json(
35 |         { error: '태그를 찾을 수 없습니다.' },
36 |         { status: 404 }
37 |       );
38 |     }
39 |     
40 |     return NextResponse.json(tag);
41 |   } catch (error) {
42 |     console.error('태그 조회 오류:', error);
43 |     return NextResponse.json(
44 |       { error: '태그를 조회하는 중 오류가 발생했습니다.' },
45 |       { status: 500 }
46 |     );
47 |   }
48 | }
49 | 
50 | // 태그 수정 API
51 | export async function PUT(
52 |   request: NextRequest,
53 |   context: { params: { id: string } }
54 | ) {
55 |   try {
56 |     const id = context.params.id;
57 |     const body = await request.json();
58 |     
59 |     // 데이터 유효성 검사
60 |     const validation = updateTagSchema.safeParse(body);
61 |     if (!validation.success) {
62 |       return NextResponse.json(
63 |         { error: '유효하지 않은 데이터입니다.', details: validation.error.format() },
64 |         { status: 400 }
65 |       );
66 |     }
67 |     
68 |     // 태그 존재 여부 확인
69 |     const existingTag = await prisma.tag.findUnique({
70 |       where: { id }
71 |     });
72 |     
73 |     if (!existingTag) {
74 |       return NextResponse.json(
75 |         { error: '태그를 찾을 수 없습니다.' },
76 |         { status: 404 }
77 |       );
78 |     }
79 |     
80 |     // 같은 이름의 태그가 있는지 확인 (다른 ID)
81 |     const duplicateTag = await prisma.tag.findFirst({
82 |       where: {
83 |         name: validation.data.name,
84 |         id: { not: id }
85 |       }
86 |     });
87 |     
88 |     if (duplicateTag) {
89 |       return NextResponse.json(
90 |         { error: '이미 같은 이름의 태그가 존재합니다.' },
91 |         { status: 400 }
92 |       );
93 |     }
94 |     
95 |     // 태그 수정
96 |     const updatedTag = await prisma.tag.update({
97 |       where: { id },
98 |       data: validation.data
99 |     });
[TRUNCATED]
```

src/app/api/logs/view/route.ts
```
1 | /**
2 |  * 파일명: route.ts
3 |  * 목적: 저장된 로그를 확인할 수 있는 API 엔드포인트
4 |  * 역할: 서버에 저장된 로그를 조회하고 필터링하여 제공
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-09
7 |  * 수정일: 2024-05-28 : module 변수명을 logModule로 변경하여 Next.js 오류 해결
8 |  * 수정일: 2024-05-28 : any 타입을 구체적인 타입으로 변경
9 |  */
10 | 
11 | import fs from 'fs';
12 | import path from 'path';
13 | 
14 | import { NextRequest, NextResponse } from 'next/server';
15 | 
16 | import { createClient } from '@/lib/supabase/server';
17 | 
18 | // 로그 항목 인터페이스 정의
19 | interface LogEntry {
20 |   module: string;
21 |   level: string;
22 |   message: string;
23 |   timestamp: string;
24 |   sessionId?: string;
25 |   details?: Record<string, unknown>;
26 | }
27 | 
28 | // 로그 파일 경로
29 | const LOG_DIR = process.env.LOG_DIR || 'logs';
30 | const LOG_FILE = path.join(process.cwd(), LOG_DIR, 'client-logs.json');
31 | 
32 | /**
33 |  * 로그 조회 API 핸들러
34 |  */
35 | export async function GET(request: NextRequest) {
36 |   try {
37 |     // 인증 확인 (관리자만 접근 가능하도록 설정)
38 |     const supabase = await createClient();
39 |     const { data: sessionData } = await supabase.auth.getSession();
40 |     
41 |     // 개발 환경이 아니고 인증되지 않은 경우 접근 거부
42 |     if (process.env.NODE_ENV !== 'development' && !sessionData.session) {
43 |       return NextResponse.json(
44 |         { error: '인증이 필요합니다.' },
45 |         { status: 401 }
46 |       );
47 |     }
48 |     
49 |     // 로그 파일이 존재하지 않는 경우
50 |     if (!fs.existsSync(LOG_FILE)) {
51 |       return NextResponse.json(
52 |         { error: '로그 파일이 존재하지 않습니다.' },
53 |         { status: 404 }
54 |       );
55 |     }
56 |     
57 |     // 로그 파일 읽기
58 |     const fileContent = fs.readFileSync(LOG_FILE, 'utf-8');
59 |     const logs = JSON.parse(fileContent) as LogEntry[];
60 |     
61 |     // URL 파라미터로 필터링
62 |     const searchParams = request.nextUrl.searchParams;
63 |     const logModule = searchParams.get('module');
64 |     const level = searchParams.get('level');
65 |     const limit = parseInt(searchParams.get('limit') || '100', 10);
66 |     const sessionId = searchParams.get('sessionId');
67 |     
68 |     // 필터링 적용
69 |     let filteredLogs = logs;
70 |     
71 |     if (logModule) {
72 |       filteredLogs = filteredLogs.filter((log: LogEntry) => log.module === logModule);
73 |     }
74 |     
75 |     if (level) {
76 |       filteredLogs = filteredLogs.filter((log: LogEntry) => log.level === level);
77 |     }
78 |     
79 |     if (sessionId) {
80 |       filteredLogs = filteredLogs.filter((log: LogEntry) => log.sessionId === sessionId);
[TRUNCATED]
```

src/app/api/user/[id]/route.ts
```
1 | /**
2 |  * 파일명: ./src/app/api/user/[id]/route.ts
3 |  * 목적: 사용자 정보 조회 API 엔드포인트
4 |  * 역할: 사용자 ID로 사용자 정보를 조회하고 응답을 반환
5 |  * 작성일: 2024-05-29
6 |  */
7 | 
8 | import { NextResponse } from 'next/server';
9 | 
10 | import prisma from '@/lib/prisma';
11 | 
12 | export async function GET(
13 |   request: Request,
14 |   { params }: { params: { id: string } }
15 | ) {
16 |   try {
17 |     // Next.js 15에서는 params가 Promise이므로 await 사용
18 |     const paramsResolved = await params;
19 |     const id = paramsResolved.id;
20 |     
21 |     if (!id) {
22 |       return NextResponse.json(
23 |         { error: '사용자 ID가 필요합니다.' },
24 |         { status: 400 }
25 |       );
26 |     }
27 |     
28 |     try {
29 |       // 사용자 조회
30 |       const user = await prisma.user.findUnique({
31 |         where: { id },
32 |       });
33 |       
34 |       if (!user) {
35 |         return NextResponse.json(
36 |           { error: '사용자를 찾을 수 없습니다.' },
37 |           { status: 404 }
38 |         );
39 |       }
40 |       
41 |       return NextResponse.json({ user });
42 |     } catch (dbError: Error | unknown) {
43 |       console.error('DB 조회 오류:', dbError);
44 |       
45 |       // DB 오류가 발생하면 더미 사용자 데이터 반환
46 |       // 실제 환경에서는 적절한 오류 처리 필요
47 |       return NextResponse.json({
48 |         user: {
49 |           id,
50 |           email: 'user@example.com',
51 |           name: '사용자',
52 |           createdAt: new Date().toISOString(),
53 |           updatedAt: new Date().toISOString(),
54 |         }
55 |       });
56 |     }
57 |   } catch (error: Error | unknown) {
58 |     console.error('사용자 조회 API 오류:', error);
59 |     const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류';
60 |     return NextResponse.json(
61 |       { error: `사용자 조회 실패: ${errorMessage}` },
62 |       { status: 500 }
63 |     );
64 |   }
65 | } 
```

src/app/api/user/register/route.ts
```
1 | /**
2 |  * 파일명: ./src/app/api/user/register/route.ts
3 |  * 목적: 사용자 등록 API 엔드포인트
4 |  * 역할: 새로운 사용자를 등록하거나 기존 사용자를 확인하는 API
5 |  * 작성일: 2024-05-29
6 |  */
7 | 
8 | import { NextResponse } from 'next/server';
9 | 
10 | import prisma from '@/lib/prisma';
11 | 
12 | export async function POST(request: Request) {
13 |   try {
14 |     const body = await request.json();
15 |     const { id, email, name } = body;
16 |     
17 |     // 필수 필드 확인
18 |     if (!id || !email) {
19 |       return NextResponse.json(
20 |         { error: '사용자 ID와 이메일은 필수입니다.' },
21 |         { status: 400 }
22 |       );
23 |     }
24 |     
25 |     try {
26 |       // 이미 등록된 사용자인지 확인
27 |       const existingUser = await prisma.user.findUnique({
28 |         where: { id },
29 |       });
30 |       
31 |       if (existingUser) {
32 |         // 이미 존재하는 사용자이면 업데이트 (필요시)
33 |         console.log('기존 사용자 확인:', existingUser.email);
34 |         return NextResponse.json({ message: '기존 사용자 확인됨', user: existingUser });
35 |       }
36 |       
37 |       // 새 사용자 생성
38 |       const newUser = await prisma.user.create({
39 |         data: {
40 |           id,
41 |           email,
42 |           name: name || email.split('@')[0],
43 |         },
44 |       });
45 |       
46 |       console.log('새 사용자 생성됨:', newUser.email);
47 |       
48 |       return NextResponse.json({ message: '사용자 등록 성공', user: newUser });
49 |     } catch (dbError: Error | unknown) {
50 |       console.error('데이터베이스 오류:', dbError);
51 |       
52 |       // 데이터베이스 연결 오류 시 더미 데이터 반환
53 |       const dummyUser = {
54 |         id,
55 |         email,
56 |         name: name || email.split('@')[0],
57 |         createdAt: new Date().toISOString(),
58 |         updatedAt: new Date().toISOString(),
59 |       };
60 |       
61 |       return NextResponse.json({ 
62 |         message: '사용자 등록은 성공했으나 데이터베이스 연결 실패', 
63 |         user: dummyUser 
64 |       });
65 |     }
66 |   } catch (error: Error | unknown) {
67 |     console.error('사용자 등록 오류:', error);
68 |     const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류';
69 |     return NextResponse.json(
70 |       { error: `사용자 등록 실패: ${errorMessage}` },
71 |       { status: 500 }
72 |     );
73 |   }
74 | } 
```

src/app/api/users/first/route.ts
```
1 | /**
2 |  * 파일명: src/app/api/users/first/route.ts
3 |  * 목적: 첫 번째 사용자 정보를 반환하는 API
4 |  * 역할: 시스템에 등록된 가장 오래된(첫 번째) 사용자 정보 제공
5 |  * 작성일: 2024-05-28
6 |  */
7 | 
8 | import { NextResponse } from 'next/server';
9 | 
10 | import prisma from '@/lib/prisma';
11 | 
12 | /**
13 |  * 첫 번째 사용자를 가져오는 API 엔드포인트
14 |  */
15 | export async function GET() {
16 |   try {
17 |     // 첫 번째 사용자를 가져옴 (가장 먼저 생성된 사용자)
18 |     const firstUser = await prisma.user.findFirst({
19 |       orderBy: {
20 |         createdAt: 'asc'
21 |       },
22 |       select: {
23 |         id: true,
24 |         name: true,
25 |         email: true
26 |       }
27 |     });
28 |     
29 |     if (!firstUser) {
30 |       return NextResponse.json(
31 |         { error: '사용자를 찾을 수 없습니다.' },
32 |         { status: 404 }
33 |       );
34 |     }
35 |     
36 |     return NextResponse.json(firstUser);
37 |   } catch (error) {
38 |     console.error('사용자 조회 오류:', error);
39 |     
40 |     return NextResponse.json(
41 |       { error: '사용자 조회 중 오류가 발생했습니다.' },
42 |       { status: 500 }
43 |     );
44 |   }
45 | } 
```

src/app/cards/[id]/edit/EditCardPageMock.tsx
```
1 | /**
2 |  * 파일명: EditCardPageMock.tsx
3 |  * 목적: 카드 편집 페이지의 테스트를 위한 모킹 컴포넌트
4 |  * 역할: 실제 컴포넌트의 동작을 시뮬레이션
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2025-04-03
7 |  */
8 | 
9 | import React, { useEffect, useState } from 'react';
10 | 
11 | import { mockActions } from './test-utils';
12 | 
13 | interface Card {
14 |     id: string;
15 |     title: string;
16 |     content: string;
17 |     cardTags: Array<{ id: string; name: string; }>;
18 | }
19 | 
20 | export const EditCardPageMock: React.FC = () => {
21 |     const [card, setCard] = useState<Card | null>(null);
22 |     const [error, setError] = useState<string | null>(null);
23 |     const [isLoading, setIsLoading] = useState(true);
24 | 
25 |     // 간소화된 useEffect - 비동기 로직 단순화
26 |     useEffect(() => {
27 |         const fetchCard = async () => {
28 |             try {
29 |                 const id = 'test-card-123';
30 | 
31 |                 // API 호출 - 동기식으로 처리 (테스트 환경에서는 즉시 해결되는 프로미스 사용)
32 |                 const response = await mockActions.getCard(id);
33 | 
34 |                 // 응답 처리
35 |                 if (!response.ok) {
36 |                     if (response.status === 404) {
37 |                         setError('카드를 찾을 수 없습니다.');
38 |                     } else {
39 |                         setError('카드 로딩에 실패했습니다.');
40 |                     }
41 |                     setIsLoading(false);
42 |                     return;
43 |                 }
44 | 
45 |                 // 응답 데이터 처리
46 |                 const data = await response.json();
47 | 
48 |                 // 데이터에 에러가 있는 경우
49 |                 if ('error' in data) {
50 |                     setError(data.error);
51 |                 } else {
52 |                     // 카드 데이터 설정
53 |                     setCard(data);
54 |                 }
55 | 
56 |                 // 로딩 상태 종료
57 |                 setIsLoading(false);
58 |             } catch (err) {
59 |                 // 에러 처리
60 |                 setError(err instanceof Error ? err.message : '카드 로딩에 실패했습니다.');
61 |                 setIsLoading(false);
62 |             }
63 |         };
64 | 
65 |         // 즉시 함수 호출
66 |         fetchCard();
67 |     }, []);
68 | 
69 |     // 로딩 중 UI
70 |     if (isLoading) {
71 |         return <div data-testid="loading-state">로딩 중...</div>;
72 |     }
73 | 
74 |     // 에러 UI
75 |     if (error) {
76 |         return (
77 |             <div data-testid="error-state">
78 |                 <p>{error}</p>
79 |                 <button onClick={() => mockActions.router.back()}>돌아가기</button>
80 |             </div>
81 |         );
82 |     }
83 | 
84 |     // 카드가 없는 경우
85 |     if (!card) {
86 |         return <div data-testid="no-card-state">카드를 찾을 수 없습니다.</div>;
87 |     }
88 | 
89 |     // 저장 버튼 핸들러
90 |     const handleSave = (e: React.MouseEvent) => {
91 |         e.preventDefault();
92 |         mockActions.router.push('/board');
93 |     };
[TRUNCATED]
```

src/app/cards/[id]/edit/page.test.tsx
```
1 | /**
2 |  * 파일명: src/app/cards/[id]/edit/page.test.tsx
3 |  * 목적: 카드 편집 페이지의 기능 테스트
4 |  * 역할: 페이지 로딩, 네비게이션, API 요청, 에러 처리 등의 기능 검증
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-04-03
7 |  * 수정일: 2025-05-19 : 린터 오류 수정 (import 순서 변경)
8 |  */
9 | 
10 | import { render } from '@testing-library/react';
11 | import '@testing-library/jest-dom';
12 | import userEvent from '@testing-library/user-event';
13 | import { http, HttpResponse } from 'msw';
14 | import { setupServer } from 'msw/node';
15 | import { act } from 'react-dom/test-utils';
16 | import { describe, test, expect, vi, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
17 | 
18 | /**
19 |  * 참고: Next.js 공식 문서에 따르면, async/await를 사용하는 Client Components는
20 |  * 단위 테스트보다 E2E 테스트를 권장합니다.
21 |  * 
22 |  * "Since async Server Components are new to the React ecosystem, Jest currently does not support them.
23 |  * While you can still run unit tests for synchronous Server and Client Components,
24 |  * we recommend using an E2E tests for async components."
25 |  * 
26 |  * 출처: https://nextjs.org/docs/app/building-your-application/testing/jest
27 |  */
28 | 
29 | // vi.mock은 파일 상단으로 호이스팅되므로 최상단에 배치 (Vitest 문서 참조)
30 | vi.mock('./test-utils', () => ({
31 |   mockActions: {
32 |     getCard: vi.fn().mockResolvedValue({
33 |       ok: true,
34 |       status: 200,
35 |       json: () => Promise.resolve({
36 |         id: '1',
37 |         title: '테스트 카드',
38 |         content: '테스트 내용',
39 |         cardTags: []
40 |       })
41 |     }),
42 |     router: {
43 |       back: vi.fn(),
44 |       push: vi.fn()
45 |     }
46 |   }
47 | }));
48 | 
49 | // 모킹 모듈 import는 mock 선언 후에 위치해야 함
50 | import { EditCardPageMock } from './EditCardPageMock';
51 | import { mockActions } from './test-utils';
52 | 
53 | // 테스트 타임아웃 설정
54 | vi.setConfig({ testTimeout: 10000 });
55 | 
56 | // MSW 서버 설정
57 | const server = setupServer(
58 |   http.get('*/api/cards/:id', () => {
59 |     return HttpResponse.json({
60 |       id: '1',
61 |       title: '테스트 카드',
62 |       content: '테스트 내용',
63 |       cardTags: []
64 |     });
65 |   })
66 | );
67 | 
68 | const setup = () => {
69 |   const user = userEvent.setup({ delay: null });
70 |   return {
71 |     ...render(<EditCardPageMock />),
72 |     user,
73 |   };
74 | };
75 | 
76 | // 테스트 환경 설정
77 | beforeAll(() => {
78 |   server.listen();
79 |   vi.useFakeTimers({ shouldAdvanceTime: true });
80 | });
81 | 
82 | afterEach(() => {
83 |   server.resetHandlers();
[TRUNCATED]
```

src/app/cards/[id]/edit/page.tsx
```
1 | /**
2 |  * 파일명: src/app/cards/[id]/edit/page.tsx
3 |  * 목적: 카드 편집 페이지
4 |  * 역할: 기존 카드 데이터를 불러와 편집할 수 있는 UI 제공
5 |  * 작성일: 2025-03-27
6 |  * 수정일: 2025-05-17 : any 타입을 구체적인 타입으로 변경
7 |  */
8 | 
9 | 'use client';
10 | 
11 | import { useEffect, useState } from 'react';
12 | 
13 | import { useRouter } from 'next/navigation';
14 | import { useParams } from 'next/navigation';
15 | 
16 | import { ArrowLeft } from 'lucide-react';
17 | 
18 | import EditCardForm from '@/components/cards/EditCardForm';
19 | import { Button } from '@/components/ui/button';
20 | import { Card, CardContent } from '@/components/ui/card';
21 | 
22 | // 카드 데이터 인터페이스 정의
23 | interface CardData {
24 |   id: string;
25 |   title: string;
26 |   content: string;
27 |   cardTags?: { id: string; tag: { id: string; name: string } }[];
28 |   [key: string]: unknown;
29 | }
30 | 
31 | export default function EditCardPage() {
32 |   const router = useRouter();
33 |   const params = useParams();
34 |   const [loading, setLoading] = useState(true);
35 |   const [card, setCard] = useState<CardData | null>(null);
36 |   const [error, setError] = useState<string | null>(null);
37 | 
38 |   useEffect(() => {
39 |     const fetchCard = async () => {
40 |       try {
41 |         setLoading(true);
42 |         const response = await fetch(`/api/cards/${params.id}`);
43 | 
44 |         if (!response.ok) {
45 |           throw new Error('카드를 찾을 수 없습니다.');
46 |         }
47 | 
48 |         const data = await response.json();
49 |         setCard(data);
50 |       } catch (err) {
51 |         setError(err instanceof Error ? err.message : '카드 로딩 중 오류가 발생했습니다.');
52 |       } finally {
53 |         setLoading(false);
54 |       }
55 |     };
56 | 
57 |     if (params.id) {
58 |       fetchCard();
59 |     }
60 |   }, [params.id]);
61 | 
62 |   const handleBack = () => {
63 |     router.back();
64 |   };
65 | 
66 |   return (
67 |     <div className="container mx-auto py-6 max-w-4xl">
68 |       <Button
69 |         variant="ghost"
70 |         className="mb-4 flex items-center"
71 |         onClick={handleBack}
72 |       >
73 |         <ArrowLeft className="mr-2 h-4 w-4" />
74 |         뒤로 가기
75 |       </Button>
76 | 
77 |       <h1 className="text-2xl font-bold mb-6">카드 수정</h1>
78 | 
79 |       {loading ? (
80 |         <div className="flex justify-center items-center h-32">
81 |           <p>로딩 중...</p>
82 |         </div>
83 |       ) : error ? (
84 |         <Card>
85 |           <CardContent className="pt-6">
[TRUNCATED]
```

src/app/cards/[id]/edit/test-utils.ts
```
1 | /**
2 |  * 파일명: test-utils.ts
3 |  * 목적: 카드 편집 페이지 테스트를 위한 유틸리티 함수 및 모킹 객체 제공
4 |  * 역할: 테스트 설정, 정리, 모킹된 액션 제공
5 |  * 작성일: 2025-04-01
6 |  * 수정일: 2025-04-03
7 |  */
8 | 
9 | import { vi } from 'vitest';
10 | 
11 | interface CardResponse {
12 |   id: string;
13 |   title: string;
14 |   content: string;
15 |   cardTags: Array<{ id: string; name: string; }>;
16 | }
17 | 
18 | interface ErrorResponse {
19 |   error: string;
20 | }
21 | 
22 | type ApiResponse = CardResponse | ErrorResponse;
23 | 
24 | // API 응답 객체 타입
25 | export interface MockApiResponse {
26 |   ok: boolean;
27 |   status: number;
28 |   json: () => Promise<ApiResponse>;
29 | }
30 | 
31 | // 모킹된 액션들
32 | export const mockActions = {
33 |   getCard: vi.fn().mockImplementation((): Promise<MockApiResponse> => {
34 |     return Promise.resolve({
35 |       ok: true,
36 |       status: 200,
37 |       json: () => Promise.resolve({
38 |         id: 'test-card-123',
39 |         title: '테스트 카드',
40 |         content: '테스트 내용',
41 |         cardTags: []
42 |       } as CardResponse)
43 |     });
44 |   }),
45 |   router: {
46 |     back: vi.fn(),
47 |     push: vi.fn()
48 |   },
49 |   toast: {
50 |     success: vi.fn(),
51 |     error: vi.fn()
52 |   }
53 | };
54 | 
55 | /**
56 |  * setupEditCardPageTests: 카드 편집 페이지 테스트를 위한 환경을 설정
57 |  */
58 | export const setupEditCardPageTests = () => {
59 |   // 모든 모킹된 함수 초기화
60 |   vi.clearAllMocks();
61 | 
62 |   // Sonner 토스트 모킹
63 |   vi.mock('sonner', () => ({
64 |     toast: {
65 |       success: vi.fn(),
66 |       error: vi.fn()
67 |     }
68 |   }));
69 | 
70 |   // next/navigation 모킹
71 |   vi.mock('next/navigation', () => ({
72 |     useRouter: () => mockActions.router,
73 |     useParams: () => ({ id: 'test-card-123' })
74 |   }));
75 | };
76 | 
77 | /**
78 |  * teardownEditCardPageTests: 카드 편집 페이지 테스트 후 정리 작업 수행
79 |  */
80 | export const teardownEditCardPageTests = () => {
81 |   vi.clearAllMocks();
82 |   vi.resetModules();
83 | };
84 | 
85 | /**
86 |  * waitForDomChanges: 비동기 작업의 안전한 완료를 위한 도우미 함수
87 |  */
88 | export const waitForDomChanges = () => new Promise(resolve => setTimeout(resolve, 50)); 
```
