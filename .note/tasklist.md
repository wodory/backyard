---
description: 
globs: 
alwaysApply: false
---
**프로젝트 개념 도입 + DB 리펙토링**

***개념***
User me +-> Project 1  +- card 1, 2, 3, 4      <-- [share the cards/projects] --- User Z
        +              +- tree & node info
        +              +- project info
        +         
        +-> Project 2  +- card a, b, c, q
                       +- tree & node info
                       +- project info

**전제**
- '[Zustand-action-msw]' 규칙을 준수하여 Zustand action 기반 커맨드 패턴 구현 
- UI는 반드시 shadcn 컴포넌트를 사용. shadcn 컴포넌트로 만들 수 없는 경우만 나에게 물어보고 별도 구현.
- 모든 변경은 User Rules를 준수하고, 테스트 가능해야 함

**Phase 1: UI 초기 개발**            
1.  **ProjectToolbar 기능 확장** ProjectToolbar에 "프로젝트 이름"이란 static text 대신 "{프로젝트 이름} - {작성자}" 표시. 작성자는 user nickname.
2.  **프로젝트 스키마 및 DB Table 업데이트** 
    * 스키마 
      - [ ] 프로젝트 이름
      - [ ] 소유자 
      - [ ] 생성일
      - [ ] 수정일
      - [ ] 프로젝트 uid
      - [ ] 프로젝트 설정 정보
      - [ ] 프로젝트 카드 배열
      - [ ] 기타 필요한 데이터 
    * 작업
      - [ ] supabase 업데이트 확인
      - [ ] Prisma 스키마 생성 
      - [ ] 지금의 카드는 프로젝트 정보를 오늘 생성한 것으로 설정해서 생성하고 프로젝트에 추가
  - 
3.  **프로젝트 UI 구현:**  
  - [ ] ProjectToolbar에 프로젝트 이름 표시
  - [ ] 프로젝트 툴바 -> 메뉴에 프로젝트 정보 수정.   

4.  **소유자별 프로젝트 선택 화면 구현:**  
  - [ ] 프로젝트 선택 화면
  - [ ] 프로젝트 삭제 
  - [ ] 프로젝트 삭제하면 카드는 어떻게 해야 하지... 아마 전체 삭제. 단, trashcan으로 이동. (90일 보관)
5. **API**
  - [ ] 기본 CRUD
  - [ ] getCurrentProject -> 로딩에서 읽어온 ID가 전역으로 필요할 듯. 

~~~

**버그**
- [ ] prod에서 보드 설정 저장 에러
- [ ] 새 카드 만들기 이후에 화면에 추가 안 되네. 
- [ ] 기존 카드를 수정하면 사이드바에 바로 업데이트 (왜나면 이미 사이드바에 내용이 나타나니까)
  - [ ] 실시간으로 보여야 할까??? 
- [ ] 사이드바 
  - [ ] 사이드바 크기 조절 -> react flow도 크기 조절 
  - [ ] 사이드바 선택 -> 보드 노드도 선택 
  - [ ] 멀티 샐랙트 -> 사이드 바 통합 표시 안 됨

**Todo**
- [ ] 중요 정보 감추기? (사용자, 프로젝트 ID 등등)
- [ ] z 활용한 스키바 벨리데이션 (cards/routes 참고?)
- [ ] 카드 리스트 삭제 -> 캔버스 삭제 
- [ ] Sidebar 필터 
- [ ] 자식 노드와의 why so 관계 추출 -> 계산 @https://reactflow.dev/learn/advanced-use/computing-flows
- [ ] z-index 문제 -> https://reactflow.dev/learn/advanced-use/state-management
- [ ] 찾기 
- [ ] 색상이나 사이즈 시맨틱 + 프리미티브 정리 
- [ ] 오토 레이아웃에서 노드 크기를 유지하기
- [ ] 아이콘
  - [ ] new https://lucide.dev/icons/file-plus
  - [ ] tree https://thenounproject.com/icon/hierachy-6606217/
  - [ ] import text to tree
- [ ] 공유 기능 = readonly
- [ ] 유틸리티 함수 분리
- [ ] 각 행동을 명령 객체(Command Pattern)**으로 캡슐화하여, 그 실행(execute())과 취소(undo()) 동작을 별도 정의합니다.


**Previous Tasks**

[ ] 카드 보드의 카드 구조
- 카드 보드의 카드는 해더와 콘텐츠 영억으로 나뉜다
- 카드는 접고 펼수 있다. 기본값은 접은 상태이다.
- 카드를 접으면 카드는 헤더 영역만 표시한다
  - 카드 헤더에는 카드 제목을 중앙 정렬로 표시하고, 맨 오른쪽에는 [펴기] 단추를 [>] 모양으로 표시한다.
  - [>] 단추를 클릭하면 카드는 펴진다. 
- 카드가 펴지면 컨텐츠 영역도 보여준다
  - 카드 헤더의 [>] 단추는 [^] 단추 = 접기 단추로 바뀐다.
  - 컨텐츠 영역에는 tiptap 뷰어를 표시하고 카드 내용을 표시한다. 
  - 글꼴 크기는 카드 목록보다 60% 수준으로 표시한다. 
  - 카드가 펴질 때 컨텐츠 영역의 최대 높이는 280px로 정한다.  
  - 컨텐츠 영역보다 표시해야 할 카드 내용이 많으면 ... 처리한다. 
- 왼쪽/오른쪽의 연결선 핸들러는 카드가 접히고 펴질 때 마다 위치를 카드 중앙으로 이동한다. 

[ ] 카드 상태
- 카드에 표시하는 다양한 UI와 동작을 카드의 상태별로 다르게 할 가능성이 있음
- 카드 상태를 기본, 마우스 호버, 선택으로 분리.

[ ] 카드 상태 - normal
- 연결선 핸들러 표시하지 않음

[ ] 카드 상태 - hover
- 연결선 핸들러 표시 
- 연결선 핸들러 색상은 연결선과 동일
- UI 변경
  -- 외곽선 : 밝은 핑크색
  -- 카드 배경색 : 

[ ] 카드 상태 - selected 
- 선택 상태는 클릭 혹은 선택 range 내부에 들어왔을 때
- 선택 상태의 UI 변경
  -- 외곽선 : 일반 카드 외곽선 + 2px, 색은 연결선 색과 동일
  -- 카드 배경색 : 초기값은 연결선 색의 밝기 60% 증가 
  -- 변경하는 UI의 값은 모두 환경 변수로 설정. 이후 UI로 바꿀 수 있어야 함. 
- 외곽선을 표시해도 연결선 핸들러가 선 가운데에 올 수 있도록 border 옵션 조절
- 연결선 핸들러 표시
- 연결선 핸들러 색상은 연결선과 동일

[ ] 카드 클릭, 선택
- 카드 위를 클릭하면 카드 선택 상태가 된다
- 카드를 드래스, 클릭, 선택하면 z-index가 가장 높다.

** 토요일 - 원격 환경 적용 및 인증 ** 

**Supabase pw**
$JpH_w$9WKrriPR

**google OAuth ID/Password**
{"web":{"client_id":"545502090118-t5kccm1dguqbvbo8eovcoms71n4vem1e.apps.googleusercontent.com","project_id":"backyard-453110","auth_uri":"https://accounts.google.com/o/oauth2/auth","token_uri":"https://oauth2.googleapis.com/token","auth_provider_x509_cert_url":"https://www.googleapis.com/oauth2/v1/certs","client_secret":"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","redirect_uris":["https://backyard-orpin.vercel.app/"],"javascript_origins":["http://localhost:3000"]}}


## 1. Vercel에 퍼블리시하기

### 퍼블리시 준비 단계 테스트
- [ ] 로컬 환경에서 애플리케이션이 오류 없이 빌드되는지 확인
  - `npm run build` 또는 `yarn build` 명령으로 빌드 오류 확인
- [ ] 환경 변수가 `.env.local`이나 `.env` 파일에 올바르게 설정되어 있는지 확인
- [ ] 프로젝트의 `package.json`에 필요한 스크립트와 의존성이 모두 포함되어 있는지 확인

### Git-Vercel 연동 관리
- [ ] Git push 시 Vercel 자동 배포 설정/해제 방법 확인
- [  ] CLI 기반 수동 배포 명령어 (vercel 또는 npx vercel) 작동 확인
- [ ] 배포 오류 시 디버깅 로그 확인 방법 테스트

## 프로덕션 환경 변수 테스트
- [ ] .env.production 파일에 Supabase 연결 정보가 올바르게 구성되었는지 확인
- [ ] Vercel 대시보드에서 환경 변수가 올바르게 설정되었는지 확인
- [ ] 프로덕션 환경에서 Supabase와 로컬 DB 연결이 정상 작동하는지 확인

### Vercel 배포 테스트
- [ ] Vercel 계정 생성 및 로그인이 정상적으로 되는지 확인
- [ ] GitHub/GitLab 저장소와 Vercel 프로젝트가 올바르게 연결되는지 확인
- [ ] Vercel CLI를 통한 배포가 정상적으로 진행되는지 확인 (`vercel` 명령어)
- [ ] Vercel 환경 변수 설정이 올바르게 되었는지 확인

### 배포 후 테스트
- [ ] 배포된 URL에서 웹사이트가 정상적으로 로딩되는지 확인
- [ ] 모든 페이지와 라우트가 정상적으로 동작하는지 확인
- [ ] 이미지, 폰트 등의 정적 자원이 올바르게 로드되는지 확인
- [ ] 반응형 디자인이 다양한 디바이스에서 올바르게 표시되는지 확인

## 2. DB를 Supabase SaaS로 교체하기

### Supabase 설정 테스트
- [ ] Supabase 계정 생성 및 새 프로젝트 생성이 정상적으로 되는지 확인
- [ ] Supabase 프로젝트의 데이터베이스 연결 정보를 올바르게 가져왔는지 확인
- [ ] Supabase JavaScript 클라이언트 라이브러리가 정상적으로 설치되는지 확인
  - `npm install @supabase/supabase-js` 또는 `yarn add @supabase/supabase-js`

### 데이터 마이그레이션 테스트
- [ ] 기존 데이터베이스 스키마를 Supabase에 맞게 설계했는지 확인
- [ ] 데이터 마이그레이션 스크립트가 정상적으로 작동하는지 확인
- [ ] 마이그레이션 후 데이터 무결성이 유지되는지 확인

### Supabase 연동 테스트
- [ ] Supabase 클라이언트 초기화가 올바르게 되는지 확인
```javascript
const supabaseClient = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
);
```
- [ ] 데이터 조회(SELECT) 쿼리가 정상적으로 작동하는지 확인
- [ ] 데이터 생성(INSERT) 쿼리가 정상적으로 작동하는지 확인
- [ ] 데이터 수정(UPDATE) 쿼리가 정상적으로 작동하는지 확인
- [ ] 데이터 삭제(DELETE) 쿼리가 정상적으로 작동하는지 확인
- [ ] Supabase RLS(Row Level Security)가 올바르게 설정되었는지 확인

### 오류 처리 테스트
- [ ] 데이터베이스 연결 실패 시 적절한 오류 메시지가 표시되는지 확인
- [ ] 쿼리 실패 시 사용자에게 친절한 오류 메시지가 제공되는지 확인
- [ ] 네트워크 오류 시 재시도 메커니즘이 작동하는지 확인

## Supabase와 로컬 DB 사용자 동기화 테스트
- [ ] Supabase 인증 사용자 정보가 로컬 데이터베이스에 자동으로 동기화되는지 확인
- [ ] 사용자 로그인 시 존재하지 않는 사용자는 자동 등록되는지 확인
- [ ] 동기화 실패 시 대체 로직(fallback)이 정상 작동하는지 확인

## Next.js 15 쿠키 처리 테스트
- [ ] 서버 컴포넌트(layout.tsx)에서 쿠키 설정 방식이 올바르게 구현되었는지 확인
- [ ] 미들웨어에서 쿠키 처리가 Next.js 15 방식으로 올바르게 수행되는지 확인
- [ ] "@supabase/ssr: createServerClient was configured without set and remove cookie methods" 경고가 해결되었는지 확인

## 미들웨어 인증 강화 테스트
- [ ] 미들웨어에서 보안 관련 쿠키 옵션(secure, sameSite, httpOnly)이 올바르게 설정되었는지 확인
- [ ] 세션 기반 인증 상태 확인 로직이 정상 작동하는지 확인
- [ ] 디버깅 로그가 적절하게 기록되는지 확인

## Prisma 환경 설정 테스트
- [ ] schema.prisma 파일이 다중 환경(개발/프로덕션)을 지원하도록 설정되었는지 확인
- [ ] 환경에 따른 데이터베이스 프로바이더(SQLite/PostgreSQL) 전환이 정상 작동하는지 확인
- [ ] 배포 전 스크립트에서 사용하는 패키지들이 존재하는지 확인

## 배포 스크립트 오류 처리
- [ ] pre-deploy.js 스크립트가 오류 발생 시에도 배포 과정을 중단하지 않도록 수정
- [ ] 스키마 동기화 실패 시 적절한 오류 처리 방법 구현

## 3. Google 원격 인증 붙이기

### Google OAuth 설정 테스트
- [ ] Google Cloud Console에서 OAuth 클라이언트 ID와 비밀키를 올바르게 생성했는지 확인
- [ ] 리디렉션 URI가 올바르게 설정되었는지 확인 (로컬 개발 및 Vercel 배포 URL 모두)
- [ ] 필요한 OAuth 스코프(이메일, 프로필 등)가 올바르게 지정되었는지 확인

### Supabase Auth 연동 테스트
- [ ] Supabase 프로젝트에서 Google OAuth 제공자가 올바르게 구성되었는지 확인
- [ ] Supabase Auth API를 사용한 Google 로그인 코드가 정상적으로 작동하는지 확인
```javascript
const { user, session, error } = await supabase.auth.signIn({
  provider: 'google',
});
```

### 인증 흐름 테스트
- [ ] 로그인 버튼 클릭 시 Google 로그인 페이지로 정상적으로 리디렉션되는지 확인
- [ ] Google 계정으로 성공적으로 로그인 후 애플리케이션으로 리디렉션되는지 확인
- [ ] 사용자 정보(이메일, 이름 등)가 올바르게 가져와지는지 확인
- [ ] 로그인 상태가 애플리케이션 전체에서 올바르게 유지되는지 확인
- [ ] 로그아웃 기능이 정상적으로 작동하는지 확인

### 인증 상태 관리 테스트
- [ ] 새로고침 후에도 로그인 상태가 유지되는지 확인
- [ ] 세션 토큰이 올바르게 저장되고 관리되는지 확인
- [ ] 인증이 필요한 페이지에 비로그인 사용자 접근 시 적절히 처리되는지 확인
- [ ] 인증된 사용자만 특정 API를 호출할 수 있는지 확인

### 사용자 경험 테스트
- [ ] 로그인 및 로그아웃 과정이 사용자에게 직관적인지 확인
- [ ] 로딩 상태가 적절히 표시되는지 확인
- [ ] 인증 오류 시 사용자 친화적인 메시지가 표시되는지 확인

### 최종 통합 테스트
- [ ] 로그인한 사용자의 데이터가 Supabase DB와 올바르게 연동되는지 확인
- [ ] 권한에 따른 데이터 접근 제한이 올바르게 작동하는지 확인
- [ ] Vercel 배포 환경에서도 모든 인증 기능이 정상적으로 작동하는지 확인

## 4. UI 수정

### 엣지 스타일 설정 
- [x] 엣지 해드 모양
- [x] 엣지 스타일 
- [x] 엣지 색상 (기본/selected)

### 스타일 및 설정값 체계화
- [x] 스타일 변수 관리 cardBoardUiOptions.json
- [x] 핸들 크기 등이 하드 코딩되어 있음.

### 버그 : 수평/수직 레이아웃
- [x] 간격이 너무 벌어지는 문제
- [x] 이 값도 옵션으로 설정

## todo
- [x] env 파일 정리 (특히 .env, .env.development)
- [x] 환경 변수 등 git에 배포하지 않은 파일에 대한 readme 작성
- [x] /sciprt와 /prisma에서도 사용하지 않는 파일 정리. 
- [ ] vercel 배포 후 로그인 실패 문제
- [ ] vercel 및 supabase 설정도 readme 추가 

** 수요일 - 전체 UI 변경  ** 

## react flow 기능 추가 
- [x] Toast 위치는 top-center
- [x] https://reactflow.dev/examples/nodes/add-node-on-edge-drop
  - [x] 새로 생성한 카드가 사이드바에 안 보이는 문제
- [x] 컴포넌트 이름 변경
  - [x] toptoobar를 두 개로 분리. left : Project Toolbar, right :shoutcut toolbar
  - [x] BottomToolbar -> MainToolbar
- [x] 모든 UI 요소는 플로팅 패널로 구현하여 시각적 일관성 유지 
- [x] 도구 막대와 패널은 12px(top-3) 간격 유지
- [x] sidebar는 드래그로 크기 변경 가능 (환경 저장 필요)
- [x] 프로젝트 툴바와 사이드바의 제목 (h1) 클래스는 text-l
- [x] Project Toolbar와 Shotcut Toolbar에 기능 연동하기.
  -- [x] 오른쪽 아래의 [새 카드 만들기]는 MainToobar 왼쪽 첫 단추
  -- [x] 이전에 개발한 [레이아웃 옵션]의 드롭다운 메뉴 아이템은 MainToolbar에 순서대로 배치
    --- [x] 수평
    --- [x] 수직
    --- [x] 자동 
    --- [x] 레이아웃 저장 
  -- [x] 각종 색/스타일 옵션 설정은 프로젝트 툴바의 삼선 드롭다운에 [보드 설정 >] 누르면 차일드 팝업
  -- [x] 숏컷 도구 막대
    --- [x] 맨 오른쪽은 로그아웃
    --- [x] 그 다음은 사이드바 접기
  -- [x] 메인 툴바에 [레이아웃 저장] 추가 
  -- [x] 프로젝트 툴바 > 메뉴에 [저장]도 이름을 [레이아웃 저장]으로 바꾸고 기능 추가
  -- [x] 왼쪽 아래의 아이콘 두 개 (이전에 만든 메뉴)는 삭제 
- [x] Sidebar에 카드에 있는 "지우기" 단추는 호버할 때만 보이기.
- [x] sidebar > 카드 배경색
  -- [x] background-color: #F4F4F5

- [x] 사이드바 동작 수정 
  -- [x] 캔버스에서 카드 선택 > 카드 제목 + contents 표시
  -- [x] 캔버스에서 선택 해제 > 다시 카드 목록 선택
  -- [x] 카드 목록에서 카드를 캔버스로 드래그 -> 노드로 추가
  -- [x] 캔버스에서 여러 카드 선택할 때 사이드바의 동작을 react flow 공식 문서 참고해서 구현. 
    --- [x] 카드 목록은 문서 뷰어로 바뀜.
    --- [x] 문서 뷰어는 캔버스에서 하나의 노드만 선택할 때와 동일한 뷰어 사용. 
    --- [x] 문서 뷰어의 제목
        ---- [x] 여러 카드 제목을 계층 순서대로 ,로 표시하고
        ---- [x] 사이드 바의 너비보다 넓어지면 ... 처리 
    --- [x] 문서 뷰어의 내용 
        ---- [x] 선택한 카드의 내용을 계층 순서대로 연결해서 하나의 HTML로 생성해서 
        ---- [x] 문서 뷰어의 콘텐츠 영역에 표시 
        ---- [ ] 문서 뷰어의 문서 표시 영역보다 길어지면 ... 처리 
    --- [x] 문서 뷰어의 날짜, 태그
        ---- [x] 표시하지 않음. 
- [x] 노드 클릭 -> 카드 목록에서 선택 구현 -> 문서 뷰어 전환에서 "카드 목록에서 선택 구현"은 불필요한 단계야. 
- [x] Main Canvas에서 카드 이벤트 정리 
  -- [x] 클릭 -> 카드 선택
  -- [x] 더블 클릭 -> 카드 선택 후 카드 정보 수정하기
- [x] 카드 수정 모드 구현
  -- [x] 캔버스에서 노드 더블클릭
  -- [x] 카드 목록에서 카드 더블 클릭 
  -- [x] 카드 목록에서 카드 hover -> 오른쪽 상단에 연필 아이콘 (추가 필요) -> 클릭 
      
- [x] 계속 다른 카드를 선택하면 문서 뷰어에서 contents가 제대로 업데이트 안 되는 현상. (제목과 tags는 잘 됨)
- [x] 캔버스 > 다중 선택 -> 문서 뷰어의 콘텐츠에서 마크업 랜더링 안 되는 문제 
- [x] 자동 레이아웃에서 노드 너비가 너무 넓음. 이전에 설정한 값 참고. 

# 환경 개선 
- [ ] 네이밍 통일 CreateCardButton vs. EditCardForm
- [ ] CSS를 프리미티브/시멘틱으로 정의하기
- [ ] 중요한 값은 외부 변수로. 캔버스 노드 크기, 카드 목록의 카드 높이... 
- [ ] https://reactflow.dev/examples/nodes/delete-middle-node


## 특별 고려사항

- 모든 UI 요소는 플로팅 패널로 구현하여 시각적 일관성 유지
- 도구 막대와 패널은 3px 마진으로 간격 유지
- 캔버스 컴포넌트는 타 팀에서 개발 중인 컴포넌트와 통합 가능하도록 설계
- 오른쪽 패널은 카드 목록 및 카드 뷰어 두 가지 모드. 캔버스에서 카드를 선택하면 카드 콘텐츠 뷰어, 아니면 카드 목록. 
- 모든 아이콘은 60x60 크기로 구현. 외부에서 일러스트풍의 아이콘을 가져오기. 

## 1. 기본 레이아웃 및 컴포넌트 설정

- [ ] shadcn 공통 컴포넌트 설치 (버튼, 패널, 드롭다운 등)
- [ ] 반응형 레이아웃 기준 설정 (브레이크포인트, 크기 조정 정책)

## 2. 플로팅 도구 막대 구현

- [x] 좌측 도구 막대 컴포넌트 구현
  - [x] 삼선 메뉴 아이콘과 프로젝트 제목 배치
  - [x] 드롭다운 메뉴 기능 구현 (내보내기, 가져오기, 저장, 옵션, 로그아웃)
  - [x] 각 메뉴 항목에 아이콘 추가
  - [x] 외부 클릭 시 메뉴 닫기 기능

- [x] 우측 도구 막대 컴포넌트 구현
  - [x] 공유, 로그아웃, 설정 아이콘 배치
  - [x] 아이콘 버튼에 호버 효과 추가
  - [x] 각 버튼 기능 연결 준비

- [x] 하단 중앙 도구 막대 컴포넌트 구현
  - [x] 60x60 크기의 아이콘 버튼 구성
  - [x] 새 카드, 수평 정렬, 수직 정렬, 요약 기능 아이콘 구현
  - [x] 텍스트 레이블 추가
  - [x] 화면 크기에 따른 위치 조정 로직 (오른쪽 패널 너비 고려)

## 3. 메인 캔버스 영역 구현

- [x] /board 통합

- [x] 통합 인터페이스
  - [x] 외부 컴포넌트와의 연동 인터페이스 설계
  - [x] 이벤트 처리 시스템 구축 (선택된 노드 정보 전달 등)
  - [x] 공통 상태 관리 구현 (Context API 또는 Redux)

## 4. 오른쪽 패널 구현

- [x] 패널 기본 구조 및 스타일링
  - [x] 플로팅 패널로 구현 (그림자, 둥근 모서리)
  - [x] 적절한 마진 및 패딩 적용
  - [x] 스크롤 처리
  - [x] 카드를 선택하면 문서 콘텐츠, 카드를 선택하지 않았다면 카드 목록 

- [x] 카드 목록 구현
  - [x] /cards 통합
  - [x] 카드를 한 줄로 표시

- [x] 카드 콘텐츠 뷰어 > 뷰어 헤더 구현
  - [x] 선택한 카드의 contents = 문서
  - [x] 문서 제목 및 작성자 정보 표시
  - [x] 날짜 표시 (24.3.7 형식)
  - [x] 스타일링 및 정렬

- [x] 카드 콘텐츠 영역 구현
  - [x] 콘텐츠 표시 영역 설계
  - [x] 선택된 노드에 따른 콘텐츠 렌더링 로직
  - [x] 콘텐츠 포맷팅 지원 (tiptap viewer)

## 5. 상태 관리 및 데이터 연동

- [x] 전역 상태 관리 구현
  - [x] 현재 선택된 노드 상태
  - [x] 프로젝트 메타데이터 상태
  - [x] UI 상태 (패널 표시 여부, 메뉴 열림 상태 등)

- [x] API 연동 설계
  - [x] 데이터 가져오기/저장 인터페이스
  - [x] 다른 프로젝트 컴포넌트와의 통신 방식 정의
  - [x] 에러 처리 및 로딩 상태 관리

## 6. 확장성 및 통합

- [x] 확장 가능한 플러그인 아키텍처 설계
  - [x] 외부 컴포넌트 로딩 메커니즘
  - [x] 이벤트 버스 구현
  - [x] 공통 인터페이스 정의

- [x] 기존 컴포넌트와의 통합
  - [x] 컴포넌트 간 데이터 공유 방식
  - [x] 일관된 스타일링 적용
  - [x] 성능 최적화 전략

## 7. 마무리 및 검증

- [x] 크로스 브라우저 테스트
- [x] 접근성 검사 및 개선
- [x] 성능 최적화 (메모이제이션, 코드 스플리팅 등)
- [x] 코드 리팩토링 및 정리
- [x] 문서화 (개발자 가이드, API 문서 등)

## 특별 고려사항

- 모든 UI 요소는 플로팅 패널로 구현하여 시각적 일관성 유지
- 도구 막대와 패널은 5px 마진으로 간격 유지
- 캔버스 컴포넌트는 타 팀에서 개발 중인 컴포넌트와 통합 가능하도록 설계
- 문서 뷰어는 캔버스에서 선택된 노드 데이터와 연동되도록 구현
- 모든 아이콘은 60x60 크기로 일관성 있게 구현


# BoardComponent.tsx 리팩토링

## 1. 리팩토링 목표

현재 BoardComponent.tsx(1100줄 이상)는 다음과 같은 문제점이 있습니다:
- 너무 많은 역할과 책임을 가지고 있음
- 코드 가독성과 유지보수성이 낮음
- 테스트하기 어려운 구조

제안된 폴더 구조와 모듈 분리 전략을 따라 단일 책임 원칙에 맞게 리팩토링하겠습니다.

## 2. 리팩토링 단계

### 1단계: 타입 정의 분리 (완료)
- ✅ `board-types.ts` 파일 생성 및 타입 정의 이전

### 2단계: 커스텀 훅 분리
- ✅ `useNodes.ts` - 노드 관련 로직 분리 완료
- ✅ `useEdges.ts` - 엣지 관련 로직 분리 
- ✅ `useBoardHandlers.ts` - 보드 이벤트 핸들러 분리
- ✅ `useBoardUtils.ts` - 유틸리티 함수 분리

### 3단계: 컴포넌트 분리
- ✅ `Board.tsx` - 메인 컨테이너 컴포넌트 생성
- ✅ `BoardCanvas.tsx` - ReactFlow 캔버스 관련 로직 분리
- ✅ `BoardControls.tsx` - 컨트롤 패널 관련 로직 분리

### 4단계: 상태 관리 리팩토링
- ✅ `useBoardStore.ts` - Zustand를 활용한 전역 상태 관리 구현

### 5단계: 노드 컴포넌트 분리
- ✅ `nodes/` 폴더 생성
- ✅ `nodes/CustomNodeTypeA.tsx` 등 커스텀 노드 컴포넌트 분리

### 6단계: 유틸리티 분리
- ✅ `utils/graphUtils.ts` - 그래프 관련 순수 함수 분리
- ✅ `utils/constants.ts` - 상수 정의 파일 생성/업데이트

### 7단계: 테스트 작성
- ✅ `useNodes.test.tsx` - useNodes 훅 테스트 완료
- ⬜ src/component/layout/MainCanvas.tsx에 리펙토링한 파일 반영 
- ⬜ src/app/board/page.tsx에 리펙토링한 파일 반영


## 3. 세부 구현 계획

### useEdges.ts 구현 (다음 단계)
```typescript
/**
 * useEdges: 엣지 관련 상태 및 로직을 관리하는 훅
 * - 엣지 상태 관리 (useEdgesState)
 * - 엣지 변경 핸들러 (handleEdgesChange)
 * - 엣지 연결 핸들러 (onConnect)
 * - 엣지 저장 함수 (saveEdges)
 */
```

### useBoardStore.ts 구현 방향
```typescript
/**
 * useBoardStore: 보드 상태 및 액션을 관리하는 전역 상태 저장소
 * - 노드/엣지 상태 관리
 * - UI 상태 관리 (선택된 노드, 모달 상태 등)
 * - 액션 함수 (노드/엣지 추가, 삭제, 업데이트)
 */
```

### Board.tsx 컴포넌트 구조
```typescript
/**
 * Board: 보드 전체를 조율하는 메인 컴포넌트
 * - 레이아웃 관리
 * - BoardCanvas와 BoardControls 조율
 * - 모달 관리
 */
```

## 4. 리팩토링 전략 및 주의사항

1. **점진적 접근**: 한 번에 모든 것을 변경하지 않고, 모듈별로 분리하며 각 단계마다 테스트

2. **상태 관리 통합**: 기존에 분산된 상태를 Zustand 저장소로 통합하여 상태 관리 일원화

3. **React Flow 컨텍스트 관리**: React Flow 훅은 반드시 적절한 컨텍스트 내에서 사용하도록 주의

4. **성능 최적화**: 불필요한 리렌더링 방지를 위한 메모이제이션 및 Zustand 선택자 활용

5. **테스트 우선**: 각 모듈은 분리 후 즉시 테스트 작성하여 기능 보장

## 5. 다음 단계 (useEdges 훅 구현)

현재 진행 중인 리팩토링에서 다음 단계는 엣지 관련 로직을 분리하는 것입니다. useNodes와 유사한 패턴으로 useEdges 훅을 구현하여 BoardComponent에서 엣지 관리 로직을 분리하겠습니다.
