좋습니다. Next.js 15을 사용하고 있다면 Server Actions을 정식으로 사용할 수 있으므로, TanStack Query와 함께 사용하는 하이브리드 구조를 적용하기에 최적의 조건입니다.

이제 다음을 반영한 최종 아키텍처 리팩토링 요구사항 문서를 작성하겠습니다:

1. 새로운 **7단계: 타입 통합 및 코드 정리** 추가
2. API 처리 전략을 **Server Actions + API Route 혼용** 구조로 명시
3. 전체 문서 구조 및 작업 순서를 업데이트하여 Cursor Agent가 바로 실행 가능한 Tasklist 형태로 구성

곧 문서를 Markdown 형식으로 정리해서 보여드릴게요.

# Backyard 애플리케이션 아키텍처 리팩토링 요구사항 (최종안)

## 1. 목표

- **AI 에이전트(Cursor) 작업 효율 개선:**  
  명확하고 일관된 아키텍처 패턴을 제공하여 AI 에이전트의 코드 생성 및 이해를 돕습니다. 또한 파일당 코드 라인 수를 관리하여 (가이드라인: 500 LoC 이하) AI의 컨텍스트 이해 부담을 감소시킵니다.

- **테스트 용이성 향상:**  
  상태 관리 로직, API 호출 로직, UI 컴포넌트를 분리하여 각 부분을 개별적으로 테스트할 수 있는 구조를 마련합니다. 이를 통해 단위 테스트 및 통합 테스트 작성 기반을 확보하고 버그 발생 시 원인을 신속히 파악할 수 있습니다.

- **아키텍처 개선:**  
  서버 상태와 클라이언트 상태를 분리하여 각각 적합한 도구로 관리합니다 (TanStack Query로 **서버 상태**, Zustand로 **클라이언트 상태** 관리). 기존 전역 스토어(`useAppStore`, `useIdeaMapStore` 등)의 역할을 재정의하고 단순화합니다. 인증 로직은 `@supabase/ssr` 중심으로 단일화하고, 중복된 액션을 통합하여 코드의 명확성을 높입니다. 이러한 개편을 통해 향후 **프로젝트 기능** 추가나 **실시간 협업** 같은 기능 확장이 용이한 기반을 마련하고, UI와 데이터 로직 분리로 UI 변경에 대한 영향도를 줄입니다.

## 2. 세부 개선 과제

- **Zustand 전역 스토어 슬라이스 패턴 적용:** Zustand 스토어를 여러 슬라이스로 분리하여 클라이언트 **UI 상태** 및 전역 이벤트 관리에 집중하도록 재구성합니다. 이를 통해 각 슬라이스가 자신의 책임을 갖고 불필요한 렌더를 최소화합니다.

- **TanStack Query 도입 (서버 상태 관리):** TanStack Query를 활용하여 **서버 데이터**(Cards, Tags, Projects, User 등)의 Fetching, Caching, Mutation을 일관되게 관리합니다. React Query DevTools 등으로 상태를 가시화하고, 서버 상태 관리를 전역 스토어에서 분리합니다.

- **API 서비스 계층 분리:** 모든 API 호출 로직을 `src/services` 디렉토리 아래 서비스 함수로 분리합니다. 각 서비스 함수에서는 **Supabase/Prisma**를 직접 호출하거나 Next.js API Route를 fetch하며, Zod를 이용한 요청/응답 데이터 유효성 검사와 표준화된 응답 형식을 적용합니다. UI 컴포넌트나 훅은 이 서비스 계층을 통해서만 데이터에 접근하도록 합니다.

- **인증 상태 관리 통합:** 인증 로직을 `@supabase/ssr` (Supabase의 SSR 기능)과 신규 `useAuth` 커스텀 훅 중심으로 통합합니다. `useAuthStore` Zustand 스토어는 사용자 프로필 캐싱과 UI 로딩/에러 상태만 관리하도록 축소하고, 토큰 저장 등의 역할은 Supabase에 맡깁니다. 기존 `AuthContext`는 제거하여 인증 소스의 단일성을 확보합니다.

- **중복 전역 상태 액션 정리:** 예를 들어 카드 선택과 관련된 중복 액션들(`selectCard`, `selectCards`, `toggleSelectedCard`)을 하나의 Zustand 슬라이스 내에서 통합 관리하도록 단순화합니다. 이로써 상태 변경이 일관되게 이루어지고 혼란을 줄입니다.

- **UI 설정 전역 관리 일원화:** 기존 `ThemeContext`는 제거하고, 테마나 레이아웃 등 전역 UI 설정은 Zustand의 별도 슬라이스(예: `AppSettingSlice` 등)로 관리합니다. 이렇게 하면 전역 UI 설정도 다른 UI 상태와 동일한 패턴으로 관리할 수 있습니다.

- **IdeaMap 상태 관리 책임 분리:** `useIdeaMapStore`는 React Flow 인스턴스 상태, 뷰포트, 로컬 레이아웃 설정 등 **IdeaMap UI 상태** 관리에만 집중하도록 재구성합니다. IdeaMap의 노드/엣지 데이터는 서버에서 불러온 카드/태그 등의 정보를 가공해야 하므로, 해당 로직은 `useIdeaMapSync`와 같은 **커스텀 훅**으로 분리합니다. 이를 통해 UI 상태와 데이터 변환 로직을 분리하여 가독성과 유지보수성을 높입니다.

- **컴포넌트의 데이터 의존성 정리:** 주요 컴포넌트(예: `IdeaMap.tsx`, `Sidebar.tsx`)는 직접 API 호출이나 복잡한 비즈니스 로직을 수행하지 않고, TanStack Query 훅(예: `useCards`, `useTags` 등)과 Zustand 훅(예: `useAppStore`)을 통해 필요한 상태를 받아 사용하도록 리팩토링합니다. 이렇게 함으로써 컴포넌트는 **표현 및 이벤트 처리**에 집중하고 데이터 소스로부터 분리됩니다.

- **타입 정의 중앙관리:** `src/types` 디렉토리에서 애플리케이션 전반에 걸쳐 쓰이는 타입(Card, Tag, User, Project, 각 Store 슬라이스의 상태 등)을 일관성 있게 정의하고 사용합니다. 중복되거나 불명확한 타입 정의를 통합하여, 타입스크립트 지원을 강화하고 개발자 및 AI 에이전트의 코드 이해를 돕습니다.

- **순환 참조 문제 해결:** 기존 코드의 모듈 간 **순환 참조(circular dependency)** 문제를 파악하고, 리팩토링을 통해 자연스럽게 해소되도록 합니다 (예: 타입 분리, 의존성 방향 조정 등으로 해결).

- **불필요한 코드/엔드포인트 제거:** 사용되지 않는 옛 스토어 훅, 컨텍스트, 혹은 `/api/users/first` 등과 같은 불필요한 API 엔드포인트 및 관련 로직을 정리합니다. 이를 통해 코드베이스를 깔끔하게 유지하고 혼선을 방지합니다.

- **Next.js Server Actions 도입 (하이브리드 데이터 처리):** Next.js 13에서 도입된 **서버 액션(Server Actions)**을 활용하여, 내부 UI에서 발생하는 데이터 변경 작업은 가능하면 별도 API Route 호출 없이 서버에서 직접 처리하도록 구조를 개선합니다. 이를 통해 클라이언트-서버 왕복을 줄이고, 필요한 경우 여전히 **API Route**를 통해 외부 서비스나 Third-party 호출도 지원하는 하이브리드 구조를 취합니다.

## 3. 작업 순서

아래의 작업 단계 1단계부터 8단계까지 순차적으로 리팩토링을 진행합니다. 각 단계마다 **목표**, **세부 단계**, **검증 방법**을 명시하여 Cursor AI 에이전트 및 개발 팀원들이 따라하기 쉽게 구성합니다.

### 1단계: 기본 설정 및 인증 리팩토링

* **목표:** TanStack Query 기반을 프로젝트에 설정하고 Supabase의 SSR 기능을 활용한 인증 체계를 확립합니다. 또한 `useAuthStore`의 역할을 재정의하여 인증 상태 관리의 단순화를 달성합니다.

* **세부 단계:**
  1. **TanStack Query 설치 및 Provider 설정:**  
     - `@tanstack/react-query` 및 개발용 도구인 `@tanstack/react-query-devtools`를 프로젝트에 설치합니다.  
     - 전역으로 Query 기능을 사용할 수 있도록, `src/app/layout.tsx` (또는 클라이언트 루트 컴포넌트)에서 `QueryClientProvider`를 설정하고 QueryClient를 주입합니다.  
     - 개발 환경에서만 React Query DevTools를 렌더링하여 쿼리 상태를 디버깅할 수 있도록 합니다.

  2. **인증 로직 정리 (`lib/auth.ts`, `lib/auth-server.ts`):**  
     - `lib/auth.ts` (클라이언트 인증 유틸리티)에서 브라우저 `localStorage`/`sessionStorage`를 통한 토큰 또는 verifier 관리 로직을 제거합니다. 이제 Supabase가 제공하는 클라이언트 객체를 직접 사용하도록 하며, 예를 들어 `signInWith...`, `signOut` 함수는 내부에서 Supabase 클라이언트 메소드를 호출하도록 변경합니다.  
     - `lib/auth-server.ts` (서버 인증 유틸리티)는 필요한 경우 최신 Supabase SSR 방식에 맞게 검토합니다. (예: `createServerComponentClient` 사용 확인 등)

  3. **`useAuth` 커스텀 훅 생성:**  
     - Supabase 클라이언트의 `auth.onAuthStateChange`를 이용하여 인증 상태 변화를 구독하는 `useAuth` 훅을 작성합니다. 이 훅은 `useEffect` 내부에서 위 구독을 설정하고, 반환값으로 현재 사용자 세션 정보와 로딩/에러 상태를 제공하도록 합니다.  
     - 인증 상태 변경 이벤트가 발생하면 (로그인, 로그아웃 등) Supabase 세션으로부터 사용자 정보를 추출하여 `useAuth` 훅의 상태로 업데이트합니다. 이를 통해 Supabase 세션을 **싱글 소스 오브 트루스(single source of truth)**로 삼고, 클라이언트 측에서는 이 훅만 바라보도록 합니다.

  4. **`useAuthStore` 리팩토링:**  
     - Zustand로 구현된 `useAuthStore`의 상태에서 더 이상 필요없는 `accessToken`, `refreshToken`, `codeVerifier` 등을 제거합니다.  
     - 대신 사용자 프로필 정보 캐시에 사용할 `profile` 객체, 로딩 여부를 나타낼 `isLoading`, 에러 메시지를 담을 `error` 상태만 남기거나 신규 추가합니다.  
     - 앞서 만든 `useAuth` 훅과 연결하여, 인증 상태 변화 시 `useAuthStore`의 `profile`, `isLoading`, `error` 상태가 적절히 업데이트되도록 합니다. (예: `useAuth` 훅 내부에서 Zustand 액션을 호출)  
     - 더 이상 필요없는 인증 관련 액션들(`setTokens`, `setUser` 등)은 제거하거나, 일부 남기는 경우 역할을 현재 구조에 맞게 조정합니다.

  5. **`AuthContext` 제거:**  
     - 기존에 Context API로 구현된 `AuthProvider` 및 관련 `AuthContext` 사용 코드를 전부 제거합니다.  
     - 컴포넌트들이 인증 상태가 필요할 경우 이제 Context 대신 `useAuth` 훅이나 `useAuthStore`를 통해 접근하도록 일괄 수정합니다.

  6. **Supabase 미들웨어 및 서버측 설정 점검:**  
     - Supabase에서 제공하는 Next.js 미들웨어 (`supabase/middleware.ts`)와 서버 클라이언트 초기화 (`supabase/server.ts`) 파일을 확인하여, PKCE 로그인 과정의 `code_verifier` 쿠키 로직 등이 Supabase 라이브러리 내부에서 적절히 처리되고 있는지 검토합니다. 수동 구현이 불필요하다면 코드를 정리하고, 쿠키의 보안 옵션(secure, httpOnly 등)이 올바르게 설정되어 있는지 확인합니다.

  7. **로그인/콜백 관련 페이지 및 라우트 수정:**  
     - 로그인 페이지(`src/app/login/page.tsx` 혹은 관련 컴포넌트)에서, 기존에 토큰을 저장하던 로직을 제거하고 `lib/auth.ts`의 `signInWith...` 함수를 직접 호출하도록 수정합니다. 사용자가 로그인 시 Supabase가 자체적으로 쿠키 세션을 관리하므로 추가 저장이 필요없습니다.  
     - OAuth 로그인 이후 리디렉션을 처리하는 콜백 라우트 (`src/app/auth/callback/route.ts`)에서는 Supabase의 `exchangeCodeForSession` 사용 여부를 확인하여, 인증 코드 교환이 제대로 이루어지고 세션이 생성되는지 검증합니다.  
     - 인증 에러를 표시하는 오류 페이지 (`src/app/auth/error/page.tsx`)는 Next.js의 `useSearchParams` 훅 등을 통해 쿼리 파라미터로 전달된 에러 메시지를 읽어 사용자에게 표시하도록 되어있는지 확인하고 필요한 경우 수정합니다.

* **검증 방법:**
  - Google OAuth 또는 이메일/비밀번호 등 **로그인/로그아웃 기능**을 수동 테스트하여, 전체 플로우가 오류 없이 동작하는지 확인합니다. (로그인 -> 콜백 -> 메인 페이지 진입, 로그아웃 시 세션 정리 등)  
  - 페이지 새로고침 또는 직접 URL 접근 후에도 Supabase **세션 쿠키** 기반으로 로그인 상태가 유지되어 자동 로그인되는지 확인합니다.  
  - React Developer Tools 등을 사용해 `useAuthStore`의 상태를 검사하여, 토큰 관련 상태가 제거되고 `profile`, `isLoading`, `error` 값만 남았는지 확인합니다.  
  - `AuthContext` 관련 코드가 전부 삭제되었는지 코드베이스를 검색하여 재확인합니다.  
  - 로그인 또는 로그아웃 과정에서 콘솔 에러가 발생하지 않는지 확인합니다.

### 2단계: API 서비스 계층 구축 및 TanStack Query 적용 (Card 예시)

* **목표:** 카드(Card) 데이터를 불러오고 조작하는 로직을 리팩토링합니다. 우선 **서비스 계층**을 도입해 API 호출을 캡슐화하고, **TanStack Query**를 사용하여 카드 **목록 조회**를 구현합니다. 이를 통해 컴포넌트가 직접 API를 호출하는 것을 피하고, 데이터 요청/캐싱이 효율적으로 이루어지도록 합니다.

* **세부 단계:**
  1. **API 서비스 디렉토리 생성:**  
     - `src/services` 디렉토리를 생성합니다. 이후 모든 비즈니스 로직이 담긴 API 호출 함수를 이곳에 모아 관리합니다.

  2. **Card 서비스 함수 구현 (`src/services/cardService.ts`):**  
     - 카드와 관련된 API 호출 함수를 작성합니다. 예를 들어:  
       **`fetchCards(params)`:** GET `/api/cards` 엔드포인트를 호출하여 카드 **목록** 데이터를 가져옵니다. 필요에 따라 `params`에 필터나 페이지네이션 정보를 전달합니다.  
       **`fetchCardById(id)`:** GET `/api/cards/[id]` 엔드포인트를 호출하여 특정 카드의 상세 정보를 가져옵니다.  
       **`createCardAPI(data)`:** POST `/api/cards` 엔드포인트를 호출하여 새로운 카드를 생성합니다.  
       **`updateCardAPI(id, data)`:** PUT `/api/cards/[id]` 엔드포인트를 호출하여 카드 `id`에 해당하는 데이터를 수정합니다.  
       **`deleteCardAPI(id)`:** DELETE `/api/cards/[id]` 엔드포인트를 호출하여 특정 카드를 삭제합니다.  
     - 각 함수 내부에서는 `fetch` 또는 Supabase 클라이언트를 사용하여 API를 호출하고, **Zod**를 활용해 응답 데이터 구조를 검증할 수 있습니다 (선택 사항).  
     - 또한 모든 서비스 함수는 `{ success: boolean, data: T | null, error: string | null }` 같은 **표준화된 반환 구조**를 고려합니다. 이렇게 하면 후속 로직에서 성공/실패를 일관되게 처리할 수 있습니다.

  3. **`useCards` 훅 생성:**  
     - TanStack Query의 `useQuery` 훅을 사용하여 카드 목록을 불러오는 `useCards` 커스텀 훅을 만듭니다.  
     - 쿼리 키는 `['cards', { filters... }]` 형식으로 정의하고(필요한 경우 필터 객체 포함), `queryFn`으로 앞서 구현한 `cardService.fetchCards` 함수를 호출합니다.  
     - 적절한 `staleTime`(데이터 신선도 유지 시간)이나 `cacheTime`(캐시 보존 시간)을 설정하여 캐싱 전략을 조정하고, 필요 시 Query Options를 통해 오류 재시도 횟수, 배경 리프레시 등의 동작을 정의합니다.

  4. **`useCard` 훅 생성 (단일 카드 조회):**  
     - 단일 카드의 상세 정보를 불러오는 `useCard` 훅을 구현합니다. 내부적으로 `useQuery`를 사용하며, `queryKey`는 `['card', cardId]` 형태로 설정합니다.  
     - `queryFn`으로 `cardService.fetchCardById`를 호출하고, `enabled` 옵션을 활용하여 `cardId` 값이 유효할 때만 쿼리가 실행되도록 합니다. (예: `cardId`가 `undefined`인 경우 쿼리 비활성화)

  5. **`CardList` 컴포넌트 리팩토링:**  
     - 기존에 `useEffect` 등을 통해 카드 목록을 불러오고 있었다면 해당 로직을 제거합니다.  
     - 대신 신규 `useCards` 훅을 사용하여 카드 데이터 리스트와 로딩/에러 상태를 가져옵니다. 컴포넌트에서는 `useCards`가 반환하는 `data`, `isLoading`, `error`를 활용해 UI를 렌더링합니다.  
     - 로딩 중일 때 로딩 표시, 에러 발생 시 메시지 표시 등의 UI 처리를 `useCards`의 상태를 기반으로 업데이트합니다.  

* **검증 방법:**
  - `CardList` 컴포넌트를 렌더링했을 때, 화면에 카드 목록이 정상 표시되는지 확인합니다. (필요하다면 여러 개의 카드 시드 데이터를 사전에 넣어둡니다.)  
  - React Query DevTools를 열어 `['cards']` 키를 가진 쿼리가 존재하고, 상태가 fetching->success로 변하며 데이터가 캐시에 저장되는 것을 확인합니다.  
  - 네트워크 탭이나 서버 로그를 확인하여, 카드 목록 조회 요청이 컴포넌트가 아닌 `cardService.ts` 내에서 이루어지는지를 검증합니다. (예: 네트워크 요청 URL과 서비스 함수 정의를 대조)  
  - 카드 목록이 로딩 중일 때 로딩 UI가 나타나고, 오류 상황을 재현(예: 네트워크 끊김 등)하여 에러 UI가 올바르게 표시되는지 확인합니다.

### 3단계: Card 뮤테이션(생성, 수정, 삭제) 적용

* **목표:** 카드 생성(Create), 수정(Update), 삭제(Delete) 기능을 TanStack Query의 `useMutation`으로 구현하고, 관련 UI 컴포넌트를 이에 맞게 리팩토링합니다. 이를 통해 서버상 카드 데이터 변경 시 전역 상태를 자동으로 갱신하고, 이전 단계에서 제거한 전역 스토어의 카드 조작 로직을 대체합니다.

* **세부 단계:**
  1. **`useCreateCard` 뮤테이션 훅 생성:**  
     - TanStack Query의 `useMutation` 훅을 사용하여 카드 생성 기능을 구현합니다.  
     - `mutationFn`으로 앞서 만든 `cardService.createCardAPI` 함수를 지정합니다. 이 함수는 서버에 카드 생성 요청을 보내고 결과를 반환합니다.  
     - `onSuccess` 콜백을 설정하여, 카드 생성이 성공하면 `queryClient.invalidateQueries(['cards'])`를 호출함으로써 **카드 목록 캐시**를 무효화합니다. 이렇게 하면 신규 카드가 목록에 즉시 반영되도록 `useCards` 쿼리가 재실행됩니다.  
     - (Optional) 낙관적 업데이트를 고려할 수 있으나, 초기 구현에서는 생략하고 확실한 동기화에 집중합니다.

  2. **`useUpdateCard` 뮤테이션 훅 생성:**  
     - `useMutation`을 사용하여 카드 수정 기능을 구현합니다.  
     - `mutationFn`은 `cardService.updateCardAPI`를 호출하여 해당 카드의 변경사항을 서버에 전송합니다.  
     - `onSuccess`에서는 `queryClient.invalidateQueries(['cards'])`를 호출하여 카드 **목록** 데이터를 새로고침하고, 동시에 `queryClient.invalidateQueries(['card', cardId])`를 호출하여 **해당 카드 상세 데이터** 캐시도 무효화합니다. (만약 상세 조회를 어딘가에서 사용 중이라면 최신 내용 반영)  
     - (Optional) 필요 시 낙관적 업데이트를 구현하여 UI 반응성을 높일 수 있습니다.

  3. **`useDeleteCard` 뮤테이션 훅 생성:**  
     - `useMutation`을 사용하여 카드 삭제 기능을 구현합니다.  
     - `mutationFn`은 `cardService.deleteCardAPI`를 호출하여 서버에서 카드를 삭제합니다.  
     - `onSuccess`에서는 `queryClient.invalidateQueries(['cards'])`로 전체 목록을 갱신하고, 추가로 `queryClient.removeQueries(['card', cardId])`를 호출하여 삭제된 카드의 상세 캐시를 아예 제거합니다. (해당 카드 상세를 더 이상 사용할 일 없으므로 캐시에서 제거)  
     - (Optional) 낙관적 업데이트로, 삭제 요청을 보내기 직전에 로컬 목록에서 미리 제거하는 처리도 고려할 수 있습니다.

  4. **관련 컴포넌트 리팩토링:**  
     - **카드 생성 Modal** (예: `CreateCardModal`): 폼 제출 시 기존 전역 상태를 업데이트하는 대신 `useCreateCard` 훅을 사용하여 카드 생성 뮤테이션을 실행하도록 변경합니다. 폼 입력값을 훅의 `mutate` 함수에 전달하고, 로딩/성공/실패 상태에 따라 UI 피드백을 표시합니다 (TanStack Query가 `isLoading`, `isSuccess`, `isError` 상태를 제공하므로 이를 활용).  
     - **카드 편집 폼** (예: `EditCardForm` 또는 `EditCardModal`): 제출 시 `useUpdateCard` 훅의 `mutate`를 호출하여 업데이트를 수행하도록 수정합니다.  
     - **카드 삭제 버튼** (예: `DeleteButton` 컴포넌트): 클릭 시 `useDeleteCard` 훅의 `mutate`를 호출하여 삭제를 수행하도록 합니다. 삭제 확인 모달 등이 있는 경우 그 로직 안에서 호출되도록 조정합니다.  
     - **CardList**: 만약 카드 리스트 내에서 개별 카드 삭제를 수행한다면, 각 아이템에 `useDeleteCard`의 `mutate`를 연결하여 삭제 기능을 동작시킵니다.

  5. **전역 스토어의 Card 관련 액션 제거:**  
     - 기존 `useAppStore` 등에 카드 생성/수정/삭제를 처리하던 액션(`createCard`, `updateCard`, `deleteCard` 등)이 있었다면 모두 제거합니다. 이제 해당 기능은 TanStack Query 훅을 통해 수행되므로, 전역 상태에는 더 이상 서버 데이터 변경 로직이 필요하지 않습니다.

* **검증 방법:**
  - **카드 생성:** 카드 생성 UI에서 새로운 카드를 추가했을 때, `useCreateCard`의 `mutate`가 호출되고 성공 후 자동으로 카드 목록에 해당 카드가 나타나는지 확인합니다. (네트워크 요청과 화면 업데이트를 검사)  
  - **카드 수정:** 임의의 카드를 편집 후 저장했을 때, `useUpdateCard`의 `onSuccess`로 인해 목록 및 카드 상세 데이터가 최신 값으로 반영되는지 확인합니다. 필요한 경우 편집 전후 데이터를 비교합니다.  
  - **카드 삭제:** 카드 삭제 액션을 실행하면 `useDeleteCard`가 호출되고 성공 시 목록에서 즉시 해당 카드가 사라지는지 확인합니다. (데이터가 많을 경우 정확한 카드가 제거되었는지 인덱스 등을 확인)  
  - React Query DevTools를 통해 각 뮤테이션의 상태 변화(loading -> success 등)와, 성공 시 캐시 무효화가 일어나는지(해당 쿼리 목록이 refetch되거나 제거되는지) 관찰합니다.  
  - `useAppStore` 등에서 카드 CRUD 관련 액션이 완전히 제거되어 있는지 코드 확인을 통해 검증합니다.

### 4단계: Tag 관리 리팩토링 (2~3단계와 동일 패턴)

* **목표:** 태그(Tag) 데이터 관리 로직을 2~3단계에서 구축한 **TanStack Query + 서비스 계층 패턴**으로 리팩토링합니다. 태그 목록 조회, 생성, 삭제를 전역 상태에서 분리하여 React Query 기반으로 전환합니다.

* **세부 단계:**
  1. **Tag 서비스 함수 구현 (`src/services/tagService.ts`):**  
     - 태그 관련 API 호출 함수를 작성합니다. 예: `fetchTags()` – GET `/api/tags` (태그 목록 조회), `createTagAPI(data)` – POST `/api/tags` (새 태그 생성), `deleteTagAPI(id)` – DELETE `/api/tags/[id]` (태그 삭제) 등을 구현합니다. 필요 시 Zod 검증 및 표준 응답 형식을 적용합니다.

  2. **TanStack Query 훅 생성:**  
     - `useTags` 훅: `useQuery`를 사용하여 태그 목록을 불러옵니다 (`queryKey: ['tags']` 등으로 설정하고 `tagService.fetchTags` 호출).  
     - `useCreateTag` 훅: `useMutation`을 사용하여 태그 생성 기능 구현 (`mutationFn: tagService.createTagAPI`). 성공 시 `invalidateQueries(['tags'])`로 태그 목록을 갱신합니다.  
     - `useDeleteTag` 훅: `useMutation`으로 태그 삭제 기능 구현 (`mutationFn: tagService.deleteTagAPI`). 성공 시 `invalidateQueries(['tags'])`로 목록을 갱신합니다.

  3. **관련 컴포넌트 리팩토링:**  
     - 태그 목록을 표시하는 `TagList` 컴포넌트는 `useTags` 훅에서 데이터 및 로딩 상태를 받아 사용하도록 변경합니다.  
     - 태그 생성 폼이나 모달(`TagForm` 등)은 `useCreateTag`를 이용하여 새 태그 추가를 처리하도록 수정합니다.  
     - 태그를 삭제하는 UI (`TagItem` 내 삭제 버튼 등)는 `useDeleteTag`를 사용하여 처리하도록 합니다.  
     - 태그 필터 컴포넌트(`TagFilter`) 등 태그 데이터를 사용하는 다른 컴포넌트도 모두 새로운 훅에서 데이터를 공급받도록 업데이트합니다.

  4. **전역 스토어의 Tag 액션 제거:**  
     - 기존에 전역 Zustand 스토어 등에서 태그 추가/삭제 기능을 담당하던 부분이 있다면 삭제합니다. (예: `addTag`, `removeTag` 같은 액션)

* **검증 방법:**
  - 태그 **목록 조회/표시**: 태그 화면 또는 태그 드롭다운 등에서 `useTags`로 가져온 태그 리스트가 정상 표시되는지 확인합니다.  
  - 태그 **생성**: 새로운 태그를 추가했을 때 `useCreateTag`가 호출되고 성공 후 태그 리스트 UI에 바로 반영되는지 확인합니다.  
  - 태그 **삭제**: 태그 삭제 동작 시 `useDeleteTag`가 호출되고 성공 후 목록에서 해당 태그가 사라지는지 확인합니다.  
  - React Query DevTools로 태그 관련 쿼리/뮤테이션의 상태 변화를 모니터링하고, 캐시가 의도대로 업데이트되는지 확인합니다. (예: tags 쿼리의 last updated 시간이 갱신되는지 등)

### 5단계: Zustand 전역 스토어 슬라이스 리팩토링 (UI 상태 집중)

* **목표:** 전역 상태 관리 라이브러리인 Zustand 스토어(`useAppStore`)를 **슬라이스 패턴**으로 재구성하여, 오직 **클라이언트 UI 상태** 관리에 집중하도록 개선합니다. 이를 통해 서버 데이터와 관련된 상태는 제거하고 UI 상태의 논리만 남겨 명확성을 높입니다.

* **세부 단계:**
  1. **`useAppStore` 슬라이스 분리 및 구현:**  
     - `createUiSlice`: 사이드바 열림/닫힘 상태와 같은 전역 UI 상태를 관리하는 슬라이스를 만듭니다. 예를 들어 `isSidebarOpen` (불리언), 이를 변경하는 `setSidebarOpen` 및 토글 함수 `toggleSidebar`를 정의합니다. 추가로 사이드바 너비 `sidebarWidth`와 이를 변경하는 `setSidebarWidth` 등을 포함할 수 있습니다.  
     - `createCardStateSlice`: 선택된 카드나 카드 펼침 상태 등을 관리하는 슬라이스입니다. 예를 들어 다중 선택된 카드 ID 배열 `selectedCardIds`, 현재 확장(상세보기)된 카드 ID `expandedCardId` 등을 상태로 가지고, 이에 대한 액션으로 `selectCards` (선택 설정), `toggleExpandCard` (카드 상세 보기 토글), `clearSelectedCards` (선택 초기화) 등을 구현합니다. 이때 기존에 단일 카드 선택을 나타내던 `selectedCardId` 상태는 제거하고, 다중 선택 배열로 통합합니다. (필요하다면 단일 선택 편의를 위해 getter 함수를 제공할 수 있습니다.)  
     - `createThemeSlice`: 기존 `ThemeContext`에서 다루던 테마 설정 관련 상태를 이전합니다. 예를 들어 현재 테마 모드(`theme`), 노드 크기 등의 UI 설정값과 `updateTheme`, `updateNodeSize` 등의 액션을 정의합니다.  
     - (Optional) `createWindowCommandSlice`: 개발 환경 전용으로 사용했던 `window.appCommand` 관련 상태가 있다면, 이를 관리하는 슬라이스를 추가로 정의할 수 있습니다. (다만 이 부분은 개발 편의를 위한 것이므로 필요시에만 유지)

  2. **루트 스토어 결합:**  
     - `src/store/useAppStore.ts`에서 `create` 함수를 이용해 각 슬라이스를 통합하여 하나의 Zustand 스토어를 생성합니다. 각 슬라이스로부터 초기 상태와 액션을 받아와 스토어의 상태를 구성합니다. TypeScript를 사용하는 경우 각 슬라이스의 타입들을 합쳐 루트 스토어의 타입을 정의합니다.

  3. **`ThemeContext` 제거:**  
     - 이제 테마 관련 상태는 `useAppStore`의 `themeSlice`에서 관리하므로, 기존 React Context로 구현된 `ThemeContext` 및 `ThemeProvider`를 제거합니다.  
     - 어플리케이션 전역을 감싸던 `ThemeProvider`를 제거하고, 해당 컨텍스트를 사용하던 컴포넌트들은 모두 `useAppStore`의 테마 상태와 액션을 사용하도록 수정합니다.

  4. **기존 `useAppStore` 사용처 업데이트:**  
     - 컴포넌트들이 더 이상 옛 `useAppStore` 구조에 의존하지 않도록, 상태 접근 코드를 모두 새로운 슬라이스 기반 구조로 변경합니다. 예를 들어, 사이드바 열림 상태를 사용하던 컴포넌트는 `useAppStore(state => state.isSidebarOpen)` 형태로 변경하고, 액션 호출 부분도 `useAppStore(state => state.toggleSidebar())` 등으로 업데이트합니다.  
     - 마찬가지로 카드 선택이나 테마 관련 상태를 참조하던 부분도 각각 `cardStateSlice`, `themeSlice`의 상태/액션을 사용하는 코드로 변경합니다.

* **검증 방법:**
  - 사이드바 열기/닫힘, 너비 조절 등의 UI 기능을 테스트하여 `useAppStore`의 `uiSlice`로 잘 동작하는지 확인합니다. (토글 함수 호출 시 사이드바 컴포넌트 상태 변경 확인)  
  - 카드 선택 및 카드 상세보기 토글이 `cardStateSlice`의 상태를 통해 이루어지는지 확인합니다. (여러 카드를 선택하고 `selectedCardIds`의 변화 확인 등)  
  - 테마 변경이나 노드 크기 변경 등의 기능이 `themeSlice` 상태 값을 변경하고 해당 값이 UI에 반영되는지 확인합니다.  
  - React Developer Tools 또는 Zustand의 DevTools 미들웨어를 사용하여, `useAppStore`의 상태 구조에 `ui`, `cardState`, `theme` 등의 슬라이스가 포함되어 있는지 확인합니다.  
  - `ThemeContext` 관련 import나 사용처를 모두 제거했는지 프로젝트 전체 검색을 통해 검증합니다.

### 6단계: IdeaMap 상태 관리 최적화 및 동기화 로직 분리

* **목표:** `useIdeaMapStore`의 책임을 명확히 하고 IdeaMap 관련 데이터 흐름을 개선합니다. React Flow 기반의 **IdeaMap UI 상태**와 **데이터 동기화 로직**을 분리하여 각각 관리합니다. 이를 통해 IdeaMap (마인드맵) 기능의 복잡도를 줄이고 유지보수를 쉽게 합니다.

* **세부 단계:**
  1. **`useIdeaMapStore` 리팩토링:**  
     - `useIdeaMapStore`는 순수 UI 상태만 다루도록 수정합니다. 예를 들어:  
       - React Flow 인스턴스 객체 (`reactFlowInstance`), 뷰포트 상태 (`viewport` 위치 및 줌 레벨), 현재 표시 중인 노드/엣지 배열 (`nodes`, `edges` - 이 값들은 React Flow 컴포넌트에 직접 전달됨) 등을 상태로 유지합니다.  
       - 이러한 상태를 변경하는 액션들 (`setNodes`, `setEdges`, `onNodesChange`, `onEdgesChange`, `setViewport` 등)도 함께 정의합니다. 특히 `onNodesChange`, `onEdgesChange`는 React Flow에서 노드나 엣지의 변화를 Zustand 상태에 반영하는 핸들러로 사용됩니다.  
       - **중요:** 노드/엣지의 데이터 로딩, 저장, 변환 등 **비주얼라이제이션을 위한 가공 로직**은 모두 제거합니다. (예: 서버에서 불러온 카드 데이터를 노드로 변환하여 `nodes`에 넣는 등의 작업은 여기서 하지 않음)

  2. **`useIdeaMapSync` 훅 생성:**  
     - IdeaMap의 데이터를 동기화하고 변환해주는 새로운 커스텀 훅 `useIdeaMapSync`를 작성합니다. 이 훅은 TanStack Query와 Zustand 상태를 모두 구독하여, **서버 데이터**와 **로컬 UI 상태**를 결합합니다.  
     - 예를 들어 `useIdeaMapSync` 내부에서 `useCards` 훅을 사용하여 **서버의 카드 리스트**를 가져오고, (만약 엣지 정보도 서버에 있다면) `useEdges`와 같은 훅 또는 다른 방식으로 엣지 정보를 가져옵니다. 만약 엣지나 기타 정보가 전적으로 클라이언트에만 있다면 해당 Zustand나 localStorage로부터 상태를 읽어옵니다.  
     - 이렇게 수집한 **서버 데이터 (예: 카드 목록)**와 **로컬 레이아웃 데이터**(예: 각 노드의 좌표나 배치 상태)를 결합하여, React Flow 컴포넌트가 필요로 하는 `nodes` 및 `edges` 배열을 생성합니다. 이를 위해 미리 작성된 유틸리티 함수 (`cardsToCardNodes` 등)가 있다면 활용하여, Card 데이터 -> Node 데이터 구조 변환을 수행합니다. 최종적으로 이 훅은 계산된 `nodes`와 `edges` 배열을 반환합니다.  
     - 추가로, 카드 데이터가 변동될 경우 (`useCards` 결과가 업데이트될 때) 자동으로 새로운 노드 배열을 계산하도록 하고, 필요하다면 React Flow의 노드 ID를 일정하게 유지하여 UI 변경을 최소화합니다.

  3. **`useIdeaMapInteractions` 훅 생성:**  
     - IdeaMap에서 발생하는 사용자 **상호작용(event) 처리 로직**을 모아서 관리하는 `useIdeaMapInteractions` 훅을 만듭니다.  
     - 예를 들어 노드 또는 빈 화면을 **클릭**했을 때 실행되는 핸들러, 노드 **드래그앤드롭**(Drag & Drop)으로 새 카드를 생성하는 기능, 노드 간 **연결**(Edge connect) 이벤트 처리 등을 이 훅에 모두 포함시킵니다.  
     - 구현 세부: 노드(또는 빈 곳) 클릭 시 선택한 카드를 전역 선택 상태로 반영하기 위해 `useAppStore`의 `cardStateSlice` 액션 (예: `selectCards` 또는 `clearSelectedCards`)를 호출합니다. 노드를 드롭(드래그 후 놓기)하는 동작이 새로운 카드 생성을 의미한다면, `useCreateCard` 뮤테이션 훅을 호출하여 서버에 카드 생성 요청을 보냅니다. 노드 간 연결(Edge 생성)은 엣지 데이터가 서버 상태일 경우 `useCreateEdge`와 같은 뮤테이션을 호출하여 서버에 저장하고, 아닐 경우 로컬 상태에 바로 반영합니다.  
     - 이 훅은 위와 같은 여러 상호작용 핸들러들을 반환하여, IdeaMap 관련 컴포넌트에서 사용할 수 있도록 합니다.

  4. **`useIdeaMapLayout` 훅 생성:**  
     - 자동 레이아웃 및 레이아웃 저장 관련 로직을 모은 `useIdeaMapLayout` 훅을 생성합니다.  
     - 예를 들어 그래프의 자동 정렬을 수행하는 `getLayoutedElements`나 그리드 배치를 계산하는 `getGridLayout` 등의 유틸 함수가 있다면 이 훅 내부에서 호출하고, 현재 `nodes`, `edges` 상태에 적용하는 함수를 제공합니다.  
     - 또한 사용자의 레이아웃 변경사항(노드 위치 변동 등)을 저장하고 이후 복원하는 로직도 이 훅에서 다룹니다. (필요하면 Zustand persist 기능이나 localStorage 직접 활용)

  5. **`IdeaMap.tsx` 컴포넌트 리팩토링:**  
     - IdeaMap 화면을 구현하는 `IdeaMap.tsx` 컴포넌트에서, 앞서 정의한 훅들을 적극 활용하도록 리팩토링합니다.  
     - 데이터 관련 로직: `useIdeaMapSync` 훅을 호출하여 계산된 `nodes`와 `edges` 데이터를 얻습니다. 이 값을 React Flow의 노드/엣지 프로퍼티로 넘깁니다.  
     - 상태 관련 로직: `useIdeaMapStore` 훅을 사용하여 React Flow 인스턴스와 `onNodesChange`, `onEdgesChange` 등의 핸들러를 가져옵니다. 이 핸들러들은 React Flow 컴포넌트의 관련 속성(onNodesChange 등)에 연결합니다.  
     - 이벤트 처리 로직: `useIdeaMapInteractions` 훅을 사용하여 반환된 이벤트 핸들러들을 가져오고, 예를 들어 노드 클릭 이벤트에 연결하거나, 드롭 동작 시 해당 핸들러를 호출하도록 React Flow 컴포넌트의 props를 설정합니다.  
     - 결과적으로 `IdeaMap.tsx` 자체는 UI를 렌더링하고 각종 훅으로부터 받은 상태와 액션/핸들러를 React Flow 컴포넌트에 연결하는 역할에 집중하게 됩니다.

  6. **`useNodeStore` 제거:**  
     - 만약 기존에 노드 상세보기(Inspector) 관련 상태를 관리하던 `useNodeStore` 같은 별도 Zustand 스토어가 있었다면, 이를 제거하거나 `useIdeaMapInteractions`/필요 시 새로운 훅 (`useNodeInspector` 등)에 통합합니다. 예를 들어, 노드를 선택하면 해당 노드의 상세 정보를 담는 상태는 단순히 React state나 context로 처리해도 될 정도로 국소적일 수 있으므로, 복잡하지 않다면 `IdeaMap.tsx` 내의 `useState`로 대체하는 것도 고려합니다.  

* **검증 방법:**
  - IdeaMap 화면에 접속했을 때 **서버의 카드 데이터가 노드로 변환**되어 올바르게 렌더링되는지 확인합니다. (예: 카드 제목이 노드 label로 보이는지 등)  
  - 노드를 클릭하거나 영역을 클릭하여 **카드 선택 상태**가 전환될 때, `useAppStore`의 `selectedCardIds` 값이 변화하고 사이드바 등 다른 UI 컴포넌트에서도 그 변화에 따라 선택된 카드 정보가 표시되는지 확인합니다.  
  - IdeaMap에서 노드를 드래그하여 빈 화면에 놓았을 때 **새 카드가 생성**되는 흐름이 잘 작동하는지 확인합니다. (노드가 생성됨과 동시에 서버에도 카드 생성 호출이 되었는지 네트워크 확인)  
  - 노드 두 개를 연결하여 엣지를 만들었을 때, 엣지 상태가 정상 업데이트되고 (서버 저장 또는 로컬 상태 반영) 새 엣지가 화면에 나타나는지 확인합니다.  
  - 자동 레이아웃 기능을 UI에서 트리거했을 때 `useIdeaMapLayout`을 통해 노드 위치가 재배치되고 결과가 화면에 반영되는지 확인합니다.  
  - 코드 레벨로 `useIdeaMapStore`에 **데이터 로딩/변환 로직이 남아있지 않고**, 온전히 UI 상태만 관리하는지 확인합니다. (예: `useIdeaMapStore`에 서버 호출이나 변환 관련 코드 X)  
  - `useNodeStore` 관련 코드가 제거되었거나 더 이상 참조되지 않음을 코드 검색 등을 통해 검증합니다.

### 7단계: 공통 타입 정의 통합 및 코드 정리

* **목표:** 리팩토링 마무리 단계로서, 코드베이스 전반의 **중복/불필요 코드**를 제거하고, 모든 중요한 **타입 정의를 일관되게 정비**합니다. 이를 통해 코드를 깨끗하게 정리하고 타입 안정성을 높여 이후 유지보수와 협업을 용이하게 합니다.

* **세부 단계:**
  1. **불필요한 파일/코드 제거:**  
     - 더 이상 사용되지 않는 과거 스토어 파일들 (예: 제거된 `useNodeStore` 등)이나 Context 파일(`AuthContext` 등), 그리고 이전 구조에서 쓰였던 훅/유틸리티 중 현재 구조에 필요 없는 것들을 삭제합니다.  
     - 또한 사용되지 않는 API Route 핸들러(예: `/api/users/first` 등 테스트 목적으로 만들었던 엔드포인트)가 있으면 제거합니다. 이 때 혹시 참조되는 곳이 남아있지 않은지 함께 확인합니다.

  2. **타입 정의 통합 (`src/types`):**  
     - `src/types` 폴더 내에 흩어져 있거나 중복된 타입 정의가 있다면 하나로 통합하고, 명확한 이름으로 정리합니다. Card, Tag, User, Project와 같은 **도메인 객체 타입**과, 서비스 계층에서 사용하는 **API 요청/응답 타입**, Zustand **스토어 슬라이스 타입** 등을 중앙에서 관리합니다.  
     - 예를 들어 Card의 타입을 `Card` 인터페이스로 정의하고, Tag는 `Tag`, User는 `UserProfile` 등으로 정의한 뒤 프로젝트 전역에서 해당 타입을 사용하도록 합니다.  
     - 타입 정의 정리가 끝나면, 프로젝트 전체를 **타입체크(컴파일)**하여 타입 에러가 없는지 확인하고, any나 unknown으로 남은 부분은 없는지 점검합니다.

  3. **설정/상수 파일 정리:**  
     - `src/constants` 또는 `src/config` 등 폴더에 여러 상수나 설정 값들이 존재한다면, 유사한 성격끼리 합치거나 구조를 개선합니다.  
     - 예를 들어 API 관련 엔드포인트 상수가 여러 군데 산재해 있다면 한 곳으로 모으고, 테마 관련 상수는 themeSlice에서만 쓰이면 그쪽으로 이동시키는 등 **응집도**를 높입니다.  
     - 환경 변수(.env) 사용 여부도 확인하고, 기존 코드에서 하드코딩된 URL이나 키 등이 있다면 적절히 `.env`로 옮겨 관리하도록 정리합니다.

* **검증 방법:**
  - 프로젝트 전역 **검색**을 통해, 1) 삭제 대상으로 정한 파일/코드가 정말로 참조되고 있지 않은지 확인합니다. (IDE의 “Find All References” 기능 등 활용)  
  - `npm run build` 또는 `next build` 등을 수행하여 프로젝트가 정상적으로 빌드되는지 확인합니다. 빌드 에러가 발생하면 제거한 코드와 연관된 부분이 남아있는지 재검토합니다.  
  - 타입스크립트 컴파일을 수행하거나 IDE의 타입체크에서 에러가 발생하지 않는지 확인합니다. 특히 통합한 타입 정의들이 올바르게 참조되는지, 누락된 곳은 없는지 살펴봅니다.  
  - 애플리케이션을 실제로 실행하여 주요 기능(로그인, 카드/태그 CRUD, IdeaMap 렌더링 등)이 여전히 정상 동작하는지 테스트합니다. (코드 정리 과정에서 기능이 망가지지 않았는지 확인)

### 8단계: 최종 정리 및 문서화

* **목표:** 리팩토링 완료 시점에서 아키텍처에 대한 기록을 남겨 팀 내 공통 이해를 돕습니다. 전체 코드베이스를 한 번 더 점검하며, **아키텍처 문서**를 작성하고 최종 정리를 수행합니다.

* **세부 단계:**
  1. **아키텍처 문서 작성:**  
     - 본 리팩토링의 결과로 확립된 아키텍처에 대해 정리된 문서를 작성합니다. (하단 [부록]에 초안을 작성) 문서에는 상태 관리 원칙, 쿼리 키 구성 전략, 서비스 계층 역할, 인증 흐름, 데이터 흐름(예시 포함), 컴포넌트와 상태간 역할 구분, 테스트 전략, AI 협업 가이드 등을 포함합니다.  
     - 특히 Next.js **Server Actions**와 기존 API Routes를 혼용하는 하이브리드 구조에 대해서도 설명하여, 내부적으로 서버 액션을 어떻게 활용하고 외부 공개 API는 어떻게 유지하는지 명시합니다.

  2. **최종 코드 및 기능 점검:**  
     - 전체 애플리케이션을 빌드 및 실행하여 **런타임 에러**가 전혀 없는지 확인합니다. 개발 모드뿐 아니라 프로덕션 빌드로도 테스트합니다.  
     - 콘솔 경고나 오류(log)도 모두 확인하여 잔여 이슈가 없는지 확인합니다. (예: React Strict Mode 경고, deprecated API 사용 등)  
     - 주요 시나리오에 대한 수동 테스트를 한번씩 진행합니다 (카드/태그 CRUD, 드래그앤드롭으로 카드 생성, 로그인 및 인증 유지 등).

  3. **문서와 실제 구현 일치 확인:**  
     - 작성한 아키텍처 문서를 팀원(또는 시니어)의 리뷰를 받아 실제 최종 코드 구조와 어긋나는 부분이 없는지 확인합니다. 예를 들어 문서에 기술된 쿼리 키 전략과 코드 구현이 다르지 않은지, 데이터 흐름 설명이 실제 동작과 일치하는지 점검합니다.  
     - 문서의 표현이 명확한지, 초급 개발자나 AI 에이전트가 읽고 바로 이해할 수 있을 정도로 구체적인지 검토합니다. 필요한 수정이나 보완이 있다면 이 단계에서 반영합니다.

* **검증 방법:**
  - `npm run build` 명령을 실행하여 프로젝트가 성공적으로 빌드되는지 확인합니다. 빌드 성공은 정적 타입 검사와 번들링이 모두 통과되었음을 의미합니다.  
  - 개발 서버를 띄운 뒤 여러 기능을 탐색하며 콘솔에 오류가 나타나지 않는지 모니터링합니다.  
  - 동료 개발자에게 아키텍처 문서를 검토받아, 문서 내용만으로도 이번 리팩토링의 구조와 원칙을 이해할 수 있다는 피드백을 받습니다.  
  - 최종적으로 Git 등의 버전관리 이력을 통해 1~8단계에서 intended한 변경사항들이 모두 반영되었는지 확인하고 리팩토링 작업을 마무리합니다.

## 4. 리팩토링 이후 작업

리팩토링이 완료된 이후 고려하거나 진행할 추가 작업들입니다. 이는 새로운 기능 개발이나 운영 개선 사항으로, 우선순위에 따라 추후 진행합니다.

- **데이터베이스 초기화 로직 개선:** 현재 개발 환경에서 데이터베이스를 초기화하는 `db-init.ts` 스크립트 등을 Prisma의 마이그레이션 및 시딩(seeding) 기능으로 대체하는 것을 검토합니다. 이를 통해 초기 데이터 세팅을 보다 표준화하고 자동화합니다.

- **"프로젝트" 기능 구현:** 기존 카드/태그를 여러 프로젝트로 분류하고 관리할 수 있는 기능을 추가합니다. 새로운 데이터 모델(Project 엔터티)을 정의하고, 해당 프로젝트 생성/수정 API, 서비스 함수, TanStack Query 훅, UI 컴포넌트를 개발합니다. (이번에 구축된 아키텍처 패턴을 따라 구현)

- **로깅 전략 재정의 및 구현:** 애플리케이션 전반의 로깅 시스템을 정비합니다. 예를 들어 Sentry나 Logtail 같은 중앙 집중식 로깅 서비스를 도입하고, 클라이언트 및 서버의 로그 레벨과 포맷을 표준화합니다. 오류 발생 시 충분한 정보를 로그에 남기고, 필요하면 사용자에게 피드백을 제공하는 체계를 마련합니다.

- **에러 핸들링 강화:** API 응답 에러나 비동기 작업 에러에 대한 처리를 일관성 있게 개선합니다. 서비스 계층에서 발생하는 에러는 적절히 throw하여 상위에서 캐치하고, 컴포넌트에서는 TanStack Query의 `error` 상태를 활용해 사용자에게 메시지를 보여줍니다. 또한 전역 에러 Boundary를 구현하여 치명적인 오류에 대한 공통 처리 (사용자 안내, 로그 전송 등)를 고려합니다.

- **React Flow 성능 최적화:** IdeaMap 내 많은 노드/엣지를 렌더링할 경우 성능이 저하되지 않도록 최적화 작업을 진행합니다. 예를 들어 가상 스크롤/렌더링 기법 도입, 복잡한 노드 컴포넌트의 메모이제이션, Canvas 상에서의 레이어링 최적화 등을 검토합니다.

- **Undo/Redo 기능 구현:** 사용자의 작업 이력을 추적하여 실행 취소(Undo) 및 다시 실행(Redo)를 지원합니다. Zustand의 middleware(예: redux-devtools나 `zustand/middleware`의 `undoStore`)를 활용하거나 별도의 상태 관리 전략을 도입하여, 카드/태그 추가 삭제, 위치 변경 등의 작업을 되돌릴 수 있도록 합니다.

- **Read-Only/뷰 모드 제공:** 특정 URL 파라미터나 별도 모드로 애플리케이션을 **읽기 전용(뷰어) 모드**로 동작시키는 기능을 추가합니다. 이를 통해 수정 권한이 없는 사용자는 객체 생성이나 수정, 드래그앤드롭 등이 비활성화된 상태로 콘텐츠를 볼 수 있게 합니다.

- **테스트 커버리지 확대:** 리팩토링된 아키텍처를 기반으로 핵심 로직에 대한 단위 테스트와 통합 테스트를 작성하여 품질을 보증합니다. 예를 들어 서비스 함수의 반환값 검증 테스트, Zustand 슬라이스의 동작 테스트, 주요 훅 및 컴포넌트에 대한 렌더링/상호작용 테스트 등을 추가합니다.

## [부록] 아키텍처 문서 초안

> **Note:** 아래 내용은 이번 리팩토링을 통해 정의된 Backyard 프로젝트의 아키텍처를 정리한 초안입니다. 개발팀과 AI 에이전트가 참고하여 일관된 코드 작성과 이해를 할 수 있도록, 핵심 개념과 패턴을 설명합니다.

### 상태 관리 구조: Server Actions + TanStack Query + Zustand

Backyard 애플리케이션은 **서버 상태**와 **클라이언트 상태**를 명확히 분리하고, 각 성격에 가장 적합한 기술을 혼용하여 사용합니다. **서버 액션(Server Actions)**, **TanStack Query (React Query)**, **Zustand**라는 세 가지 요소가 협력하여 효율적인 상태 관리 아키텍처를 구성합니다.

- **TanStack Query (React Query)** – **서버 상태** 관리의 중심축입니다. 서버에서 가져오는 데이터 (예: 카드 목록, 태그 등)는 모두 TanStack Query를 통해 패치되고 캐싱됩니다. TanStack Query는 원격 데이터의 fetching, caching, background update 등에 특화되어 있어, Zustand 등으로 직접 관리하기 번거로운 부분을 맡습니다. 권장되는 베스트 프랙틱스대로, **원격/서버 상태는 TanStack Query로 관리하고, 로컬/UI 상태는 Zustand로 관리**합니다 ([Zustand Meets React Query: The Perfect Pair for State Handling | by Chamith Madusanka | Feb, 2025 | Level Up Coding](https://chamith.medium.com/zustand-react-query-the-lightweight-duo-for-state-management-271c5454a956#:~:text=While%20Zustand%20is%20great%20for,state%20and%20local%20state%20logic)). 서버 데이터의 변경(create/update/delete)도 `useMutation`을 통해 수행하며, 성공 시 관련 캐시를 invalidate/remove하여 UI를 최신으로 유지합니다.

- **Zustand** – **클라이언트 상태(UI 상태)** 관리에 사용됩니다. UI 열림/닫힘 상태, 입력 폼 모달 열림 여부, 현재 선택된 객체 ID, 테마 모드 등 **서버와 무관한 순수 프론트엔드 상태**를 보관합니다. Zustand는 가볍고 직관적인 API로 전역 상태를 관리할 수 있고, 슬라이스 패턴을 통해 여러 모듈로 분리하여 관리하고 있습니다. 이를 통해 서로 다른 UI 상태가 독립적으로 관리되고, 불필요한 리렌더를 방지합니다.

- **Next.js Server Actions** – Next.js 13에 도입된 기능으로, 클라이언트에서 직접 호출 가능한 **서버 사이드 함수**입니다. UI에서 발생한 특정 액션(예: 버튼 클릭으로 데이터 생성)을 처리할 때, API Route를 별도로 거치지 않고 서버 코드를 실행할 수 있습니다 ([Introduction to Next.js Server Actions](https://makerkit.dev/blog/tutorials/nextjs-server-actions#:~:text=Next,learn%20how%20to%20use%20them)). 우리 프로젝트에서는 **내부 UI 상호작용**(특히 데이터 변경)에 Server Action을 활용함으로써, 불필요한 HTTP 통신을 줄이고 보안/성능을 향상시킵니다. 예를 들어 카드 생성 시 클라이언트 컴포넌트에서 Server Action 함수를 바로 호출하면, 서버에서 DB에 쓰기 작업을 수행하고 결과를 반환받아 Query 캐시를 갱신할 수 있습니다. (TanStack Query의 `useMutation` 내에서 Server Action을 호출하는 형태로도 활용 가능)

이 세 가지 요소를 조합한 이유는 다음과 같습니다: 서버 액션과 React Query를 활용하면 **API 엔드포인트를 만들지 않고도** 데이터 변조를 처리할 수 있어 개발자 경험이 향상되고 불필요한 코드가 줄어듭니다. React Query는 자동으로 데이터를 캐싱/동기화하여 상태 일관성을 유지하고, Zustand는 UI 상태를 간결하게 관리합니다. 결과적으로 각 도구의 강점을 살려 애플리케이션 상태 관리의 복잡도를 낮추고 성능을 높입니다.

### 쿼리 키 전략

TanStack Query에서 **쿼리 키(Query Key)**는 캐싱과 데이터 동기화의 기준이 되므로, 일관된 규칙에 따라 설계합니다. 우리 프로젝트에서는 리소스 타입별로 고유한 1급 키를 부여하고, 필요한 경우 식별자나 필터 객체를 추가로 포함시키는 전략을 채택합니다.

- **리스트 쿼리의 키:** 엔터티 목록을 가져오는 쿼리는 복수형 키를 사용합니다. 예를 들어 카드 목록은 `['cards']`를 기본 키로 사용합니다. 만약 프로젝트별 카드 목록이나 특정 필터가 적용된 목록이 있다면 `['cards', projectId]` 또는 `['cards', { filter: 'recent' }]`처럼 2차 키를 추가합니다. 이로써 `invalidateQueries('cards')` 호출만으로 해당 유형의 모든 목록을 한꺼번에 무효화하거나, 특정 조건의 목록만 갱신할 수도 있습니다.

- **개별 아이템 쿼리의 키:** 단일 객체(아이템)를 가져오는 쿼리는 단수형 키와 식별자를 조합합니다. 예를 들어 특정 카드 상세 조회는 `['card', cardId]` 키를 사용합니다. 태그 상세 조회가 필요하다면 `['tag', tagId]`의 형태로 정의할 것입니다. 이 규칙을 통해 어떤 쿼리인지 키만 보고도 추측이 가능하고, 관련된 invalidate도 쉽게 관리됩니다.

- **중첩/의존 관계:** 가급적 쿼리 키는 **리소스 간 의존성을 반영**하도록 설계합니다. 예를 들어 카드가 속한 프로젝트 ID가 있다면 카드 목록 키에 프로젝트 ID를 포함함으로써, 프로젝트 변경 시 해당 카드 쿼리만 갱신할 수 있습니다. 마찬가지로 사용자별 데이터라면 사용자 ID를 키에 포함합니다.

- **키 상수 관리:** 쿼리 키 문자열('cards', 'card', 'tags', ...)은 `src/constants/queryKeys.ts`와 같이 상수로 관리할 수도 있습니다. 그러나 규모가 아주 크지 않은 현 단계에서는 파일 하나에 모아두기보다 각 훅 파일에서 직접 사용하되, 오탈자가 없도록 타입으로 관리하거나 테스트를 통해 검증합니다.

이러한 쿼리 키 전략을 따르면 데이터 변경 시 **정확한 범위의 캐시**만 무효화할 수 있고, 불필요한 네트워크 요청을 피하면서도 데이터 일관성을 유지할 수 있습니다. 실제로 본 프로젝트에서도 카드 생성/수정 후 `invalidateQueries(['cards'])`로 목록을 갱신하거나, 카드 수정 시 `invalidateQueries(['card', id])`로 상세를 갱신하는 식으로 활용하고 있습니다.

### API 서비스 계층 역할

**서비스 계층**(`src/services`)은 UI(컴포넌트/훅)와 API 혹은 데이터베이스 로직 간의 중간 다리 역할을 합니다. 주요 목표는 **데이터 요청/처리 로직의 재사용성과 테스트 용이성**을 확보하고, UI 코드로부터 비즈니스 로직을 격리하는 것입니다.

- 각 서비스 모듈(e.g. `cardService.ts`, `tagService.ts`)에는 해당 도메인 객체(Card, Tag 등)를 다루는 함수들이 모여 있습니다. 이 함수들은 RESTful API 엔드포인트 호출이나 Supabase/Prisma 클라이언트를 통한 DB 쿼리를 수행합니다.  
- 서비스 계층은 **입출력에 대한 표준화**를 제공합니다. 모든 함수는 내부적으로 try-catch나 오류 처리를 수행하고, 필요에 따라 **Zod 스키마**로 응답을 검증하여 예상치 못한 데이터 구조 변화에 대비합니다. 또한 통일된 반환 타입(예: `{ success, data, error }`)을 사용하여 상위에서 일관되게 처리할 수 있도록 합니다.  
- UI 레이어(React 컴포넌트나 TanStack Query 훅)는 이러한 서비스 함수를 통해서만 데이터에 접근합니다. 예를 들어 `useCards` 훅은 단순히 `cardService.fetchCards`를 호출하고 결과를 반환받는 역할만 합니다. 이로써 컴포넌트와 데이터 소스 간 결합도를 낮추고, 서비스 함수를 mock하여 **단위 테스트**를 작성하기도 쉬워집니다.  
- **중복 로직 제거:** 서비스 계층은 Server Action과 API Route 모두에서 활용됩니다. 동일한 작업을 수행하는 두 가지 경로(예: 카드 생성 Server Action 함수와 `/api/cards` POST 핸들러)는 모두 내부에서 `cardService.createCard`를 호출하도록 구현하면, 로직을 한 곳에만 유지할 수 있습니다.  
- 향후 새로운 엔터티나 API가 추가될 때도 서비스 레이어에 함수만 추가하면 되므로, 프로젝트 구조가 일관되게 확장됩니다. 또한 만약 데이터 소스가 Supabase에서 다른 백엔드로 변경되어도, 이 계층만 수정하면 되므로 **유연성**이 높습니다.

### 인증 구조

Backyard의 인증은 **Supabase 인증**을 기반으로 합니다. 리팩토링 후 인증 구성은 다음과 같습니다:

- **Supabase SSR (서버 사이드 인증):** Next.js 서버 측 렌더링 또는 Server Action에서 현재 사용자 세션을 파악하기 위해 Supabase의 SSR 지원을 사용합니다. Supabase의 세션 쿠키를 통해 사용자 인증정보가 전달되며, 서버 측에서 `createServerComponentClient` 등을 통해 현재 로그인한 사용자의 정보를 가져올 수 있습니다. 이 방식을 통해 클라이언트에서 토큰을 직접 관리할 필요가 없고, 페이지 전환이나 새로고침 시에도 로그인 상태를 유지할 수 있습니다.

- **클라이언트 인증 훅 (`useAuth`):** 클라이언트 컴포넌트에서는 Supabase 클라이언트 (`supabase-js`)의 `onAuthStateChange`를 구독하는 `useAuth` 훅을 제공합니다. 이 훅은 앱이 로드될 때 사용자의 세션을 확인하고, 로그인/로그아웃/토큰만료 등의 이벤트가 발생하면 콜백을 통해 상태를 갱신합니다. 반환하는 값은 현재 사용자 프로필 (또는 `null`), 로딩 상태, 에러 정보입니다.

- **Zustand 인증 스토어 (`useAuthStore`):** Zustand로 관리되는 `useAuthStore`는 인증과 관련된 최소한의 전역 상태만을 포함합니다. 예를 들어 현재 사용자 프로필 정보(`profile`), 로딩 여부(`isLoading`), 에러 메시지(`error`) 등이 있습니다. 이 스토어는 기본적으로 `useAuth` 훅과 연동되어 동작합니다. 즉, `useAuth`에서 인증 상태 변화 이벤트를 받으면 `useAuthStore`의 상태를 업데이트하는 식입니다.  
  기존에 존재했던 토큰 저장 로직은 모두 제거되었으며, Supabase 세션 쿠키가 **싱글 소스**로 작동합니다. 이렇게 함으로써 클라이언트와 서버가 동일한 인증 정보를 참고하고, 이중 관리로 인한 불일치를 없앴습니다.

- **AuthContext 제거:** 과거 버전에서 사용되던 React Context 기반의 AuthProvider 패턴은 삭제되었습니다. 대신 위에서 언급한 hook/store 조합으로 대체되었습니다. 컴포넌트가 인증 상태를 알아야 하면 `useAuthStore` (혹은 `useAuth`)를 직접 사용하면 됩니다. Context API를 경유하지 않으므로 더 단순하고, 필요시 Zustand를 통해 어느 컴포넌트에서나 접근할 수 있다는 장점이 있습니다.

- **인증 흐름 요약:** 사용자가 로그인을 시도하면 Supabase의 OAuth나 이메일 로그인 메소드가 호출되고, 성공 시 Supabase가 알아서 **HttpOnly 쿠키**에 세션을 저장합니다. 이후부터는 모든 요청에 해당 쿠키가 포함되어 있으므로, 서버 측에서 이를 사용해 사용자 식별이 가능합니다. 클라이언트 측에서는 `useAuth` 훅이 이 변화를 감지해 `useAuthStore.profile`에 사용자 정보를 채워주며, 로그아웃 시에도 마찬가지로 상태를 비웁니다.

이 구조의 이점은 **단순성과 일관성**입니다. Supabase가 인증을 책임지고, 프론트엔드는 최소한의 코드로 상태를 반영만 하면 됩니다. 또한 서버와 클라이언트가 동일한 세션 정보를 공유하므로 SSR 페이지나 Server Action에서도 별도 처리 없이 현재 사용자 컨텍스트를 활용할 수 있습니다.

### 주요 데이터 흐름 (예시)

아키텍처 개선으로 인한 데이터 흐름 변화를 이해하기 위해, **카드 생성**과 **IdeaMap 동기화** 두 가지 사례를 들어 설명합니다.

- **카드 생성 흐름:** 사용자가 카드 생성 폼에서 "저장"을 눌러 새 카드를 만들 때의 처리를 살펴보겠습니다.  
  1. **컴포넌트 레벨:** `CreateCardModal` 컴포넌트에서 폼 제출 이벤트를 처리할 때, 전역 상태를 직접 수정하는 대신 `useCreateCard` 뮤테이션 훅의 `mutate` 함수를 호출합니다. 이때 폼 입력 데이터를 인자로 넘겨줍니다.  
  2. **TanStack Query 뮤테이션:** `useCreateCard` 훅은 내부적으로 `mutationFn`으로 등록된 `cardService.createCardAPI`를 실행합니다. 이 함수는 `/api/cards` 엔드포인트로 POST 요청을 보내거나 (혹은 Server Action을 통해 직접 DB에 쓰거나) 새로운 카드를 생성합니다.  
  3. **서비스 계층:** `cardService.createCardAPI`는 카드 데이터 유효성을 검사한 뒤 Supabase/Prisma를 통해 DB에 레코드를 추가하고, 생성된 카드 객체(또는 성공 상태)를 반환합니다.  
  4. **응답 처리:** `useCreateCard`의 `onSuccess` 콜백이 호출되면서, 전역 카드 목록 쿼리(`['cards']`)를 invalidate합니다. React Query는 이 키에 해당하는 캐시를 stale 상태로 만들고, 화면에 보여지는 `CardList` 컴포넌트는 곧바로 새 데이터 fetch를 트리거합니다.  
  5. **화면 업데이트:** `CardList` 컴포넌트의 `useCards` 훅이 invalidation을 감지하고 `/api/cards`로부터 최신 카드 목록을 다시 받아옵니다. 거기에는 방금 추가된 카드가 포함되어 있고, 컴포넌트는 이를 렌더링하여 사용자에게 새 카드가 목록에 나타난 것을 보여줍니다.  
  6. **후속 처리:** 모달 컴포넌트는 생성 완료 후 닫히고, 필요하면 `useAppStore` 등을 통해 "성공" 알림 배너를 표시하거나 하는 처리를 합니다. (이 부분은 optional)

  이 흐름에서 주목할 점은, **컴포넌트가 직접 전역 상태를 건드리지 않고** TanStack Query의 뮤테이션/캐시 메커니즘을 활용했다는 것입니다. 그 결과 개발자는 별도로 "목록에 새 아이템 추가" 코드를 작성할 필요 없이, invalidate만으로 동기화가 이루어집니다. 또한 오류 발생 시에는 `useCreateCard` 훅 내 `onError`를 통해 통일된 에러 처리 (예: 토스트 메시지 표시 등)도 구현할 수 있습니다.

- **IdeaMap 데이터 동기화 흐름:** IdeaMap 화면은 서버의 카드/태그 데이터를 시각화하는 특수한 UI입니다. 여기서는 **서버 데이터와 로컬 상태의 결합**이 중요한데, 이를 우리 아키텍처에서는 `useIdeaMapSync` 훅으로 해결하고 있습니다.  
  1. **초기 로드:** 사용자가 IdeaMap 페이지를 열면, `IdeaMap.tsx`에서 `useIdeaMapSync` 훅이 실행됩니다. 이 훅은 내부적으로 `useCards` (카드 목록)와 `useTags`(태그 목록, 필요하면) 쿼리를 사용하여 서버로부터 최신 데이터를 가져옵니다. 동시에, 과거에 사용자가 배치해 둔 노드 위치나 화면 줌 레벨 등의 레이아웃 정보는 `useIdeaMapStore` (혹은 localStorage)을 통해 불러옵니다.  
  2. **데이터 결합:** `useIdeaMapSync`는 가져온 카드 리스트를 순회하며 각 카드 객체를 React Flow 노드 객체로 변환합니다. 이때 카드의 속성(id, content 등)은 노드의 `data` 필드에 저장되고, 좌표나 레이아웃 정보는 저장된 값을 이용합니다 (없을 경우 자동 배치). 변환 결과로 노드와 엣지 배열을 생성하여 훅의 반환값으로 제공합니다.  
  3. **UI 렌더:** `IdeaMap.tsx`는 `useIdeaMapSync`가 반환한 `nodes`와 `edges`를 React Flow 컴포넌트에 전달하여 그려지게 합니다. 초기 로드 시점에 TanStack Query가 데이터를 불러오는 동안에는 로딩 스피너를 보여줄 수도 있습니다. 데이터가 준비되면 React Flow가 노드/엣지를 렌더링합니다.  
  4. **실시간 반영:** 사용자가 다른 곳에서 카드를 추가하거나 편집하는 경우 (예: 사이드바 리스트에서), 혹은 다른 사용자가 협업 중 추가한 경우를 생각해볼 수 있습니다. TanStack Query의 장점은 서버 데이터가 변경되면 (혹은 refetch 트리거 시) `useCards` 쿼리가 새로운 데이터를 가져온다는 점입니다. 이때 `useIdeaMapSync`는 **Reactive**하게 동작하기 때문에 `useCards`의 결과 변화 → 노드 배열 재생성 → UI 갱신으로 이어집니다. 예를 들어 사이드바에서 카드 이름을 수정하면 `useUpdateCard` 뮤테이션 -> `invalidateQueries(['cards'])` -> `useCards` 데이터 갱신 -> `useIdeaMapSync` 재계산 -> React Flow 노드 라벨 업데이트, 순으로 **일관성 있는 데이터 뷰**가 유지됩니다.  
  5. **사용자 상호작용:** IdeaMap 내에서의 사용자 조작은 `useIdeaMapInteractions` 훅을 통해 관리됩니다. 사용자가 노드를 드래그하여 새로운 위치에 놓으면, `onNodesChange` 이벤트가 발생하고 이 이벤트를 `useIdeaMapStore`가 받아 노드 좌표를 업데이트합니다. 또한 이 변경사항은 `useIdeaMapLayout` 훅을 통해 저장되거나 Undo 스택에 쌓일 수도 있습니다. 만약 사용자가 캔버스 빈 공간을 더블클릭하여 새 노드를 만드는 UX가 있다면, 해당 이벤트에서 `useCreateCard` 뮤테이션을 호출하여 서버에 새 카드를 만들고, 이는 곧 위의 데이터 흐름에 따라 새 노드로 화면에 나타나게 됩니다.  
  6. **정리:** 페이지를 떠날 때 등에는 필요한 경우 `useIdeaMapStore`를 리셋하거나, React Query 캐시를 유지할지 전략을 정할 수 있습니다. (본 프로젝트에서는 캐시가 기본 몇 분 유지되도록 설정)

  이 IdeaMap 흐름은 전통적인 MVC로 치면 Model(TanStack Query 데이터)과 View(React Flow UI) 사이에 Controller(`useIdeaMapSync` 훅)이 끼어 있는 형태로 볼 수 있습니다. 이 컨트롤러 역할을 하는 훅 덕분에, React Flow라는 복잡한 UI 라이브러리와 우리의 상태 관리 간 연결부가 명확히 분리되었고, 기능 추가/변경도 해당 훅만 손대면 되는 이점이 생겼습니다.

### 컴포넌트 책임 분리

리팩토링 이후 각 React 컴포넌트는 **자신의 역할에 충실**하도록 책임이 분리되었습니다. 간단히 원칙을 정리하면 "컴포넌트는 **상태를 조회하고 액션을 발생시키는 일**에 집중하고, **비즈니스 로직은 훅과 서비스 레이어**에 맡긴다"입니다.

- **데이터 표시 컴포넌트:** 예를 들어 `CardList`, `TagList` 같은 컴포넌트는 화면에 데이터를 표시하는 역할입니다. 이러한 컴포넌트는 내부에서 직접 `fetch`를 호출하지 않고, `useCards`, `useTags`와 같은 커스텀 훅을 사용하여 필요한 데이터를 받아옵니다. 또한 데이터 변경이 필요할 때도 자체적으로 상태를 변경하지 않고, 적절한 뮤테이션 훅(`useDeleteCard`, `useCreateTag` 등)을 호출합니다.  
  결과적으로, 컴포넌트 코드에는 "어떤 데이터를 보여줄지"와 "어떤 동작 시 어떤 훅을 호출할지"만 남고, API 경로나 구체적인 처리 내용은 드러나지 않습니다. 이는 컴포넌트를 이해하기 쉽게 만들고, 디자이너/프론트엔드 개발자가 UI를 수정할 때 실수로 비즈니스 로직을 망가뜨릴 위험을 줄여줍니다.

- **폼/모달 컴포넌트:** 폼 입력을 받는 컴포넌트(예: 카드 생성 모달, 로그인 폼 등)는 사용자 입력을 받아 유효성 검증 후, onSubmit 시점에 서비스 레이어 호출을 트리거합니다. 이때도 직접 서비스 함수를 부르는 대신 대응되는 TanStack Query **뮤테이션 훅**을 사용합니다. 훅을 사용함으로써 로딩/에러 상태를 쉽게 관리할 수 있고, 성공 시 후속 처리(모달 닫기 등)도 `onSuccess` 내에서 제어 가능합니다.

- **상태 제어 전용 컴포넌트:** 일부 컴포넌트는 UI 보조 역할로 전역 상태를 제어할 수 있습니다. 예를 들어 다크모드 토글 스위치는 `useAppStore`의 `theme` 상태를 토글하는데만 전념합니다. 이 컴포넌트는 복잡한 로직이 없고 단순히 Zustand 액션을 호출하는 버튼일 뿐입니다. 이런 컴포넌트는 작고 재사용 가능하며, 필요시 어디서든 끼워넣을 수 있습니다.

- **React Flow 관련 컴포넌트:** IdeaMap처럼 서드파티 UI 라이브러리를 래핑한 컴포넌트의 경우, 내부에서 `useIdeaMapSync`, `useIdeaMapInteractions` 등을 사용하여 필요한 데이터와 이벤트 핸들러를 모두 얻습니다. 그리고 그를 React Flow 컴포넌트 속성으로 전달하여 초기화합니다. 이 컴포넌트 역시 자신이 비즈니스 로직을 가지지 않고 훅에 의존하여 행동합니다.

정리하면, **컴포넌트 = UI + 훅 조합**으로 보고, 훅이 사실상 컴포넌트의 컨트롤러이자 모델 역할을 합니다. 이런 구조에서는 컴포넌트를 단순히 순수 함수형 뷰로 테스트할 수 있고, 훅은 별도로 로직을 테스트할 수 있어 **테스트 가능성**도 향상됩니다.

### 테스트 전략

리팩토링된 아키텍처는 테스트 작성에 적합하도록 계층이 분리되어 있습니다. 각 계층 및 기능별로 다음과 같은 **테스트 전략**을 수립합니다:

- **유닛 테스트 (Unit Tests):**  
  - *서비스 함수 테스트:* `src/services`의 각 함수에 대한 테스트를 작성합니다. 예를 들어 `cardService.fetchCards`가 정상적으로 API 호출을 하고, 올바른 데이터를 반환하거나 에러를 처리하는지 모킹을 통해 검증합니다. 이때 실제 네트워크를 호출하지 않도록 fetch/Supabase 클라이언트를 모의 객체로 대체하고, 예상되는 응답을 흉내내어 함수의 동작을 확인합니다.  
  - *Zustand 스토어 테스트:* 슬라이스별로 주요 액션이 상태를 제대로 변경하는지 테스트합니다. 예를 들어 `useAppStore`의 `toggleSidebar` 호출 후 `isSidebarOpen` 값이 바뀌는지, `selectCards`로 특정 카드 ID 배열을 넣었을 때 상태가 정확히 반영되는지 등을 확인합니다. Zustand는 함수 호출로 상태를 가져올 수 있으므로 간단히 검증할 수 있습니다.  
  - *유틸리티 함수 테스트:* `cardsToCardNodes`와 같은 데이터 변환 함수나, `getLayoutedElements` 같은 알고리즘 함수가 있다면 입력 대비 출력이 기대대로 나오는지 테스트 케이스를 작성합니다.

- **통합 테스트 (Integration Tests):**  
  - *훅 테스트:* React Testing Library와 Jest를 활용하여 커스텀 훅들을 테스트합니다. 예를 들어 `useCards` 훅을 테스트할 때는 QueryClientProvider로 감싼 가상 컴포넌트를 렌더링하고, MSW(Mock Service Worker) 등을 활용해 `/api/cards` 호출에 대한 가짜 응답을 준 뒤, 훅이 반환하는 데이터와 로딩 상태 변화를 검증합니다. 뮤테이션 훅 (`useCreateCard` 등)도 호출 후 캐시 invalidate가 일어나는지를 QueryClient의 상태를 살펴 검증할 수 있습니다.  
  - *컴포넌트 테스트:* 주요 컴포넌트에 대해 실제 DOM 렌더링과 사용자 시뮬레이션을 통한 테스트를 실시합니다. 예를 들어 `CardList` 컴포넌트를 테스트하면서, 내부에 mock된 `useCards` 훅 결과를 주입하여 카드 아이템들이 렌더되는지 확인하고, 삭제 버튼 클릭 시 `useDeleteCard`의 mutate가 호출되었는지 등을 spy를 통해 검증합니다. React Testing Library의 `fireEvent`나 `userEvent`로 사용자 액션을 흉내 내고, 화면 변화를 expect합니다.  
  - *페이지/라우트 테스트:* Next.js의 페이지 컴포넌트 (예: `page.tsx` 등)나 중요한 라우트에 대해, 페이지 전체를 렌더링한 후 요소들이 제대로 표시되는지, 라우트 이동 또는 폼 전송 등 핵심 시나리오가 잘 동작하는지 테스트합니다. 필요하면 Next.js의 테스트 유틸이나 MSW로 Server Action/API 응답을 흉내냅니다.

- **E2E 테스트 (필요시):**  
  아키텍처 리팩토링 범위에서는 직접 다루지 않았지만, 추후 Playwright, Cypress 등을 통해 실제 브라우저 상에서의 end-to-end 테스트를 구축할 수 있습니다. 중요한 사용자 흐름(로그인 -> 카드 생성 -> IdeaMap 반영)을 자동화하여 회귀를 방지합니다.

테스트 작성 시 유의사항은 **AI 협업**과도 연결됩니다. 테스트 코드는 요구사항의 명세서 역할도 하기 때문에, AI 에이전트가 오해하지 않도록 행동의 기대치를 명확히 드러내야 합니다. 예를 들어 테스트 함수 이름을 `it('creates a new card and updates the list')`처럼 작성하면, 코드 자체에 설명이 되므로 협업에 도움이 됩니다.

### AI 협업 가이드

Backyard 프로젝트는 개발 보조로 **Cursor AI 에이전트**를 사용하고 있으므로, AI와 원활히 협업하기 위한 몇 가지 코드 원칙을 따릅니다:

- **파일 크기 제한 준수:** 각 파일의 길이는 가급적 500 lines of code 이하로 유지합니다. 이는 AI 컨텍스트 윈도우 제한을 고려한 것으로, 한 파일이 너무 길면 AI가 모든 내용을 읽지 못하거나 혼동할 수 있습니다. 리팩토링을 통해 이미 많은 파일들이 슬라이스/훅 단위로 쪼개졌으며, 이후 기능 추가 시에도 이 원칙을 지킵니다.

- **명확한 네이밍과 일관성:** 변수, 함수, 훅, 컴포넌트 이름 등을 **의도대로 직설적으로** 짓습니다. 예를 들어 카드 생성 훅은 `useCreateCard`, 삭제 서비스 함수는 `deleteCardAPI` 등으로, 누구나 역할을 추측할 수 있게 합니다. 일관된 카멜케이스/파스칼케이스 규칙과 접두어(use, create 등) 사용으로 AI가 새로운 함수를 생성할 때 기존 패턴을 따르기 쉽게 합니다.

- **모듈화와 단일 책임:** 한 파일/함수는 되가능하면 한 가지 역할만 하도록 구성합니다. 여러 기능이 섞여 있는 경우 AI가 잘못된 편집을 할 우려가 있습니다. 이번 리팩토링으로 서비스 함수, 상태 훅, UI 컴포넌트가 각각 나뉘었으므로, 이후에도 기능이 추가되면 새로운 파일(슬라이스나 훅 등)로 모듈을 분리하는 것을 우선 고려합니다.

- **주석과 문서화:** 중요한 비즈니스 로직이나 트릭이 있는 부분에는 주석을 추가합니다. AI는 주석을 통해 의도를 파악할 수 있기 때문에, 예컨대 "// When a new node is dropped, we trigger card creation" 같은 주석은 이후 AI가 코드를 수정할 때 실수를 줄여줍니다. 또한 함수 JSDoc 주석을 간단히라도 작성하면 AI의 보조 이해에 도움이 됩니다.

- **README/아키텍처 문서의 활용:** 본 문서와 같이 아키텍처 개요를 항상 최신으로 유지하고, 새로운 팀원이나 AI에게 작업을 맡기기 전에 이 문서를 참고하도록 합니다. 예를 들어 AI에게 "태그에 새로운 속성을 추가해 주세요"라는 작업을 시킬 때, 아키텍처 문서를 먼저 읽히게 하면 어떤 파일들을 수정해야 할지, 어떤 패턴을 따라야 할지 더 잘 파악할 수 있습니다.

- **일괄적인 코드 스타일:** Prettier, ESLint 등의 도구를 활용하여 코드 스타일을 자동으로 정렬합니다. 들여쓰기, 따옴표 사용, 세미콜론 등 사소한 스타일에서 일관성을 유지하면 AI도 이에 맞춰 코드를 생성합니다. ESLint 룰은 가능한 엄격하게 해서, AI가 잠재적 오류나 anti-pattern을 도입했을 때 바로잡도록 합니다.

- **AI 피드백 루프:** 커밋 메시지나 PR 설명 등에 "AI"에 대한 언급이나 간단한 설명을 추가하여, 나중에 AI가 코드 변화 이력을 볼 경우 도움이 되도록 합니다. (예: "Refactor: Migrate tag management to React Query (by AI assist)" 등) 이는 추후 AI가 맥락을 이해하는 데 작은 힌트가 될 수 있습니다.

요약하면, **코드의 단순명료함이 곧 AI 협업 최적화**입니다. 사람이 보기에 이해하기 쉬운 코드는 AI에게도 그렇습니다. 따라서 우리가 유지보수하기 좋은 코드를 작성하는 것이 그대로 AI와 함께 작업하기 좋은 환경을 만드는 길입니다. (500 LoC 제한 등은 그중 하나의 구체적 지침일 뿐입니다.)

### API 라우트 및 서버 액션 혼용 전략 (하이브리드 구조)

Next.js의 **API Routes**와 **Server Actions**를 모두 활용하는 하이브리드 구조를 채택하여, 내부와 외부 요구사항을 동시에 만족합니다.

- **내부 호출 - Server Actions 우선:** Frontend UI에서 발생하는 데이터 변경이나 조회는 가급적 Server Action을 통해 처리합니다. Server Action은 Next.js 13의 기능으로, 클라이언트 컴포넌트에서 직접 서버 함수를 호출할 수 있게 해주며, 별도의 HTTP 요청 없이 서버 로직을 실행합니다 ([Introduction to Next.js Server Actions](https://makerkit.dev/blog/tutorials/nextjs-server-actions#:~:text=One%20of%20the%20most%20exciting,to%20be%20a%20game%20changer)). 예를 들어 새로운 카드를 생성할 때 UI에서 Server Action `createCardAction`을 호출하면, 서버에서 DB에 카드가 추가되고 바로 결과를 돌려받을 수 있습니다. 이 과정에서 네트워크 요청 overhead가 줄고, 보안적으로도 클라이언트에 민감 정보가 드러나지 않는 장점이 있습니다. 우리의 TanStack Query 훅(`useCreateCard`)도 내부적으로 mutation 시 `createCardAction`을 사용할 수 있고, 성공 시 Query 캐시를 갱신하는 구조로 동작하게 할 수 있습니다.

- **외부 호출 - API Routes 유지:** 외부 시스템이나 별도의 클라이언트(예: 모바일 앱, 다른 서비스 연동)가 우리 백엔드를 사용해야 하는 경우, Next.js API Route를 통해 RESTful API 형태로 서비스를 제공합니다. 예컨대 `/api/cards` 엔드포인트는 그대로 유지하여, 만약 다른 서비스가 HTTP로 카드 목록을 요청하면 응답을 받을 수 있습니다. 내부적으로 이 API Route의 구현에서도 `cardService.fetchCards`를 호출하도록 하여 로직은 동일합니다.  
  중요한 것은 **내부 UI와 외부 API 사용자가 동일한 결과를 얻도록** 이중 경로를 관리하는 것입니다. 따라서 API Route 핸들러와 Server Action 함수는 가능한 같은 서비스 레이어를 공유하며, 권한 체크 등도 같은 기준으로 적용합니다.

- **권한 및 인증:** Server Action을 사용할 때는 내부적으로 현재 사용자 세션 정보가 포함되어 있어야 합니다. Next.js는 Server Action 호출 시 자동으로 해당 요청 컨텍스트를 전달하므로, `createCardAction` 함수 내에서 `cookies`나 `headers`를 통해 세션을 확인하거나 `supabase/server` 클라이언트를 생성할 수 있습니다. API Route의 경우 `req` 객체에 포함된 쿠키로 인증을 확인합니다. 두 경우 모두 Supabase의 인증 미들웨어를 통해 공통된 방식으로 인증 상태를 파악하므로, **동일한 권한 로직**이 적용됩니다.

- **응답 일관성:** Server Action은 함수 호출이므로, 에러가 발생하면 예외를 throw하거나, 결과를 반환하면 바로 객체를 리턴합니다. API Route는 JSON 형태로 응답을 보내게 됩니다. 우리의 서비스 레이어는 `{ success, data, error }` 형식을 사용하므로, Server Action에서는 이 객체를 그대로 리턴하고, API Route에서는 이를 JSON으로 `res.json()`에 담아주는 식으로 구현합니다. 이렇게 하면 클라이언트(TanStack Query 훅)에서는 Server Action을 호출해도 동일한 구조의 객체를 받게 되고, API로 받아도 같은 구조이므로 처리 로직을 재사용할 수 있습니다.

- **사용 시나리오 구분:** 일반적으로 **페이지 접속 시 데이터 패칭**은 React Query로 SSR/CSR 모두 처리하게 하고, **사용자 상호작용으로 인한 변화**는 Server Action으로 처리하는 것을 권장합니다. 예를 들어 페이지를 열 때 카드 목록을 가져오는 건 `useCards`(-> fetch to API or direct DB), but 카드 생성/수정은 server action. 다만 TanStack Query의 뮤테이션 안에 server action 호출을 넣으면 결국 fetch와 유사하게 Promise를 다루는 것이므로 구현 패턴은 크게 다르지 않습니다.

- **예외 - Third-party webhook 등:** 만약 외부에서 호출해야 하는 특별한 엔드포인트 (예: Webhook 수신) 등이 있다면 그 부분은 API Route로 유지해야 합니다. 이러한 엔드포인트는 Next.js App 라우터의 Server Action으로 처리할 수 없기 때문에 (외부에서는 그냥 HTTP POST를 할 테니), 기존처럼 `/api/...`에 라우트를 만들고 처리합니다. 이 역시 서비스 레이어를 호출하여 다른 로직과 통합합니다.

정리하면, **내부적으로는 Server Actions로 빠르고 직접적으로 처리**하고 **외부적으로는 RESTful API를 유지**하는 형태입니다. 이 하이브리드 접근은 Next.js 앱이 커다란 백엔드 서비스를 겸할 때 유용하며, 우리 프로젝트도 그 방향으로 대비하고 있습니다. 개발할 때는 "이 기능을 우리 앱 UI에서도 쓰고, 외부에서도 쓸 수 있을까?"를 염두에 두고, 그렇다면 API Route도 만들어주거나 기존 것을 유지하고, 아니면 서버 액션만 구현하는 식으로 case-by-case로 적용합니다.

